/* tslint:disable */
/* eslint-disable */
/**
 * Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../../base';
// @ts-ignore
import type { AutoCleanUpDataWrapper } from '../../models';
// @ts-ignore
import type { AutoCleanupRequestDto } from '../../models';
// @ts-ignore
import type { BooleanWrapper } from '../../models';
// @ts-ignore
import type { CheckDocServiceUrlRequestDto } from '../../models';
// @ts-ignore
import type { DisplayRequestDto } from '../../models';
// @ts-ignore
import type { DocServiceUrlWrapper } from '../../models';
// @ts-ignore
import type { FileShareArrayWrapper } from '../../models';
// @ts-ignore
import type { FilesSettingsWrapper } from '../../models';
// @ts-ignore
import type { HideConfirmConvertRequestDto } from '../../models';
// @ts-ignore
import type { ICompressWrapper } from '../../models';
// @ts-ignore
import type { ModuleWrapper } from '../../models';
// @ts-ignore
import type { SettingsRequestDto } from '../../models';
/**
 * FilesSettingsApi - axios parameter creator
 * @export
 */
export const FilesSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes the access to the third-party settings.
         * @summary Change the third-party settings access
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccessToThirdparty: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the trash bin auto-clearing setting.
         * @summary Update the trash bin auto-clearing setting
         * @param {AutoCleanupRequestDto} [autoCleanupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAutomaticallyCleanUp: async (autoCleanupRequestDto?: AutoCleanupRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/autocleanup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoCleanupRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the default access rights in the sharing settings.
         * @summary Change the default access rights
         * @param {Array<number>} [requestBody] Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDefaultAccessRights: async (requestBody?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/dafaultaccessrights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies whether to confirm the file deletion or not.
         * @summary Confirm the file deletion
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDeleteConfirm: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/changedeleteconfrim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the format of the downloaded archive from .zip to .tar.gz. This method uses the body parameters.
         * @summary Change the archive format (using body parameters)
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDownloadZipFromBody: async (displayRequestDto?: DisplayRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/downloadtargz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(displayRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks the document service location URL.
         * @summary Check the document service URL
         * @param {CheckDocServiceUrlRequestDto} [checkDocServiceUrlRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDocServiceUrl: async (checkDocServiceUrlRequestDto?: CheckDocServiceUrlRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/docservice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkDocServiceUrlRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies whether to display a file extension or not.
         * @summary Display a file extension
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayFileExtension: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/displayfileextension`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to share a file externally.
         * @summary Change the external sharing ability
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalShare: async (displayRequestDto?: DisplayRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/external`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(displayRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to share a file externally on social networks.
         * @summary Change the external sharing ability on social networks
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalShareSocialMedia: async (displayRequestDto?: DisplayRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/externalsocialmedia`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(displayRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies if the file forcesaving is enabled or not.
         * @summary Change the forcesaving ability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forcesave: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/forcesave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the trash bin auto-clearing setting.
         * @summary Get the trash bin auto-clearing setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomaticallyCleanUp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/autocleanup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the URL address of the connected editors.
         * @summary Get the document service URL
         * @param {boolean} [version] Specifies whether to return the editor version or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocServiceUrl: async (version?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/docservice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the information about the \"Documents\" module.
         * @summary Get the \"Documents\" information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesModule: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the file settings.
         * @summary Get file settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides the confirmation dialog when canceling operations.
         * @summary Hide confirmation dialog when canceling operations
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmCancelOperation: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/hideconfirmcanceloperation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides the confirmation dialog for saving the file copy in the original format when converting a file.
         * @summary Hide the confirmation dialog when converting
         * @param {HideConfirmConvertRequestDto} [hideConfirmConvertRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmConvert: async (hideConfirmConvertRequestDto?: HideConfirmConvertRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/hideconfirmconvert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hideConfirmConvertRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides the confirmation dialog when changing the room lifetime settings.
         * @summary Hide confirmation dialog when changing room lifetime settings
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmRoomLifetime: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/hideconfirmroomlifetime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the \"Private Room\" settings are available or not.
         * @summary Check the \"Private Room\" availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAvailablePrivacyRoomSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@privacy/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies whether to ask a user for a file name on creation or not.
         * @summary Ask a new file name
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keepNewFileName: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/keepnewfilename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to open the document in the same browser tab.
         * @summary Open document in the same browser tab
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOpenEditorInSameTab: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/openeditorinsametab`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to store the forcesaved file versions.
         * @summary Change the ability to store the forcesaved files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeForcesave: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/storeforcesave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to upload documents in the original formats as well.
         * @summary Change the ability to upload original formats
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOriginal: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/storeoriginal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a file version if a file with such a name already exists.
         * @summary Update a file version if it exists
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIfExist: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/updateifexist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write"], configuration)

            // authentication ApiKeyBearer required
            await setApiKeyToObject(localVarHeaderParameter, "ApiKeyBearer", configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesSettingsApi - functional programming interface
 * @export
 */
export const FilesSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Changes the access to the third-party settings.
         * @summary Change the third-party settings access
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAccessToThirdparty(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeAccessToThirdparty(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeAccessToThirdparty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the trash bin auto-clearing setting.
         * @summary Update the trash bin auto-clearing setting
         * @param {AutoCleanupRequestDto} [autoCleanupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAutomaticallyCleanUp(autoCleanupRequestDto?: AutoCleanupRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoCleanUpDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeAutomaticallyCleanUp(autoCleanupRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeAutomaticallyCleanUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the default access rights in the sharing settings.
         * @summary Change the default access rights
         * @param {Array<number>} [requestBody] Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDefaultAccessRights(requestBody?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDefaultAccessRights(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeDefaultAccessRights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies whether to confirm the file deletion or not.
         * @summary Confirm the file deletion
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDeleteConfirm(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDeleteConfirm(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeDeleteConfirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the format of the downloaded archive from .zip to .tar.gz. This method uses the body parameters.
         * @summary Change the archive format (using body parameters)
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDownloadZipFromBody(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICompressWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDownloadZipFromBody(displayRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeDownloadZipFromBody']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks the document service location URL.
         * @summary Check the document service URL
         * @param {CheckDocServiceUrlRequestDto} [checkDocServiceUrlRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDocServiceUrl(checkDocServiceUrlRequestDto?: CheckDocServiceUrlRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocServiceUrlWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDocServiceUrl(checkDocServiceUrlRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.checkDocServiceUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies whether to display a file extension or not.
         * @summary Display a file extension
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayFileExtension(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayFileExtension(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.displayFileExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to share a file externally.
         * @summary Change the external sharing ability
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalShare(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalShare(displayRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.externalShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to share a file externally on social networks.
         * @summary Change the external sharing ability on social networks
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalShareSocialMedia(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalShareSocialMedia(displayRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.externalShareSocialMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies if the file forcesaving is enabled or not.
         * @summary Change the forcesaving ability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forcesave(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forcesave(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.forcesave']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the trash bin auto-clearing setting.
         * @summary Get the trash bin auto-clearing setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutomaticallyCleanUp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoCleanUpDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutomaticallyCleanUp(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.getAutomaticallyCleanUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the URL address of the connected editors.
         * @summary Get the document service URL
         * @param {boolean} [version] Specifies whether to return the editor version or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocServiceUrl(version?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocServiceUrlWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocServiceUrl(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.getDocServiceUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the information about the \"Documents\" module.
         * @summary Get the \"Documents\" information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilesModule(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesModule(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.getFilesModule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all the file settings.
         * @summary Get file settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilesSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.getFilesSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hides the confirmation dialog when canceling operations.
         * @summary Hide confirmation dialog when canceling operations
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideConfirmCancelOperation(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideConfirmCancelOperation(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.hideConfirmCancelOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hides the confirmation dialog for saving the file copy in the original format when converting a file.
         * @summary Hide the confirmation dialog when converting
         * @param {HideConfirmConvertRequestDto} [hideConfirmConvertRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideConfirmConvert(hideConfirmConvertRequestDto?: HideConfirmConvertRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideConfirmConvert(hideConfirmConvertRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.hideConfirmConvert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hides the confirmation dialog when changing the room lifetime settings.
         * @summary Hide confirmation dialog when changing room lifetime settings
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideConfirmRoomLifetime(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideConfirmRoomLifetime(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.hideConfirmRoomLifetime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the \"Private Room\" settings are available or not.
         * @summary Check the \"Private Room\" availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAvailablePrivacyRoomSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAvailablePrivacyRoomSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.isAvailablePrivacyRoomSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies whether to ask a user for a file name on creation or not.
         * @summary Ask a new file name
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keepNewFileName(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keepNewFileName(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.keepNewFileName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to open the document in the same browser tab.
         * @summary Open document in the same browser tab
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOpenEditorInSameTab(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOpenEditorInSameTab(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.setOpenEditorInSameTab']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to store the forcesaved file versions.
         * @summary Change the ability to store the forcesaved files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeForcesave(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeForcesave(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.storeForcesave']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to upload documents in the original formats as well.
         * @summary Change the ability to upload original formats
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeOriginal(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeOriginal(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.storeOriginal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a file version if a file with such a name already exists.
         * @summary Update a file version if it exists
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIfExist(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIfExist(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.updateIfExist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesSettingsApi - factory interface
 * @export
 */
export const FilesSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesSettingsApiFp(configuration)
    return {
        /**
         * Changes the access to the third-party settings.
         * @summary Change the third-party settings access
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccessToThirdparty(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.changeAccessToThirdparty(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the trash bin auto-clearing setting.
         * @summary Update the trash bin auto-clearing setting
         * @param {AutoCleanupRequestDto} [autoCleanupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAutomaticallyCleanUp(autoCleanupRequestDto?: AutoCleanupRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<AutoCleanUpDataWrapper> {
            return localVarFp.changeAutomaticallyCleanUp(autoCleanupRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the default access rights in the sharing settings.
         * @summary Change the default access rights
         * @param {Array<number>} [requestBody] Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDefaultAccessRights(requestBody?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<FileShareArrayWrapper> {
            return localVarFp.changeDefaultAccessRights(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies whether to confirm the file deletion or not.
         * @summary Confirm the file deletion
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDeleteConfirm(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.changeDeleteConfirm(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the format of the downloaded archive from .zip to .tar.gz. This method uses the body parameters.
         * @summary Change the archive format (using body parameters)
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDownloadZipFromBody(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ICompressWrapper> {
            return localVarFp.changeDownloadZipFromBody(displayRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks the document service location URL.
         * @summary Check the document service URL
         * @param {CheckDocServiceUrlRequestDto} [checkDocServiceUrlRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDocServiceUrl(checkDocServiceUrlRequestDto?: CheckDocServiceUrlRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<DocServiceUrlWrapper> {
            return localVarFp.checkDocServiceUrl(checkDocServiceUrlRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies whether to display a file extension or not.
         * @summary Display a file extension
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayFileExtension(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.displayFileExtension(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to share a file externally.
         * @summary Change the external sharing ability
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalShare(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.externalShare(displayRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to share a file externally on social networks.
         * @summary Change the external sharing ability on social networks
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalShareSocialMedia(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.externalShareSocialMedia(displayRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies if the file forcesaving is enabled or not.
         * @summary Change the forcesaving ability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forcesave(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.forcesave(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the trash bin auto-clearing setting.
         * @summary Get the trash bin auto-clearing setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomaticallyCleanUp(options?: RawAxiosRequestConfig): AxiosPromise<AutoCleanUpDataWrapper> {
            return localVarFp.getAutomaticallyCleanUp(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the URL address of the connected editors.
         * @summary Get the document service URL
         * @param {boolean} [version] Specifies whether to return the editor version or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocServiceUrl(version?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<DocServiceUrlWrapper> {
            return localVarFp.getDocServiceUrl(version, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the information about the \"Documents\" module.
         * @summary Get the \"Documents\" information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesModule(options?: RawAxiosRequestConfig): AxiosPromise<ModuleWrapper> {
            return localVarFp.getFilesModule(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the file settings.
         * @summary Get file settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesSettings(options?: RawAxiosRequestConfig): AxiosPromise<FilesSettingsWrapper> {
            return localVarFp.getFilesSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Hides the confirmation dialog when canceling operations.
         * @summary Hide confirmation dialog when canceling operations
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmCancelOperation(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.hideConfirmCancelOperation(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Hides the confirmation dialog for saving the file copy in the original format when converting a file.
         * @summary Hide the confirmation dialog when converting
         * @param {HideConfirmConvertRequestDto} [hideConfirmConvertRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmConvert(hideConfirmConvertRequestDto?: HideConfirmConvertRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ModuleWrapper> {
            return localVarFp.hideConfirmConvert(hideConfirmConvertRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Hides the confirmation dialog when changing the room lifetime settings.
         * @summary Hide confirmation dialog when changing room lifetime settings
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmRoomLifetime(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.hideConfirmRoomLifetime(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the \"Private Room\" settings are available or not.
         * @summary Check the \"Private Room\" availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAvailablePrivacyRoomSettings(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.isAvailablePrivacyRoomSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies whether to ask a user for a file name on creation or not.
         * @summary Ask a new file name
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keepNewFileName(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.keepNewFileName(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to open the document in the same browser tab.
         * @summary Open document in the same browser tab
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOpenEditorInSameTab(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.setOpenEditorInSameTab(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to store the forcesaved file versions.
         * @summary Change the ability to store the forcesaved files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeForcesave(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.storeForcesave(options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to upload documents in the original formats as well.
         * @summary Change the ability to upload original formats
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOriginal(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.storeOriginal(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a file version if a file with such a name already exists.
         * @summary Update a file version if it exists
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIfExist(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.updateIfExist(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesSettingsApi - object-oriented interface
 * @export
 * @class FilesSettingsApi
 * @extends {BaseAPI}
 */
export class FilesSettingsApi extends BaseAPI {
    /**
     * Changes the access to the third-party settings.
     * @summary Change the third-party settings access
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeAccessToThirdparty(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeAccessToThirdparty(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the trash bin auto-clearing setting.
     * @summary Update the trash bin auto-clearing setting
     * @param {AutoCleanupRequestDto} [autoCleanupRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeAutomaticallyCleanUp(autoCleanupRequestDto?: AutoCleanupRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeAutomaticallyCleanUp(autoCleanupRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the default access rights in the sharing settings.
     * @summary Change the default access rights
     * @param {Array<number>} [requestBody] Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeDefaultAccessRights(requestBody?: Array<number>, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeDefaultAccessRights(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies whether to confirm the file deletion or not.
     * @summary Confirm the file deletion
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeDeleteConfirm(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeDeleteConfirm(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the format of the downloaded archive from .zip to .tar.gz. This method uses the body parameters.
     * @summary Change the archive format (using body parameters)
     * @param {DisplayRequestDto} [displayRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeDownloadZipFromBody(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeDownloadZipFromBody(displayRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks the document service location URL.
     * @summary Check the document service URL
     * @param {CheckDocServiceUrlRequestDto} [checkDocServiceUrlRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public checkDocServiceUrl(checkDocServiceUrlRequestDto?: CheckDocServiceUrlRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).checkDocServiceUrl(checkDocServiceUrlRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies whether to display a file extension or not.
     * @summary Display a file extension
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public displayFileExtension(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).displayFileExtension(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to share a file externally.
     * @summary Change the external sharing ability
     * @param {DisplayRequestDto} [displayRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public externalShare(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).externalShare(displayRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to share a file externally on social networks.
     * @summary Change the external sharing ability on social networks
     * @param {DisplayRequestDto} [displayRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public externalShareSocialMedia(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).externalShareSocialMedia(displayRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies if the file forcesaving is enabled or not.
     * @summary Change the forcesaving ability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public forcesave(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).forcesave(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the trash bin auto-clearing setting.
     * @summary Get the trash bin auto-clearing setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public getAutomaticallyCleanUp(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).getAutomaticallyCleanUp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the URL address of the connected editors.
     * @summary Get the document service URL
     * @param {boolean} [version] Specifies whether to return the editor version or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public getDocServiceUrl(version?: boolean, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).getDocServiceUrl(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the information about the \"Documents\" module.
     * @summary Get the \"Documents\" information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public getFilesModule(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).getFilesModule(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the file settings.
     * @summary Get file settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public getFilesSettings(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).getFilesSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hides the confirmation dialog when canceling operations.
     * @summary Hide confirmation dialog when canceling operations
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public hideConfirmCancelOperation(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).hideConfirmCancelOperation(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hides the confirmation dialog for saving the file copy in the original format when converting a file.
     * @summary Hide the confirmation dialog when converting
     * @param {HideConfirmConvertRequestDto} [hideConfirmConvertRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public hideConfirmConvert(hideConfirmConvertRequestDto?: HideConfirmConvertRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).hideConfirmConvert(hideConfirmConvertRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hides the confirmation dialog when changing the room lifetime settings.
     * @summary Hide confirmation dialog when changing room lifetime settings
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public hideConfirmRoomLifetime(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).hideConfirmRoomLifetime(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the \"Private Room\" settings are available or not.
     * @summary Check the \"Private Room\" availability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public isAvailablePrivacyRoomSettings(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).isAvailablePrivacyRoomSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies whether to ask a user for a file name on creation or not.
     * @summary Ask a new file name
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public keepNewFileName(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).keepNewFileName(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to open the document in the same browser tab.
     * @summary Open document in the same browser tab
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public setOpenEditorInSameTab(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).setOpenEditorInSameTab(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to store the forcesaved file versions.
     * @summary Change the ability to store the forcesaved files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public storeForcesave(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).storeForcesave(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to upload documents in the original formats as well.
     * @summary Change the ability to upload original formats
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public storeOriginal(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).storeOriginal(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a file version if a file with such a name already exists.
     * @summary Update a file version if it exists
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public updateIfExist(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).updateIfExist(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

