/* tslint:disable */
/* eslint-disable */
/**
 * Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ApiDateTime } from '../models';
// @ts-ignore
import type { ApplyFilterOption } from '../models';
// @ts-ignore
import type { CheckUploadRequest } from '../models';
// @ts-ignore
import type { CreateFolder } from '../models';
// @ts-ignore
import type { DeleteFolder } from '../models';
// @ts-ignore
import type { FileEntryArrayWrapper } from '../models';
// @ts-ignore
import type { FileIntegerWrapper } from '../models';
// @ts-ignore
import type { FileOperationArrayWrapper } from '../models';
// @ts-ignore
import type { FileShareWrapper } from '../models';
// @ts-ignore
import type { FilesStatisticsResultWrapper } from '../models';
// @ts-ignore
import type { FilterType } from '../models';
// @ts-ignore
import type { FolderContentIntegerArrayWrapper } from '../models';
// @ts-ignore
import type { FolderContentIntegerWrapper } from '../models';
// @ts-ignore
import type { FolderIntegerWrapper } from '../models';
// @ts-ignore
import type { FormsItemArrayWrapper } from '../models';
// @ts-ignore
import type { HistoryArrayWrapper } from '../models';
// @ts-ignore
import type { ObjectWrapper } from '../models';
// @ts-ignore
import type { OrderRequestDto } from '../models';
// @ts-ignore
import type { STRINGArrayWrapper } from '../models';
// @ts-ignore
import type { SearchArea } from '../models';
// @ts-ignore
import type { UploadRequestDto } from '../models';
/**
 * FilesFoldersApi - axios parameter creator
 * @export
 */
export const FilesFoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks the file uploads to the folder with the ID specified in the request.
         * @summary Check file uploads
         * @param {number} folderId The folder ID.
         * @param {CheckUploadRequest} [checkUploadRequest] The request parameters for checking file uploads.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUpload: async (folderId: number, checkUploadRequest?: CheckUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('checkUpload', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/upload/check`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new folder with the title specified in the request. The parent folder ID can be also specified.
         * @summary Create a folder
         * @param {number} folderId The folder ID for the folder creation.
         * @param {CreateFolder} [createFolder] The parameters for creating a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (folderId: number, createFolder?: CreateFolder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createFolder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFolder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a folder with the ID specified in the request.
         * @summary Delete a folder
         * @param {number} folderId The folder ID to delete.
         * @param {DeleteFolder} [deleteFolder] The parameters for deleting a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId: number, deleteFolder?: DeleteFolder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteFolder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the used space of files in the root folders.
         * @summary Get used space of files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesUsedSpace: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/filesusedspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the form filter of a folder with the ID specified in the request.
         * @summary Get folder form filter
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/formfilter`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed list of files and folders located in the folder with the ID specified in the request.
         * @summary Get a folder by ID
         * @param {number} folderId The folder ID of the request.
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {number} [roomId] The room ID.
         * @param {boolean} [excludeSubject] Specifies whether to exclude search by user or group ID.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder.
         * @param {string} [extension] Specifies whether to search for the specific file extension.
         * @param {SearchArea} [searchArea] The search area.
         * @param {string} [formsItemKey] The forms item key.
         * @param {string} [formsItemType] The forms item type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderByFolderId: async (folderId: number, userIdOrGroupId?: string, filterType?: FilterType, roomId?: number, excludeSubject?: boolean, applyFilterOption?: ApplyFilterOption, extension?: string, searchArea?: SearchArea, formsItemKey?: string, formsItemType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderByFolderId', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (roomId !== undefined) {
                localVarQueryParameter['roomId'] = roomId;
            }

            if (excludeSubject !== undefined) {
                localVarQueryParameter['excludeSubject'] = excludeSubject;
            }

            if (applyFilterOption !== undefined) {
                localVarQueryParameter['applyFilterOption'] = applyFilterOption;
            }

            if (extension !== undefined) {
                localVarQueryParameter['extension'] = extension;
            }

            if (searchArea !== undefined) {
                localVarQueryParameter['searchArea'] = searchArea;
            }

            if (formsItemKey !== undefined) {
                localVarQueryParameter['formsItemKey'] = formsItemKey;
            }

            if (formsItemType !== undefined) {
                localVarQueryParameter['formsItemType'] = formsItemType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the activity history of a folder with a specified identifier.
         * @summary Get folder history
         * @param {number} folderId The folder ID of the history request.
         * @param {ApiDateTime} [fromDate] The start date of the history request.
         * @param {ApiDateTime} [toDate] The end date of the history request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory: async (folderId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderHistory', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}/log`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required

            if (fromDate !== undefined) {
                for (const [key, value] of Object.entries(fromDate)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (toDate !== undefined) {
                for (const [key, value] of Object.entries(toDate)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about a folder with the ID specified in the request.
         * @summary Get folder information
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderInfo: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderInfo', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a path to the folder with the ID specified in the request.
         * @summary Get the folder path
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPath: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderPath', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}/path`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPrimaryExternalLink: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFolderPrimaryExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/folder/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the subfolders from a folder with the ID specified in the request.
         * @summary Get subfolders
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolders', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/subfolders`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed list of files and folders located in the \"My documents\" section.
         * @summary Get the \"My documents\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyFolder: async (userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (applyFilterOption !== undefined) {
                localVarQueryParameter['applyFilterOption'] = applyFilterOption;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the new items from a folder with the ID specified in the request.
         * @summary Get new folder items
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewItems: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getNewItems', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/news`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed list of files and folders located in the \"Private Room\" section.
         * @summary Get the \"Private Room\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacyFolder: async (userIdOrGroupId?: string, filterType?: FilterType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@privacy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the sections matching the parameters specified in the request.
         * @summary Get filtered sections
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {boolean} [withoutTrash] Specifies whether to return the \&quot;Trash\&quot; section or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolders: async (userIdOrGroupId?: string, filterType?: FilterType, withoutTrash?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (withoutTrash !== undefined) {
                localVarQueryParameter['withoutTrash'] = withoutTrash;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed list of files and folders located in the \"Trash\" section.
         * @summary Get the \"Trash\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrashFolder: async (userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@trash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (applyFilterOption !== undefined) {
                localVarQueryParameter['applyFilterOption'] = applyFilterOption;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts a file specified in the request to the selected folder by single file uploading.
         * @summary Insert a file
         * @param {number} folderId The folder ID for inserting a file.
         * @param {File} [insertFileFile] The file to be inserted.
         * @param {string} [insertFileTitle] The file title to be inserted.
         * @param {boolean} [insertFileCreateNewIfExist] Specifies whether to create a new file if it already exists or not.
         * @param {boolean} [insertFileKeepConvertStatus] Specifies whether to keep the file converting status or not.
         * @param {boolean} [insertFileStreamCanRead] 
         * @param {boolean} [insertFileStreamCanWrite] 
         * @param {boolean} [insertFileStreamCanSeek] 
         * @param {boolean} [insertFileStreamCanTimeout] 
         * @param {number} [insertFileStreamLength] 
         * @param {number} [insertFileStreamPosition] 
         * @param {number} [insertFileStreamReadTimeout] 
         * @param {number} [insertFileStreamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertFile: async (folderId: number, insertFileFile?: File, insertFileTitle?: string, insertFileCreateNewIfExist?: boolean, insertFileKeepConvertStatus?: boolean, insertFileStreamCanRead?: boolean, insertFileStreamCanWrite?: boolean, insertFileStreamCanSeek?: boolean, insertFileStreamCanTimeout?: boolean, insertFileStreamLength?: number, insertFileStreamPosition?: number, insertFileStreamReadTimeout?: number, insertFileStreamWriteTimeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('insertFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/insert`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


            if (insertFileFile !== undefined) { 
                localVarFormParams.append('InsertFile.File', insertFileFile as any);
            }
    
            if (insertFileTitle !== undefined) { 
                localVarFormParams.append('InsertFile.Title', insertFileTitle as any);
            }
    
            if (insertFileCreateNewIfExist !== undefined) { 
                localVarFormParams.append('InsertFile.CreateNewIfExist', String(insertFileCreateNewIfExist) as any);
            }
    
            if (insertFileKeepConvertStatus !== undefined) { 
                localVarFormParams.append('InsertFile.KeepConvertStatus', String(insertFileKeepConvertStatus) as any);
            }
    
            if (insertFileStreamCanRead !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.CanRead', String(insertFileStreamCanRead) as any);
            }
    
            if (insertFileStreamCanWrite !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.CanWrite', String(insertFileStreamCanWrite) as any);
            }
    
            if (insertFileStreamCanSeek !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.CanSeek', String(insertFileStreamCanSeek) as any);
            }
    
            if (insertFileStreamCanTimeout !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.CanTimeout', String(insertFileStreamCanTimeout) as any);
            }
    
            if (insertFileStreamLength !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.Length', insertFileStreamLength as any);
            }
    
            if (insertFileStreamPosition !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.Position', insertFileStreamPosition as any);
            }
    
            if (insertFileStreamReadTimeout !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.ReadTimeout', insertFileStreamReadTimeout as any);
            }
    
            if (insertFileStreamWriteTimeout !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.WriteTimeout', insertFileStreamWriteTimeout as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts a file specified in the request to the \"My documents\" section by single file uploading.
         * @summary Insert a file to the \"My documents\" section
         * @param {File} [file] The file to be inserted.
         * @param {string} [title] The file title to be inserted.
         * @param {boolean} [createNewIfExist] Specifies whether to create a new file if it already exists or not.
         * @param {boolean} [keepConvertStatus] Specifies whether to keep the file converting status or not.
         * @param {boolean} [streamCanRead] 
         * @param {boolean} [streamCanWrite] 
         * @param {boolean} [streamCanSeek] 
         * @param {boolean} [streamCanTimeout] 
         * @param {number} [streamLength] 
         * @param {number} [streamPosition] 
         * @param {number} [streamReadTimeout] 
         * @param {number} [streamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertFileToMyFromBody: async (file?: File, title?: string, createNewIfExist?: boolean, keepConvertStatus?: boolean, streamCanRead?: boolean, streamCanWrite?: boolean, streamCanSeek?: boolean, streamCanTimeout?: boolean, streamLength?: number, streamPosition?: number, streamReadTimeout?: number, streamWriteTimeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/insert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
            if (title !== undefined) { 
                localVarFormParams.append('Title', title as any);
            }
    
            if (createNewIfExist !== undefined) { 
                localVarFormParams.append('CreateNewIfExist', String(createNewIfExist) as any);
            }
    
            if (keepConvertStatus !== undefined) { 
                localVarFormParams.append('KeepConvertStatus', String(keepConvertStatus) as any);
            }
    
            if (streamCanRead !== undefined) { 
                localVarFormParams.append('Stream.CanRead', String(streamCanRead) as any);
            }
    
            if (streamCanWrite !== undefined) { 
                localVarFormParams.append('Stream.CanWrite', String(streamCanWrite) as any);
            }
    
            if (streamCanSeek !== undefined) { 
                localVarFormParams.append('Stream.CanSeek', String(streamCanSeek) as any);
            }
    
            if (streamCanTimeout !== undefined) { 
                localVarFormParams.append('Stream.CanTimeout', String(streamCanTimeout) as any);
            }
    
            if (streamLength !== undefined) { 
                localVarFormParams.append('Stream.Length', streamLength as any);
            }
    
            if (streamPosition !== undefined) { 
                localVarFormParams.append('Stream.Position', streamPosition as any);
            }
    
            if (streamReadTimeout !== undefined) { 
                localVarFormParams.append('Stream.ReadTimeout', streamReadTimeout as any);
            }
    
            if (streamWriteTimeout !== undefined) { 
                localVarFormParams.append('Stream.WriteTimeout', streamWriteTimeout as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames the selected folder with a new title specified in the request.
         * @summary Rename a folder
         * @param {number} folderId The folder ID for the folder creation.
         * @param {CreateFolder} [createFolder] The parameters for creating a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameFolder: async (folderId: number, createFolder?: CreateFolder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('renameFolder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFolder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the file order in the folder with ID specified in the request.
         * @summary Set file order
         * @param {number} folderId The folder unique identifier.
         * @param {OrderRequestDto} [orderRequestDto] The folder order information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFileOrder: async (folderId: number, orderRequestDto?: OrderRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('setFileOrder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}/order`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file
         * @param {number} folderId The folder ID to upload a file.
         * @param {UploadRequestDto} [uploadRequestDto] The request parameters for uploading a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (folderId: number, uploadRequestDto?: UploadRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('uploadFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/upload`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file to the \"My documents\" section
         * @param {UploadRequestDto} [inDto] The request parameters for uploading a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileToMy: async (inDto?: UploadRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required

            if (inDto !== undefined) {
                for (const [key, value] of Object.entries(inDto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesFoldersApi - functional programming interface
 * @export
 */
export const FilesFoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesFoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks the file uploads to the folder with the ID specified in the request.
         * @summary Check file uploads
         * @param {number} folderId The folder ID.
         * @param {CheckUploadRequest} [checkUploadRequest] The request parameters for checking file uploads.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUpload(folderId: number, checkUploadRequest?: CheckUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<STRINGArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUpload(folderId, checkUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.checkUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new folder with the title specified in the request. The parent folder ID can be also specified.
         * @summary Create a folder
         * @param {number} folderId The folder ID for the folder creation.
         * @param {CreateFolder} [createFolder] The parameters for creating a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(folderId, createFolder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a folder with the ID specified in the request.
         * @summary Delete a folder
         * @param {number} folderId The folder ID to delete.
         * @param {DeleteFolder} [deleteFolder] The parameters for deleting a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId: number, deleteFolder?: DeleteFolder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderId, deleteFolder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.deleteFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the used space of files in the root folders.
         * @summary Get used space of files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilesUsedSpace(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesStatisticsResultWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesUsedSpace(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFilesUsedSpace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the form filter of a folder with the ID specified in the request.
         * @summary Get folder form filter
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormsItemArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed list of files and folders located in the folder with the ID specified in the request.
         * @summary Get a folder by ID
         * @param {number} folderId The folder ID of the request.
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {number} [roomId] The room ID.
         * @param {boolean} [excludeSubject] Specifies whether to exclude search by user or group ID.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder.
         * @param {string} [extension] Specifies whether to search for the specific file extension.
         * @param {SearchArea} [searchArea] The search area.
         * @param {string} [formsItemKey] The forms item key.
         * @param {string} [formsItemType] The forms item type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderByFolderId(folderId: number, userIdOrGroupId?: string, filterType?: FilterType, roomId?: number, excludeSubject?: boolean, applyFilterOption?: ApplyFilterOption, extension?: string, searchArea?: SearchArea, formsItemKey?: string, formsItemType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderByFolderId(folderId, userIdOrGroupId, filterType, roomId, excludeSubject, applyFilterOption, extension, searchArea, formsItemKey, formsItemType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderByFolderId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the activity history of a folder with a specified identifier.
         * @summary Get folder history
         * @param {number} folderId The folder ID of the history request.
         * @param {ApiDateTime} [fromDate] The start date of the history request.
         * @param {ApiDateTime} [toDate] The end date of the history request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderHistory(folderId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderHistory(folderId, fromDate, toDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about a folder with the ID specified in the request.
         * @summary Get folder information
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderInfo(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderInfo(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a path to the folder with the ID specified in the request.
         * @summary Get the folder path
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderPath(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderPath(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderPath']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderPrimaryExternalLink(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderPrimaryExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the subfolders from a folder with the ID specified in the request.
         * @summary Get subfolders
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolders(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolders(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed list of files and folders located in the \"My documents\" section.
         * @summary Get the \"My documents\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyFolder(userIdOrGroupId, filterType, applyFilterOption, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getMyFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the new items from a folder with the ID specified in the request.
         * @summary Get new folder items
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewItems(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewItems(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getNewItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed list of files and folders located in the \"Private Room\" section.
         * @summary Get the \"Private Room\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrivacyFolder(userIdOrGroupId?: string, filterType?: FilterType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrivacyFolder(userIdOrGroupId, filterType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getPrivacyFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all the sections matching the parameters specified in the request.
         * @summary Get filtered sections
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {boolean} [withoutTrash] Specifies whether to return the \&quot;Trash\&quot; section or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootFolders(userIdOrGroupId?: string, filterType?: FilterType, withoutTrash?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRootFolders(userIdOrGroupId, filterType, withoutTrash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getRootFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed list of files and folders located in the \"Trash\" section.
         * @summary Get the \"Trash\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrashFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrashFolder(userIdOrGroupId, filterType, applyFilterOption, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getTrashFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts a file specified in the request to the selected folder by single file uploading.
         * @summary Insert a file
         * @param {number} folderId The folder ID for inserting a file.
         * @param {File} [insertFileFile] The file to be inserted.
         * @param {string} [insertFileTitle] The file title to be inserted.
         * @param {boolean} [insertFileCreateNewIfExist] Specifies whether to create a new file if it already exists or not.
         * @param {boolean} [insertFileKeepConvertStatus] Specifies whether to keep the file converting status or not.
         * @param {boolean} [insertFileStreamCanRead] 
         * @param {boolean} [insertFileStreamCanWrite] 
         * @param {boolean} [insertFileStreamCanSeek] 
         * @param {boolean} [insertFileStreamCanTimeout] 
         * @param {number} [insertFileStreamLength] 
         * @param {number} [insertFileStreamPosition] 
         * @param {number} [insertFileStreamReadTimeout] 
         * @param {number} [insertFileStreamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertFile(folderId: number, insertFileFile?: File, insertFileTitle?: string, insertFileCreateNewIfExist?: boolean, insertFileKeepConvertStatus?: boolean, insertFileStreamCanRead?: boolean, insertFileStreamCanWrite?: boolean, insertFileStreamCanSeek?: boolean, insertFileStreamCanTimeout?: boolean, insertFileStreamLength?: number, insertFileStreamPosition?: number, insertFileStreamReadTimeout?: number, insertFileStreamWriteTimeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertFile(folderId, insertFileFile, insertFileTitle, insertFileCreateNewIfExist, insertFileKeepConvertStatus, insertFileStreamCanRead, insertFileStreamCanWrite, insertFileStreamCanSeek, insertFileStreamCanTimeout, insertFileStreamLength, insertFileStreamPosition, insertFileStreamReadTimeout, insertFileStreamWriteTimeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.insertFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts a file specified in the request to the \"My documents\" section by single file uploading.
         * @summary Insert a file to the \"My documents\" section
         * @param {File} [file] The file to be inserted.
         * @param {string} [title] The file title to be inserted.
         * @param {boolean} [createNewIfExist] Specifies whether to create a new file if it already exists or not.
         * @param {boolean} [keepConvertStatus] Specifies whether to keep the file converting status or not.
         * @param {boolean} [streamCanRead] 
         * @param {boolean} [streamCanWrite] 
         * @param {boolean} [streamCanSeek] 
         * @param {boolean} [streamCanTimeout] 
         * @param {number} [streamLength] 
         * @param {number} [streamPosition] 
         * @param {number} [streamReadTimeout] 
         * @param {number} [streamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertFileToMyFromBody(file?: File, title?: string, createNewIfExist?: boolean, keepConvertStatus?: boolean, streamCanRead?: boolean, streamCanWrite?: boolean, streamCanSeek?: boolean, streamCanTimeout?: boolean, streamLength?: number, streamPosition?: number, streamReadTimeout?: number, streamWriteTimeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertFileToMyFromBody(file, title, createNewIfExist, keepConvertStatus, streamCanRead, streamCanWrite, streamCanSeek, streamCanTimeout, streamLength, streamPosition, streamReadTimeout, streamWriteTimeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.insertFileToMyFromBody']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Renames the selected folder with a new title specified in the request.
         * @summary Rename a folder
         * @param {number} folderId The folder ID for the folder creation.
         * @param {CreateFolder} [createFolder] The parameters for creating a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameFolder(folderId, createFolder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.renameFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the file order in the folder with ID specified in the request.
         * @summary Set file order
         * @param {number} folderId The folder unique identifier.
         * @param {OrderRequestDto} [orderRequestDto] The folder order information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFileOrder(folderId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFileOrder(folderId, orderRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.setFileOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file
         * @param {number} folderId The folder ID to upload a file.
         * @param {UploadRequestDto} [uploadRequestDto] The request parameters for uploading a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(folderId: number, uploadRequestDto?: UploadRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(folderId, uploadRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file to the \"My documents\" section
         * @param {UploadRequestDto} [inDto] The request parameters for uploading a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileToMy(inDto?: UploadRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileToMy(inDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.uploadFileToMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesFoldersApi - factory interface
 * @export
 */
export const FilesFoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesFoldersApiFp(configuration)
    return {
        /**
         * Checks the file uploads to the folder with the ID specified in the request.
         * @summary Check file uploads
         * @param {number} folderId The folder ID.
         * @param {CheckUploadRequest} [checkUploadRequest] The request parameters for checking file uploads.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUpload(folderId: number, checkUploadRequest?: CheckUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<STRINGArrayWrapper> {
            return localVarFp.checkUpload(folderId, checkUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new folder with the title specified in the request. The parent folder ID can be also specified.
         * @summary Create a folder
         * @param {number} folderId The folder ID for the folder creation.
         * @param {CreateFolder} [createFolder] The parameters for creating a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.createFolder(folderId, createFolder, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a folder with the ID specified in the request.
         * @summary Delete a folder
         * @param {number} folderId The folder ID to delete.
         * @param {DeleteFolder} [deleteFolder] The parameters for deleting a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(folderId: number, deleteFolder?: DeleteFolder, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.deleteFolder(folderId, deleteFolder, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the used space of files in the root folders.
         * @summary Get used space of files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesUsedSpace(options?: RawAxiosRequestConfig): AxiosPromise<FilesStatisticsResultWrapper> {
            return localVarFp.getFilesUsedSpace(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the form filter of a folder with the ID specified in the request.
         * @summary Get folder form filter
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FormsItemArrayWrapper> {
            return localVarFp.getFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed list of files and folders located in the folder with the ID specified in the request.
         * @summary Get a folder by ID
         * @param {number} folderId The folder ID of the request.
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {number} [roomId] The room ID.
         * @param {boolean} [excludeSubject] Specifies whether to exclude search by user or group ID.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder.
         * @param {string} [extension] Specifies whether to search for the specific file extension.
         * @param {SearchArea} [searchArea] The search area.
         * @param {string} [formsItemKey] The forms item key.
         * @param {string} [formsItemType] The forms item type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderByFolderId(folderId: number, userIdOrGroupId?: string, filterType?: FilterType, roomId?: number, excludeSubject?: boolean, applyFilterOption?: ApplyFilterOption, extension?: string, searchArea?: SearchArea, formsItemKey?: string, formsItemType?: string, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getFolderByFolderId(folderId, userIdOrGroupId, filterType, roomId, excludeSubject, applyFilterOption, extension, searchArea, formsItemKey, formsItemType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the activity history of a folder with a specified identifier.
         * @summary Get folder history
         * @param {number} folderId The folder ID of the history request.
         * @param {ApiDateTime} [fromDate] The start date of the history request.
         * @param {ApiDateTime} [toDate] The end date of the history request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory(folderId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig): AxiosPromise<HistoryArrayWrapper> {
            return localVarFp.getFolderHistory(folderId, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about a folder with the ID specified in the request.
         * @summary Get folder information
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderInfo(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.getFolderInfo(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a path to the folder with the ID specified in the request.
         * @summary Get the folder path
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPath(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryArrayWrapper> {
            return localVarFp.getFolderPath(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.getFolderPrimaryExternalLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the subfolders from a folder with the ID specified in the request.
         * @summary Get subfolders
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryArrayWrapper> {
            return localVarFp.getFolders(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed list of files and folders located in the \"My documents\" section.
         * @summary Get the \"My documents\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getMyFolder(userIdOrGroupId, filterType, applyFilterOption, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the new items from a folder with the ID specified in the request.
         * @summary Get new folder items
         * @param {number} folderId The request folder ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewItems(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryArrayWrapper> {
            return localVarFp.getNewItems(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed list of files and folders located in the \"Private Room\" section.
         * @summary Get the \"Private Room\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacyFolder(userIdOrGroupId?: string, filterType?: FilterType, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getPrivacyFolder(userIdOrGroupId, filterType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the sections matching the parameters specified in the request.
         * @summary Get filtered sections
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {boolean} [withoutTrash] Specifies whether to return the \&quot;Trash\&quot; section or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolders(userIdOrGroupId?: string, filterType?: FilterType, withoutTrash?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerArrayWrapper> {
            return localVarFp.getRootFolders(userIdOrGroupId, filterType, withoutTrash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed list of files and folders located in the \"Trash\" section.
         * @summary Get the \"Trash\" section
         * @param {string} [userIdOrGroupId] The user or group ID.
         * @param {FilterType} [filterType] The filter type.
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrashFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getTrashFolder(userIdOrGroupId, filterType, applyFilterOption, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts a file specified in the request to the selected folder by single file uploading.
         * @summary Insert a file
         * @param {number} folderId The folder ID for inserting a file.
         * @param {File} [insertFileFile] The file to be inserted.
         * @param {string} [insertFileTitle] The file title to be inserted.
         * @param {boolean} [insertFileCreateNewIfExist] Specifies whether to create a new file if it already exists or not.
         * @param {boolean} [insertFileKeepConvertStatus] Specifies whether to keep the file converting status or not.
         * @param {boolean} [insertFileStreamCanRead] 
         * @param {boolean} [insertFileStreamCanWrite] 
         * @param {boolean} [insertFileStreamCanSeek] 
         * @param {boolean} [insertFileStreamCanTimeout] 
         * @param {number} [insertFileStreamLength] 
         * @param {number} [insertFileStreamPosition] 
         * @param {number} [insertFileStreamReadTimeout] 
         * @param {number} [insertFileStreamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertFile(folderId: number, insertFileFile?: File, insertFileTitle?: string, insertFileCreateNewIfExist?: boolean, insertFileKeepConvertStatus?: boolean, insertFileStreamCanRead?: boolean, insertFileStreamCanWrite?: boolean, insertFileStreamCanSeek?: boolean, insertFileStreamCanTimeout?: boolean, insertFileStreamLength?: number, insertFileStreamPosition?: number, insertFileStreamReadTimeout?: number, insertFileStreamWriteTimeout?: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.insertFile(folderId, insertFileFile, insertFileTitle, insertFileCreateNewIfExist, insertFileKeepConvertStatus, insertFileStreamCanRead, insertFileStreamCanWrite, insertFileStreamCanSeek, insertFileStreamCanTimeout, insertFileStreamLength, insertFileStreamPosition, insertFileStreamReadTimeout, insertFileStreamWriteTimeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts a file specified in the request to the \"My documents\" section by single file uploading.
         * @summary Insert a file to the \"My documents\" section
         * @param {File} [file] The file to be inserted.
         * @param {string} [title] The file title to be inserted.
         * @param {boolean} [createNewIfExist] Specifies whether to create a new file if it already exists or not.
         * @param {boolean} [keepConvertStatus] Specifies whether to keep the file converting status or not.
         * @param {boolean} [streamCanRead] 
         * @param {boolean} [streamCanWrite] 
         * @param {boolean} [streamCanSeek] 
         * @param {boolean} [streamCanTimeout] 
         * @param {number} [streamLength] 
         * @param {number} [streamPosition] 
         * @param {number} [streamReadTimeout] 
         * @param {number} [streamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertFileToMyFromBody(file?: File, title?: string, createNewIfExist?: boolean, keepConvertStatus?: boolean, streamCanRead?: boolean, streamCanWrite?: boolean, streamCanSeek?: boolean, streamCanTimeout?: boolean, streamLength?: number, streamPosition?: number, streamReadTimeout?: number, streamWriteTimeout?: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.insertFileToMyFromBody(file, title, createNewIfExist, keepConvertStatus, streamCanRead, streamCanWrite, streamCanSeek, streamCanTimeout, streamLength, streamPosition, streamReadTimeout, streamWriteTimeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames the selected folder with a new title specified in the request.
         * @summary Rename a folder
         * @param {number} folderId The folder ID for the folder creation.
         * @param {CreateFolder} [createFolder] The parameters for creating a folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.renameFolder(folderId, createFolder, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the file order in the folder with ID specified in the request.
         * @summary Set file order
         * @param {number} folderId The folder unique identifier.
         * @param {OrderRequestDto} [orderRequestDto] The folder order information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFileOrder(folderId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.setFileOrder(folderId, orderRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file
         * @param {number} folderId The folder ID to upload a file.
         * @param {UploadRequestDto} [uploadRequestDto] The request parameters for uploading a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(folderId: number, uploadRequestDto?: UploadRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.uploadFile(folderId, uploadRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file to the \"My documents\" section
         * @param {UploadRequestDto} [inDto] The request parameters for uploading a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileToMy(inDto?: UploadRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.uploadFileToMy(inDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesFoldersApi - object-oriented interface
 * @export
 * @class FilesFoldersApi
 * @extends {BaseAPI}
 */
export class FilesFoldersApi extends BaseAPI {
    /**
     * Checks the file uploads to the folder with the ID specified in the request.
     * @summary Check file uploads
     * @param {number} folderId The folder ID.
     * @param {CheckUploadRequest} [checkUploadRequest] The request parameters for checking file uploads.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public checkUpload(folderId: number, checkUploadRequest?: CheckUploadRequest, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).checkUpload(folderId, checkUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new folder with the title specified in the request. The parent folder ID can be also specified.
     * @summary Create a folder
     * @param {number} folderId The folder ID for the folder creation.
     * @param {CreateFolder} [createFolder] The parameters for creating a folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public createFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).createFolder(folderId, createFolder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a folder with the ID specified in the request.
     * @summary Delete a folder
     * @param {number} folderId The folder ID to delete.
     * @param {DeleteFolder} [deleteFolder] The parameters for deleting a folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public deleteFolder(folderId: number, deleteFolder?: DeleteFolder, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).deleteFolder(folderId, deleteFolder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the used space of files in the root folders.
     * @summary Get used space of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFilesUsedSpace(options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFilesUsedSpace(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the form filter of a folder with the ID specified in the request.
     * @summary Get folder form filter
     * @param {number} folderId The request folder ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolder(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolder(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed list of files and folders located in the folder with the ID specified in the request.
     * @summary Get a folder by ID
     * @param {number} folderId The folder ID of the request.
     * @param {string} [userIdOrGroupId] The user or group ID.
     * @param {FilterType} [filterType] The filter type.
     * @param {number} [roomId] The room ID.
     * @param {boolean} [excludeSubject] Specifies whether to exclude search by user or group ID.
     * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder.
     * @param {string} [extension] Specifies whether to search for the specific file extension.
     * @param {SearchArea} [searchArea] The search area.
     * @param {string} [formsItemKey] The forms item key.
     * @param {string} [formsItemType] The forms item type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderByFolderId(folderId: number, userIdOrGroupId?: string, filterType?: FilterType, roomId?: number, excludeSubject?: boolean, applyFilterOption?: ApplyFilterOption, extension?: string, searchArea?: SearchArea, formsItemKey?: string, formsItemType?: string, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderByFolderId(folderId, userIdOrGroupId, filterType, roomId, excludeSubject, applyFilterOption, extension, searchArea, formsItemKey, formsItemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the activity history of a folder with a specified identifier.
     * @summary Get folder history
     * @param {number} folderId The folder ID of the history request.
     * @param {ApiDateTime} [fromDate] The start date of the history request.
     * @param {ApiDateTime} [toDate] The end date of the history request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderHistory(folderId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderHistory(folderId, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about a folder with the ID specified in the request.
     * @summary Get folder information
     * @param {number} folderId The request folder ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderInfo(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderInfo(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a path to the folder with the ID specified in the request.
     * @summary Get the folder path
     * @param {number} folderId The request folder ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderPath(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderPath(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary external link by the identifier specified in the request.
     * @summary Get primary external link
     * @param {number} id The request folder ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderPrimaryExternalLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the subfolders from a folder with the ID specified in the request.
     * @summary Get subfolders
     * @param {number} folderId The request folder ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolders(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolders(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed list of files and folders located in the \"My documents\" section.
     * @summary Get the \"My documents\" section
     * @param {string} [userIdOrGroupId] The user or group ID.
     * @param {FilterType} [filterType] The filter type.
     * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getMyFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getMyFolder(userIdOrGroupId, filterType, applyFilterOption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the new items from a folder with the ID specified in the request.
     * @summary Get new folder items
     * @param {number} folderId The request folder ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getNewItems(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getNewItems(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed list of files and folders located in the \"Private Room\" section.
     * @summary Get the \"Private Room\" section
     * @param {string} [userIdOrGroupId] The user or group ID.
     * @param {FilterType} [filterType] The filter type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getPrivacyFolder(userIdOrGroupId?: string, filterType?: FilterType, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getPrivacyFolder(userIdOrGroupId, filterType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the sections matching the parameters specified in the request.
     * @summary Get filtered sections
     * @param {string} [userIdOrGroupId] The user or group ID.
     * @param {FilterType} [filterType] The filter type.
     * @param {boolean} [withoutTrash] Specifies whether to return the \&quot;Trash\&quot; section or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getRootFolders(userIdOrGroupId?: string, filterType?: FilterType, withoutTrash?: boolean, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getRootFolders(userIdOrGroupId, filterType, withoutTrash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed list of files and folders located in the \"Trash\" section.
     * @summary Get the \"Trash\" section
     * @param {string} [userIdOrGroupId] The user or group ID.
     * @param {FilterType} [filterType] The filter type.
     * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getTrashFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getTrashFolder(userIdOrGroupId, filterType, applyFilterOption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts a file specified in the request to the selected folder by single file uploading.
     * @summary Insert a file
     * @param {number} folderId The folder ID for inserting a file.
     * @param {File} [insertFileFile] The file to be inserted.
     * @param {string} [insertFileTitle] The file title to be inserted.
     * @param {boolean} [insertFileCreateNewIfExist] Specifies whether to create a new file if it already exists or not.
     * @param {boolean} [insertFileKeepConvertStatus] Specifies whether to keep the file converting status or not.
     * @param {boolean} [insertFileStreamCanRead] 
     * @param {boolean} [insertFileStreamCanWrite] 
     * @param {boolean} [insertFileStreamCanSeek] 
     * @param {boolean} [insertFileStreamCanTimeout] 
     * @param {number} [insertFileStreamLength] 
     * @param {number} [insertFileStreamPosition] 
     * @param {number} [insertFileStreamReadTimeout] 
     * @param {number} [insertFileStreamWriteTimeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public insertFile(folderId: number, insertFileFile?: File, insertFileTitle?: string, insertFileCreateNewIfExist?: boolean, insertFileKeepConvertStatus?: boolean, insertFileStreamCanRead?: boolean, insertFileStreamCanWrite?: boolean, insertFileStreamCanSeek?: boolean, insertFileStreamCanTimeout?: boolean, insertFileStreamLength?: number, insertFileStreamPosition?: number, insertFileStreamReadTimeout?: number, insertFileStreamWriteTimeout?: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).insertFile(folderId, insertFileFile, insertFileTitle, insertFileCreateNewIfExist, insertFileKeepConvertStatus, insertFileStreamCanRead, insertFileStreamCanWrite, insertFileStreamCanSeek, insertFileStreamCanTimeout, insertFileStreamLength, insertFileStreamPosition, insertFileStreamReadTimeout, insertFileStreamWriteTimeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts a file specified in the request to the \"My documents\" section by single file uploading.
     * @summary Insert a file to the \"My documents\" section
     * @param {File} [file] The file to be inserted.
     * @param {string} [title] The file title to be inserted.
     * @param {boolean} [createNewIfExist] Specifies whether to create a new file if it already exists or not.
     * @param {boolean} [keepConvertStatus] Specifies whether to keep the file converting status or not.
     * @param {boolean} [streamCanRead] 
     * @param {boolean} [streamCanWrite] 
     * @param {boolean} [streamCanSeek] 
     * @param {boolean} [streamCanTimeout] 
     * @param {number} [streamLength] 
     * @param {number} [streamPosition] 
     * @param {number} [streamReadTimeout] 
     * @param {number} [streamWriteTimeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public insertFileToMyFromBody(file?: File, title?: string, createNewIfExist?: boolean, keepConvertStatus?: boolean, streamCanRead?: boolean, streamCanWrite?: boolean, streamCanSeek?: boolean, streamCanTimeout?: boolean, streamLength?: number, streamPosition?: number, streamReadTimeout?: number, streamWriteTimeout?: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).insertFileToMyFromBody(file, title, createNewIfExist, keepConvertStatus, streamCanRead, streamCanWrite, streamCanSeek, streamCanTimeout, streamLength, streamPosition, streamReadTimeout, streamWriteTimeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Renames the selected folder with a new title specified in the request.
     * @summary Rename a folder
     * @param {number} folderId The folder ID for the folder creation.
     * @param {CreateFolder} [createFolder] The parameters for creating a folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public renameFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).renameFolder(folderId, createFolder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the file order in the folder with ID specified in the request.
     * @summary Set file order
     * @param {number} folderId The folder unique identifier.
     * @param {OrderRequestDto} [orderRequestDto] The folder order information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public setFileOrder(folderId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).setFileOrder(folderId, orderRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
     * @summary Upload a file
     * @param {number} folderId The folder ID to upload a file.
     * @param {UploadRequestDto} [uploadRequestDto] The request parameters for uploading a file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public uploadFile(folderId: number, uploadRequestDto?: UploadRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).uploadFile(folderId, uploadRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
     * @summary Upload a file to the \"My documents\" section
     * @param {UploadRequestDto} [inDto] The request parameters for uploading a file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public uploadFileToMy(inDto?: UploadRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).uploadFileToMy(inDto, options).then((request) => request(this.axios, this.basePath));
    }
}

