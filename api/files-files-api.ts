/* tslint:disable */
/* eslint-disable */
/**
 * Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ApiDateTime } from '../models';
// @ts-ignore
import type { BaseBatchRequestDto } from '../models';
// @ts-ignore
import type { BooleanWrapper } from '../models';
// @ts-ignore
import type { ChangeHistory } from '../models';
// @ts-ignore
import type { CheckFillFormDraft } from '../models';
// @ts-ignore
import type { ConfigurationIntegerWrapper } from '../models';
// @ts-ignore
import type { CopyAsJsonElement } from '../models';
// @ts-ignore
import type { CreateFileJsonElement } from '../models';
// @ts-ignore
import type { CreateTextOrHtmlFile } from '../models';
// @ts-ignore
import type { CustomFilterParameters } from '../models';
// @ts-ignore
import type { Delete } from '../models';
// @ts-ignore
import type { EditHistoryArrayWrapper } from '../models';
// @ts-ignore
import type { EditHistoryDataWrapper } from '../models';
// @ts-ignore
import type { EditorType } from '../models';
// @ts-ignore
import type { FileEntryWrapper } from '../models';
// @ts-ignore
import type { FileIntegerArrayWrapper } from '../models';
// @ts-ignore
import type { FileIntegerWrapper } from '../models';
// @ts-ignore
import type { FileLinkRequest } from '../models';
// @ts-ignore
import type { FileLinkWrapper } from '../models';
// @ts-ignore
import type { FileOperationArrayWrapper } from '../models';
// @ts-ignore
import type { FileReferenceWrapper } from '../models';
// @ts-ignore
import type { FileShareArrayWrapper } from '../models';
// @ts-ignore
import type { FileShareWrapper } from '../models';
// @ts-ignore
import type { FillingFormResultIntegerWrapper } from '../models';
// @ts-ignore
import type { FormRoleArrayWrapper } from '../models';
// @ts-ignore
import type { FormRoleWrapper } from '../models';
// @ts-ignore
import type { GetReferenceDataDtoInteger } from '../models';
// @ts-ignore
import type { HistoryArrayWrapper } from '../models';
// @ts-ignore
import type { KeyValuePairBooleanStringWrapper } from '../models';
// @ts-ignore
import type { LockFileParameters } from '../models';
// @ts-ignore
import type { ManageFormFillingDtoInteger } from '../models';
// @ts-ignore
import type { MentionWrapperArrayWrapper } from '../models';
// @ts-ignore
import type { NoContentResultWrapper } from '../models';
// @ts-ignore
import type { ObjectArrayWrapper } from '../models';
// @ts-ignore
import type { ObjectWrapper } from '../models';
// @ts-ignore
import type { OrderRequestDto } from '../models';
// @ts-ignore
import type { OrdersRequestDtoInteger } from '../models';
// @ts-ignore
import type { SaveAsPdfInteger } from '../models';
// @ts-ignore
import type { SaveFormRoleMappingDtoInteger } from '../models';
// @ts-ignore
import type { StartEdit } from '../models';
// @ts-ignore
import type { StringWrapper } from '../models';
// @ts-ignore
import type { TemplatesRequestDto } from '../models';
// @ts-ignore
import type { UpdateFile } from '../models';
/**
 * FilesFilesApi - axios parameter creator
 * @export
 */
export const FilesFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds files with the IDs specified in the request to the template list.
         * @summary Add template files
         * @param {TemplatesRequestDto} [templatesRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplates: async (templatesRequestDto?: TemplatesRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the version history of a file with the ID specified in the request.
         * @summary Change version history
         * @param {number} fileId The file Id to change its version history.
         * @param {ChangeHistory} [changeHistory] The parameters for changing version history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeHistory: async (fileId: number, changeHistory?: ChangeHistory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('changeHistory', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/history`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeHistory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the current file is a form draft which can be filled out.
         * @summary Check the form draft filling
         * @param {number} fileId The file ID of the form draft.
         * @param {CheckFillFormDraft} [checkFillFormDraft] The parameters for checking the form draft filling.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFillFormDraft: async (fileId: number, checkFillFormDraft?: CheckFillFormDraft, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('checkFillFormDraft', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/masterform/{fileId}/checkfillformdraft`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkFillFormDraft, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copies (and converts if possible) an existing file to the specified folder.
         * @summary Copy a file
         * @param {number} fileId The file ID to copy.
         * @param {CopyAsJsonElement} [copyAsJsonElement] The parameters for copying a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFileAs: async (fileId: number, copyAsJsonElement?: CopyAsJsonElement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('copyFileAs', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/copyas`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(copyAsJsonElement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session to edit the existing file with multiple chunks (needed for WebDAV).   **Note**: Information about created session which includes:  <ul>  <li><b>id:</b> unique ID of this upload session,</li>  <li><b>created:</b> UTC time when the session was created,</li>  <li><b>expired:</b> UTC time when the session will expire if no chunks are sent before that time,</li>  <li><b>location:</b> URL where you should send your next chunk,</li>  <li><b>bytes_uploaded:</b> number of bytes uploaded for the specific upload ID,</li>  <li><b>bytes_total:</b> total number of bytes which will be uploaded.</li>  </ul>
         * @summary Create the editing session
         * @param {number} fileId The file ID.
         * @param {number} [fileSize] The file size in bytes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEditSession: async (fileId: number, fileSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('createEditSession', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/edit_session`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required

            if (fileSize !== undefined) {
                localVarQueryParameter['fileSize'] = fileSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new file in the specified folder with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file
         * @param {number} folderId The folder ID for the file creation.
         * @param {CreateFileJsonElement} [createFileJsonElement] The parameters for creating a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (folderId: number, createFileJsonElement?: CreateFileJsonElement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/file`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileJsonElement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new file in the \"My documents\" section with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file in the \"My documents\" section
         * @param {CreateFileJsonElement} [createFileJsonElement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileMyDocuments: async (createFileJsonElement?: CreateFileJsonElement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileJsonElement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an HTML (.html) file in the selected folder with the title and contents specified in the request.
         * @summary Create an HTML file
         * @param {number} folderId The folder ID to create the text or HTML file.
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] The parameters for creating an HTML or text file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHtmlFile: async (folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createHtmlFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/html`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextOrHtmlFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an HTML (.html) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create an HTML file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHtmlFileInMy: async (createTextOrHtmlFile?: CreateTextOrHtmlFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextOrHtmlFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a primary external link by the identifier specified in the request.
         * @summary Create primary external link
         * @param {number} id The file ID.
         * @param {FileLinkRequest} [fileLinkRequest] The file external link parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrimaryExternalLink: async (id: number, fileLinkRequest?: FileLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPrimaryExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a text (.txt) file in the selected folder with the title and contents specified in the request.
         * @summary Create a text file
         * @param {number} folderId The folder ID to create the text or HTML file.
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] The parameters for creating an HTML or text file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextFile: async (folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createTextFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/text`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextOrHtmlFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a text (.txt) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create a text file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextFileInMy: async (createTextOrHtmlFile?: CreateTextOrHtmlFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextOrHtmlFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates thumbnails for the files with the IDs specified in the request.
         * @summary Create file thumbnails
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThumbnails: async (baseBatchRequestDto?: BaseBatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thumbnails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseBatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a file with the ID specified in the request.
         * @summary Delete a file
         * @param {number} fileId The file ID to delete.
         * @param {Delete} _delete The parameters for deleting a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (fileId: number, _delete: Delete, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFile', 'fileId', fileId)
            // verify required parameter '_delete' is not null or undefined
            assertParamExists('deleteFile', '_delete', _delete)
            const localVarPath = `/api/2.0/files/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_delete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes files with the IDs specified in the request from the \"Recent\" section.
         * @summary Delete recent files
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecent: async (baseBatchRequestDto?: BaseBatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseBatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes files with the IDs specified in the request from the template list.
         * @summary Delete template files
         * @param {Array<number>} [requestBody] The file IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplates: async (requestBody?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all roles for the specified form.
         * @summary Get form roles
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFormRoles: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getAllFormRoles', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/formroles`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a URL to the changes of a file version specified in the request.
         * @summary Get changes URL
         * @param {number} fileId The file ID.
         * @param {number} [version] The file version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditDiffUrl: async (fileId: number, version?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getEditDiffUrl', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/edit/diff`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the version history of a file with the ID specified in the request.
         * @summary Get version history
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditHistory: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getEditHistory', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/edit/history`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of actions performed on the file with the specified identifier.
         * @summary Get file history
         * @param {number} fileId The file ID of the history request.
         * @param {ApiDateTime} [fromDate] The start date of the history.
         * @param {ApiDateTime} [toDate] The end date of the history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileHistory: async (fileId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileHistory', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/log`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required

            if (fromDate !== undefined) {
                for (const [key, value] of Object.entries(fromDate)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (toDate !== undefined) {
                for (const [key, value] of Object.entries(toDate)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about a file with the ID specified in the request.
         * @summary Get file information
         * @param {number} fileId The file ID.
         * @param {number} [version] The file version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileInfo: async (fileId: number, version?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileInfo', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilePrimaryExternalLink: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFilePrimaryExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about all the available file versions with the ID specified in the request.
         * @summary Get file versions
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileVersionInfo: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileVersionInfo', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/history`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the result of a form-filling session.
         * @summary Get form-filling result
         * @param {string} [fillingSessionId] The form-filling session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFillResult: async (fillingSessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/file/fillresult`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fillingSessionId !== undefined) {
                localVarQueryParameter['fillingSessionId'] = fillingSessionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the external links of a file with the ID specified in the request.
         * @summary Get file external links
         * @param {number} id The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinks: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLinks', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a link to download a file with the ID specified in the request asynchronously.
         * @summary Get file download link asynchronously
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedFileUri: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getPresignedFileUri', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/presigned`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a pre-signed URL to download a file with the specified ID.  This temporary link provides secure access to the file.
         * @summary Get file download link
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUri: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getPresignedUri', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/presigneduri`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the reference data to uniquely identify a file in its system and check the availability of insering data into the destination spreadsheet by the external link.
         * @summary Get reference data
         * @param {GetReferenceDataDtoInteger} [getReferenceDataDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceData: async (getReferenceDataDtoInteger?: GetReferenceDataDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/file/referencedata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getReferenceDataDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the PDF file is a form or not.
         * @summary Check the PDF file
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isFormPDF: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('isFormPDF', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/isformpdf`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Locks a file with the ID specified in the request.
         * @summary Lock a file
         * @param {number} fileId The file ID for locking.
         * @param {LockFileParameters} [lockFileParameters] The parameters for locking a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockFile: async (fileId: number, lockFileParameters?: LockFileParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('lockFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/lock`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lockFileParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs the specified form filling action.
         * @summary Perform form filling action
         * @param {string} fileId 
         * @param {ManageFormFillingDtoInteger} [manageFormFillingDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageFormFilling: async (fileId: string, manageFormFillingDtoInteger?: ManageFormFillingDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('manageFormFilling', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/manageformfilling`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageFormFillingDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the initialization configuration of a file to open it in the editor.
         * @summary Open a file configuration
         * @param {number} fileId The file ID to open.
         * @param {number} [version] The file version to open.
         * @param {boolean} [view] Specifies if the document will be opened for viewing only or not.
         * @param {EditorType} [editorType] The editor type to open the file.
         * @param {boolean} [edit] Specifies if the document is opened in the editing mode or not.
         * @param {boolean} [fill] Specifies if the document is opened in the form-filling mode or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openEdit: async (fileId: number, version?: number, view?: boolean, editorType?: EditorType, edit?: boolean, fill?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('openEdit', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/openedit`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (editorType !== undefined) {
                localVarQueryParameter['editorType'] = editorType;
            }

            if (edit !== undefined) {
                localVarQueryParameter['edit'] = edit;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users with their access rights to the protected file with the ID specified in the request.
         * @summary Get users access rights to the protected file
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protectUsers: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('protectUsers', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/protectusers`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores a file version specified in the request.
         * @summary Restore a file version
         * @param {number} fileId The file ID of the restore version.
         * @param {number} [version] The file version of the restore.
         * @param {string} [url] The file version URL of the restore.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreVersion: async (fileId: number, version?: number, url?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('restoreVersion', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/restoreversion`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves a file with the identifier specified in the request as a PDF document.
         * @summary Save a file as PDF
         * @param {number} id The file ID to save as PDF.
         * @param {SaveAsPdfInteger} [saveAsPdfInteger] The parameters for saving file as PDF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAsPdf: async (id: number, saveAsPdfInteger?: SaveAsPdfInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('saveAsPdf', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/saveaspdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveAsPdfInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves edits to a file with the ID specified in the request.
         * @summary Save file edits
         * @param {number} fileId The editing file ID from the request.
         * @param {string} [fileExtension] The editing file extension from the request.
         * @param {string} [downloadUri] The URI to download the editing file.
         * @param {File} [file] The request file stream.
         * @param {boolean} [forcesave] Specifies whether to force save the file or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEditingFromForm: async (fileId: number, fileExtension?: string, downloadUri?: string, file?: File, forcesave?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('saveEditingFromForm', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/saveediting`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


            if (fileExtension !== undefined) { 
                localVarFormParams.append('FileExtension', fileExtension as any);
            }
    
            if (downloadUri !== undefined) { 
                localVarFormParams.append('DownloadUri', downloadUri as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
            if (forcesave !== undefined) { 
                localVarFormParams.append('Forcesave', String(forcesave) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the form role mapping.
         * @summary Save form role mapping
         * @param {string} fileId 
         * @param {SaveFormRoleMappingDtoInteger} [saveFormRoleMappingDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFormRoleMapping: async (fileId: string, saveFormRoleMappingDtoInteger?: SaveFormRoleMappingDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('saveFormRoleMapping', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/formrolemapping`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveFormRoleMappingDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the Custom Filter editing mode to a file with the ID specified in the request.
         * @summary Set the Custom Filter editing mode
         * @param {number} fileId The file ID.
         * @param {CustomFilterParameters} [customFilterParameters] The parameters for setting the Custom Filter editing mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomFilterTag: async (fileId: number, customFilterParameters?: CustomFilterParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('setCustomFilterTag', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/customfilter`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilterParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets an external link to a file with the ID specified in the request.
         * @summary Set an external link
         * @param {number} id The file ID.
         * @param {FileLinkRequest} [fileLinkRequest] The file external link parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalLink: async (id: number, fileLinkRequest?: FileLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets order of the files.
         * @summary Set order of files
         * @param {OrdersRequestDtoInteger} [ordersRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFilesOrder: async (ordersRequestDtoInteger?: OrdersRequestDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ordersRequestDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets order of the file with ID specified in the request.
         * @summary Set file order
         * @param {number} fileId The file unique identifier.
         * @param {OrderRequestDto} [orderRequestDto] The file order information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrderFile: async (fileId: number, orderRequestDto?: OrderRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('setOrderFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/{fileId}/order`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Informs about opening a file with the ID specified in the request for editing, locking it from being deleted or moved (this method is called by the mobile editors).
         * @summary Start file editing
         * @param {number} fileId The file ID to start editing.
         * @param {StartEdit} [startEdit] The file parameters to start editing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEdit: async (fileId: number, startEdit?: StartEdit, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('startEdit', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/startedit`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startEdit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts filling a file with the ID specified in the request.
         * @summary Start file filling
         * @param {number} fileId The file ID to start filling.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFilling: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('startFilling', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/startfilling`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiKeyBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication asc_auth_key required

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication OpenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tracks file changes when editing.
         * @summary Track file editing
         * @param {number} fileId The file ID to track editing changes.
         * @param {string} [tabId] The tab ID to track editing changes.
         * @param {string} [docKeyForTrack] The document key for tracking changes.
         * @param {boolean} [isFinish] Specifies whether to finish file tracking or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEditFile: async (fileId: number, tabId?: string, docKeyForTrack?: string, isFinish?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('trackEditFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/trackeditfile`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tabId !== undefined) {
                localVarQueryParameter['tabId'] = tabId;
            }

            if (docKeyForTrack !== undefined) {
                localVarQueryParameter['docKeyForTrack'] = docKeyForTrack;
            }

            if (isFinish !== undefined) {
                localVarQueryParameter['isFinish'] = isFinish;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the information of the selected file with the parameters specified in the request.
         * @summary Update a file
         * @param {number} fileId The file ID to update.
         * @param {UpdateFile} [updateFile] The parameters for updating a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (fileId: number, updateFile?: UpdateFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('updateFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesFilesApi - functional programming interface
 * @export
 */
export const FilesFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds files with the IDs specified in the request to the template list.
         * @summary Add template files
         * @param {TemplatesRequestDto} [templatesRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTemplates(templatesRequestDto?: TemplatesRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTemplates(templatesRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.addTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the version history of a file with the ID specified in the request.
         * @summary Change version history
         * @param {number} fileId The file Id to change its version history.
         * @param {ChangeHistory} [changeHistory] The parameters for changing version history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeHistory(fileId: number, changeHistory?: ChangeHistory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeHistory(fileId, changeHistory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.changeHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the current file is a form draft which can be filled out.
         * @summary Check the form draft filling
         * @param {number} fileId The file ID of the form draft.
         * @param {CheckFillFormDraft} [checkFillFormDraft] The parameters for checking the form draft filling.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkFillFormDraft(fileId: number, checkFillFormDraft?: CheckFillFormDraft, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkFillFormDraft(fileId, checkFillFormDraft, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.checkFillFormDraft']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Copies (and converts if possible) an existing file to the specified folder.
         * @summary Copy a file
         * @param {number} fileId The file ID to copy.
         * @param {CopyAsJsonElement} [copyAsJsonElement] The parameters for copying a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyFileAs(fileId: number, copyAsJsonElement?: CopyAsJsonElement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyFileAs(fileId, copyAsJsonElement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.copyFileAs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a session to edit the existing file with multiple chunks (needed for WebDAV).   **Note**: Information about created session which includes:  <ul>  <li><b>id:</b> unique ID of this upload session,</li>  <li><b>created:</b> UTC time when the session was created,</li>  <li><b>expired:</b> UTC time when the session will expire if no chunks are sent before that time,</li>  <li><b>location:</b> URL where you should send your next chunk,</li>  <li><b>bytes_uploaded:</b> number of bytes uploaded for the specific upload ID,</li>  <li><b>bytes_total:</b> total number of bytes which will be uploaded.</li>  </ul>
         * @summary Create the editing session
         * @param {number} fileId The file ID.
         * @param {number} [fileSize] The file size in bytes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEditSession(fileId: number, fileSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEditSession(fileId, fileSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createEditSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new file in the specified folder with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file
         * @param {number} folderId The folder ID for the file creation.
         * @param {CreateFileJsonElement} [createFileJsonElement] The parameters for creating a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(folderId: number, createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(folderId, createFileJsonElement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new file in the \"My documents\" section with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file in the \"My documents\" section
         * @param {CreateFileJsonElement} [createFileJsonElement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFileMyDocuments(createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFileMyDocuments(createFileJsonElement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createFileMyDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an HTML (.html) file in the selected folder with the title and contents specified in the request.
         * @summary Create an HTML file
         * @param {number} folderId The folder ID to create the text or HTML file.
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] The parameters for creating an HTML or text file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHtmlFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHtmlFile(folderId, createTextOrHtmlFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createHtmlFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an HTML (.html) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create an HTML file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHtmlFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHtmlFileInMy(createTextOrHtmlFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createHtmlFileInMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a primary external link by the identifier specified in the request.
         * @summary Create primary external link
         * @param {number} id The file ID.
         * @param {FileLinkRequest} [fileLinkRequest] The file external link parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrimaryExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrimaryExternalLink(id, fileLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createPrimaryExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a text (.txt) file in the selected folder with the title and contents specified in the request.
         * @summary Create a text file
         * @param {number} folderId The folder ID to create the text or HTML file.
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] The parameters for creating an HTML or text file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTextFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTextFile(folderId, createTextOrHtmlFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createTextFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a text (.txt) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create a text file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTextFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTextFileInMy(createTextOrHtmlFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createTextFileInMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates thumbnails for the files with the IDs specified in the request.
         * @summary Create file thumbnails
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThumbnails(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThumbnails(baseBatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createThumbnails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a file with the ID specified in the request.
         * @summary Delete a file
         * @param {number} fileId The file ID to delete.
         * @param {Delete} _delete The parameters for deleting a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(fileId: number, _delete: Delete, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(fileId, _delete, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.deleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes files with the IDs specified in the request from the \"Recent\" section.
         * @summary Delete recent files
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecent(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoContentResultWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecent(baseBatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.deleteRecent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes files with the IDs specified in the request from the template list.
         * @summary Delete template files
         * @param {Array<number>} [requestBody] The file IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplates(requestBody?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplates(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.deleteTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all roles for the specified form.
         * @summary Get form roles
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFormRoles(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormRoleArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFormRoles(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getAllFormRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a URL to the changes of a file version specified in the request.
         * @summary Get changes URL
         * @param {number} fileId The file ID.
         * @param {number} [version] The file version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEditDiffUrl(fileId: number, version?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditHistoryDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEditDiffUrl(fileId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getEditDiffUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the version history of a file with the ID specified in the request.
         * @summary Get version history
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEditHistory(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditHistoryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEditHistory(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getEditHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of actions performed on the file with the specified identifier.
         * @summary Get file history
         * @param {number} fileId The file ID of the history request.
         * @param {ApiDateTime} [fromDate] The start date of the history.
         * @param {ApiDateTime} [toDate] The end date of the history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileHistory(fileId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileHistory(fileId, fromDate, toDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFileHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about a file with the ID specified in the request.
         * @summary Get file information
         * @param {number} fileId The file ID.
         * @param {number} [version] The file version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileInfo(fileId: number, version?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileInfo(fileId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFileInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilePrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilePrimaryExternalLink(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFilePrimaryExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about all the available file versions with the ID specified in the request.
         * @summary Get file versions
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileVersionInfo(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileVersionInfo(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFileVersionInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the result of a form-filling session.
         * @summary Get form-filling result
         * @param {string} [fillingSessionId] The form-filling session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFillResult(fillingSessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FillingFormResultIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFillResult(fillingSessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFillResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the external links of a file with the ID specified in the request.
         * @summary Get file external links
         * @param {number} id The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinks(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinks(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a link to download a file with the ID specified in the request asynchronously.
         * @summary Get file download link asynchronously
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedFileUri(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileLinkWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedFileUri(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getPresignedFileUri']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a pre-signed URL to download a file with the specified ID.  This temporary link provides secure access to the file.
         * @summary Get file download link
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUri(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUri(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getPresignedUri']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the reference data to uniquely identify a file in its system and check the availability of insering data into the destination spreadsheet by the external link.
         * @summary Get reference data
         * @param {GetReferenceDataDtoInteger} [getReferenceDataDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferenceData(getReferenceDataDtoInteger?: GetReferenceDataDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileReferenceWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferenceData(getReferenceDataDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getReferenceData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the PDF file is a form or not.
         * @summary Check the PDF file
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isFormPDF(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isFormPDF(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.isFormPDF']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Locks a file with the ID specified in the request.
         * @summary Lock a file
         * @param {number} fileId The file ID for locking.
         * @param {LockFileParameters} [lockFileParameters] The parameters for locking a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockFile(fileId: number, lockFileParameters?: LockFileParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockFile(fileId, lockFileParameters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.lockFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Performs the specified form filling action.
         * @summary Perform form filling action
         * @param {string} fileId 
         * @param {ManageFormFillingDtoInteger} [manageFormFillingDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageFormFilling(fileId: string, manageFormFillingDtoInteger?: ManageFormFillingDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageFormFilling(fileId, manageFormFillingDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.manageFormFilling']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the initialization configuration of a file to open it in the editor.
         * @summary Open a file configuration
         * @param {number} fileId The file ID to open.
         * @param {number} [version] The file version to open.
         * @param {boolean} [view] Specifies if the document will be opened for viewing only or not.
         * @param {EditorType} [editorType] The editor type to open the file.
         * @param {boolean} [edit] Specifies if the document is opened in the editing mode or not.
         * @param {boolean} [fill] Specifies if the document is opened in the form-filling mode or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openEdit(fileId: number, version?: number, view?: boolean, editorType?: EditorType, edit?: boolean, fill?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openEdit(fileId, version, view, editorType, edit, fill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.openEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of users with their access rights to the protected file with the ID specified in the request.
         * @summary Get users access rights to the protected file
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async protectUsers(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MentionWrapperArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.protectUsers(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.protectUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restores a file version specified in the request.
         * @summary Restore a file version
         * @param {number} fileId The file ID of the restore version.
         * @param {number} [version] The file version of the restore.
         * @param {string} [url] The file version URL of the restore.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreVersion(fileId: number, version?: number, url?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditHistoryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreVersion(fileId, version, url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.restoreVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves a file with the identifier specified in the request as a PDF document.
         * @summary Save a file as PDF
         * @param {number} id The file ID to save as PDF.
         * @param {SaveAsPdfInteger} [saveAsPdfInteger] The parameters for saving file as PDF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAsPdf(id: number, saveAsPdfInteger?: SaveAsPdfInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAsPdf(id, saveAsPdfInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.saveAsPdf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves edits to a file with the ID specified in the request.
         * @summary Save file edits
         * @param {number} fileId The editing file ID from the request.
         * @param {string} [fileExtension] The editing file extension from the request.
         * @param {string} [downloadUri] The URI to download the editing file.
         * @param {File} [file] The request file stream.
         * @param {boolean} [forcesave] Specifies whether to force save the file or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveEditingFromForm(fileId: number, fileExtension?: string, downloadUri?: string, file?: File, forcesave?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveEditingFromForm(fileId, fileExtension, downloadUri, file, forcesave, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.saveEditingFromForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the form role mapping.
         * @summary Save form role mapping
         * @param {string} fileId 
         * @param {SaveFormRoleMappingDtoInteger} [saveFormRoleMappingDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveFormRoleMapping(fileId: string, saveFormRoleMappingDtoInteger?: SaveFormRoleMappingDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormRoleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveFormRoleMapping(fileId, saveFormRoleMappingDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.saveFormRoleMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the Custom Filter editing mode to a file with the ID specified in the request.
         * @summary Set the Custom Filter editing mode
         * @param {number} fileId The file ID.
         * @param {CustomFilterParameters} [customFilterParameters] The parameters for setting the Custom Filter editing mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCustomFilterTag(fileId: number, customFilterParameters?: CustomFilterParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomFilterTag(fileId, customFilterParameters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.setCustomFilterTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets an external link to a file with the ID specified in the request.
         * @summary Set an external link
         * @param {number} id The file ID.
         * @param {FileLinkRequest} [fileLinkRequest] The file external link parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalLink(id, fileLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.setExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets order of the files.
         * @summary Set order of files
         * @param {OrdersRequestDtoInteger} [ordersRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFilesOrder(ordersRequestDtoInteger?: OrdersRequestDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFilesOrder(ordersRequestDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.setFilesOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets order of the file with ID specified in the request.
         * @summary Set file order
         * @param {number} fileId The file unique identifier.
         * @param {OrderRequestDto} [orderRequestDto] The file order information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrderFile(fileId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrderFile(fileId, orderRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.setOrderFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Informs about opening a file with the ID specified in the request for editing, locking it from being deleted or moved (this method is called by the mobile editors).
         * @summary Start file editing
         * @param {number} fileId The file ID to start editing.
         * @param {StartEdit} [startEdit] The file parameters to start editing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startEdit(fileId: number, startEdit?: StartEdit, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startEdit(fileId, startEdit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.startEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts filling a file with the ID specified in the request.
         * @summary Start file filling
         * @param {number} fileId The file ID to start filling.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startFilling(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startFilling(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.startFilling']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Tracks file changes when editing.
         * @summary Track file editing
         * @param {number} fileId The file ID to track editing changes.
         * @param {string} [tabId] The tab ID to track editing changes.
         * @param {string} [docKeyForTrack] The document key for tracking changes.
         * @param {boolean} [isFinish] Specifies whether to finish file tracking or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackEditFile(fileId: number, tabId?: string, docKeyForTrack?: string, isFinish?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyValuePairBooleanStringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackEditFile(fileId, tabId, docKeyForTrack, isFinish, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.trackEditFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the information of the selected file with the parameters specified in the request.
         * @summary Update a file
         * @param {number} fileId The file ID to update.
         * @param {UpdateFile} [updateFile] The parameters for updating a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(fileId: number, updateFile?: UpdateFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(fileId, updateFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.updateFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesFilesApi - factory interface
 * @export
 */
export const FilesFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesFilesApiFp(configuration)
    return {
        /**
         * Adds files with the IDs specified in the request to the template list.
         * @summary Add template files
         * @param {TemplatesRequestDto} [templatesRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplates(templatesRequestDto?: TemplatesRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.addTemplates(templatesRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the version history of a file with the ID specified in the request.
         * @summary Change version history
         * @param {number} fileId The file Id to change its version history.
         * @param {ChangeHistory} [changeHistory] The parameters for changing version history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeHistory(fileId: number, changeHistory?: ChangeHistory, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerArrayWrapper> {
            return localVarFp.changeHistory(fileId, changeHistory, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the current file is a form draft which can be filled out.
         * @summary Check the form draft filling
         * @param {number} fileId The file ID of the form draft.
         * @param {CheckFillFormDraft} [checkFillFormDraft] The parameters for checking the form draft filling.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFillFormDraft(fileId: number, checkFillFormDraft?: CheckFillFormDraft, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.checkFillFormDraft(fileId, checkFillFormDraft, options).then((request) => request(axios, basePath));
        },
        /**
         * Copies (and converts if possible) an existing file to the specified folder.
         * @summary Copy a file
         * @param {number} fileId The file ID to copy.
         * @param {CopyAsJsonElement} [copyAsJsonElement] The parameters for copying a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFileAs(fileId: number, copyAsJsonElement?: CopyAsJsonElement, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryWrapper> {
            return localVarFp.copyFileAs(fileId, copyAsJsonElement, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a session to edit the existing file with multiple chunks (needed for WebDAV).   **Note**: Information about created session which includes:  <ul>  <li><b>id:</b> unique ID of this upload session,</li>  <li><b>created:</b> UTC time when the session was created,</li>  <li><b>expired:</b> UTC time when the session will expire if no chunks are sent before that time,</li>  <li><b>location:</b> URL where you should send your next chunk,</li>  <li><b>bytes_uploaded:</b> number of bytes uploaded for the specific upload ID,</li>  <li><b>bytes_total:</b> total number of bytes which will be uploaded.</li>  </ul>
         * @summary Create the editing session
         * @param {number} fileId The file ID.
         * @param {number} [fileSize] The file size in bytes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEditSession(fileId: number, fileSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.createEditSession(fileId, fileSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new file in the specified folder with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file
         * @param {number} folderId The folder ID for the file creation.
         * @param {CreateFileJsonElement} [createFileJsonElement] The parameters for creating a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(folderId: number, createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createFile(folderId, createFileJsonElement, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new file in the \"My documents\" section with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file in the \"My documents\" section
         * @param {CreateFileJsonElement} [createFileJsonElement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileMyDocuments(createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createFileMyDocuments(createFileJsonElement, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an HTML (.html) file in the selected folder with the title and contents specified in the request.
         * @summary Create an HTML file
         * @param {number} folderId The folder ID to create the text or HTML file.
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] The parameters for creating an HTML or text file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHtmlFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createHtmlFile(folderId, createTextOrHtmlFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an HTML (.html) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create an HTML file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHtmlFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createHtmlFileInMy(createTextOrHtmlFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a primary external link by the identifier specified in the request.
         * @summary Create primary external link
         * @param {number} id The file ID.
         * @param {FileLinkRequest} [fileLinkRequest] The file external link parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrimaryExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.createPrimaryExternalLink(id, fileLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a text (.txt) file in the selected folder with the title and contents specified in the request.
         * @summary Create a text file
         * @param {number} folderId The folder ID to create the text or HTML file.
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] The parameters for creating an HTML or text file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createTextFile(folderId, createTextOrHtmlFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a text (.txt) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create a text file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createTextFileInMy(createTextOrHtmlFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates thumbnails for the files with the IDs specified in the request.
         * @summary Create file thumbnails
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThumbnails(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ObjectArrayWrapper> {
            return localVarFp.createThumbnails(baseBatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a file with the ID specified in the request.
         * @summary Delete a file
         * @param {number} fileId The file ID to delete.
         * @param {Delete} _delete The parameters for deleting a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId: number, _delete: Delete, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.deleteFile(fileId, _delete, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes files with the IDs specified in the request from the \"Recent\" section.
         * @summary Delete recent files
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecent(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<NoContentResultWrapper> {
            return localVarFp.deleteRecent(baseBatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes files with the IDs specified in the request from the template list.
         * @summary Delete template files
         * @param {Array<number>} [requestBody] The file IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplates(requestBody?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.deleteTemplates(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all roles for the specified form.
         * @summary Get form roles
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFormRoles(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<FormRoleArrayWrapper> {
            return localVarFp.getAllFormRoles(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a URL to the changes of a file version specified in the request.
         * @summary Get changes URL
         * @param {number} fileId The file ID.
         * @param {number} [version] The file version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditDiffUrl(fileId: number, version?: number, options?: RawAxiosRequestConfig): AxiosPromise<EditHistoryDataWrapper> {
            return localVarFp.getEditDiffUrl(fileId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the version history of a file with the ID specified in the request.
         * @summary Get version history
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditHistory(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<EditHistoryArrayWrapper> {
            return localVarFp.getEditHistory(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of actions performed on the file with the specified identifier.
         * @summary Get file history
         * @param {number} fileId The file ID of the history request.
         * @param {ApiDateTime} [fromDate] The start date of the history.
         * @param {ApiDateTime} [toDate] The end date of the history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileHistory(fileId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig): AxiosPromise<HistoryArrayWrapper> {
            return localVarFp.getFileHistory(fileId, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about a file with the ID specified in the request.
         * @summary Get file information
         * @param {number} fileId The file ID.
         * @param {number} [version] The file version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileInfo(fileId: number, version?: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.getFileInfo(fileId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilePrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.getFilePrimaryExternalLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about all the available file versions with the ID specified in the request.
         * @summary Get file versions
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileVersionInfo(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerArrayWrapper> {
            return localVarFp.getFileVersionInfo(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the result of a form-filling session.
         * @summary Get form-filling result
         * @param {string} [fillingSessionId] The form-filling session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFillResult(fillingSessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FillingFormResultIntegerWrapper> {
            return localVarFp.getFillResult(fillingSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the external links of a file with the ID specified in the request.
         * @summary Get file external links
         * @param {number} id The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinks(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FileShareArrayWrapper> {
            return localVarFp.getLinks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a link to download a file with the ID specified in the request asynchronously.
         * @summary Get file download link asynchronously
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedFileUri(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileLinkWrapper> {
            return localVarFp.getPresignedFileUri(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a pre-signed URL to download a file with the specified ID.  This temporary link provides secure access to the file.
         * @summary Get file download link
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUri(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.getPresignedUri(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the reference data to uniquely identify a file in its system and check the availability of insering data into the destination spreadsheet by the external link.
         * @summary Get reference data
         * @param {GetReferenceDataDtoInteger} [getReferenceDataDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceData(getReferenceDataDtoInteger?: GetReferenceDataDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<FileReferenceWrapper> {
            return localVarFp.getReferenceData(getReferenceDataDtoInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the PDF file is a form or not.
         * @summary Check the PDF file
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isFormPDF(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.isFormPDF(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Locks a file with the ID specified in the request.
         * @summary Lock a file
         * @param {number} fileId The file ID for locking.
         * @param {LockFileParameters} [lockFileParameters] The parameters for locking a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockFile(fileId: number, lockFileParameters?: LockFileParameters, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.lockFile(fileId, lockFileParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs the specified form filling action.
         * @summary Perform form filling action
         * @param {string} fileId 
         * @param {ManageFormFillingDtoInteger} [manageFormFillingDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageFormFilling(fileId: string, manageFormFillingDtoInteger?: ManageFormFillingDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.manageFormFilling(fileId, manageFormFillingDtoInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the initialization configuration of a file to open it in the editor.
         * @summary Open a file configuration
         * @param {number} fileId The file ID to open.
         * @param {number} [version] The file version to open.
         * @param {boolean} [view] Specifies if the document will be opened for viewing only or not.
         * @param {EditorType} [editorType] The editor type to open the file.
         * @param {boolean} [edit] Specifies if the document is opened in the editing mode or not.
         * @param {boolean} [fill] Specifies if the document is opened in the form-filling mode or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openEdit(fileId: number, version?: number, view?: boolean, editorType?: EditorType, edit?: boolean, fill?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ConfigurationIntegerWrapper> {
            return localVarFp.openEdit(fileId, version, view, editorType, edit, fill, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users with their access rights to the protected file with the ID specified in the request.
         * @summary Get users access rights to the protected file
         * @param {number} fileId The file ID of the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protectUsers(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<MentionWrapperArrayWrapper> {
            return localVarFp.protectUsers(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores a file version specified in the request.
         * @summary Restore a file version
         * @param {number} fileId The file ID of the restore version.
         * @param {number} [version] The file version of the restore.
         * @param {string} [url] The file version URL of the restore.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreVersion(fileId: number, version?: number, url?: string, options?: RawAxiosRequestConfig): AxiosPromise<EditHistoryArrayWrapper> {
            return localVarFp.restoreVersion(fileId, version, url, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves a file with the identifier specified in the request as a PDF document.
         * @summary Save a file as PDF
         * @param {number} id The file ID to save as PDF.
         * @param {SaveAsPdfInteger} [saveAsPdfInteger] The parameters for saving file as PDF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAsPdf(id: number, saveAsPdfInteger?: SaveAsPdfInteger, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.saveAsPdf(id, saveAsPdfInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves edits to a file with the ID specified in the request.
         * @summary Save file edits
         * @param {number} fileId The editing file ID from the request.
         * @param {string} [fileExtension] The editing file extension from the request.
         * @param {string} [downloadUri] The URI to download the editing file.
         * @param {File} [file] The request file stream.
         * @param {boolean} [forcesave] Specifies whether to force save the file or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEditingFromForm(fileId: number, fileExtension?: string, downloadUri?: string, file?: File, forcesave?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.saveEditingFromForm(fileId, fileExtension, downloadUri, file, forcesave, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the form role mapping.
         * @summary Save form role mapping
         * @param {string} fileId 
         * @param {SaveFormRoleMappingDtoInteger} [saveFormRoleMappingDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFormRoleMapping(fileId: string, saveFormRoleMappingDtoInteger?: SaveFormRoleMappingDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<FormRoleWrapper> {
            return localVarFp.saveFormRoleMapping(fileId, saveFormRoleMappingDtoInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the Custom Filter editing mode to a file with the ID specified in the request.
         * @summary Set the Custom Filter editing mode
         * @param {number} fileId The file ID.
         * @param {CustomFilterParameters} [customFilterParameters] The parameters for setting the Custom Filter editing mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomFilterTag(fileId: number, customFilterParameters?: CustomFilterParameters, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.setCustomFilterTag(fileId, customFilterParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets an external link to a file with the ID specified in the request.
         * @summary Set an external link
         * @param {number} id The file ID.
         * @param {FileLinkRequest} [fileLinkRequest] The file external link parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.setExternalLink(id, fileLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets order of the files.
         * @summary Set order of files
         * @param {OrdersRequestDtoInteger} [ordersRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFilesOrder(ordersRequestDtoInteger?: OrdersRequestDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerArrayWrapper> {
            return localVarFp.setFilesOrder(ordersRequestDtoInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets order of the file with ID specified in the request.
         * @summary Set file order
         * @param {number} fileId The file unique identifier.
         * @param {OrderRequestDto} [orderRequestDto] The file order information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrderFile(fileId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.setOrderFile(fileId, orderRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Informs about opening a file with the ID specified in the request for editing, locking it from being deleted or moved (this method is called by the mobile editors).
         * @summary Start file editing
         * @param {number} fileId The file ID to start editing.
         * @param {StartEdit} [startEdit] The file parameters to start editing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEdit(fileId: number, startEdit?: StartEdit, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.startEdit(fileId, startEdit, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts filling a file with the ID specified in the request.
         * @summary Start file filling
         * @param {number} fileId The file ID to start filling.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFilling(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.startFilling(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Tracks file changes when editing.
         * @summary Track file editing
         * @param {number} fileId The file ID to track editing changes.
         * @param {string} [tabId] The tab ID to track editing changes.
         * @param {string} [docKeyForTrack] The document key for tracking changes.
         * @param {boolean} [isFinish] Specifies whether to finish file tracking or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEditFile(fileId: number, tabId?: string, docKeyForTrack?: string, isFinish?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<KeyValuePairBooleanStringWrapper> {
            return localVarFp.trackEditFile(fileId, tabId, docKeyForTrack, isFinish, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the information of the selected file with the parameters specified in the request.
         * @summary Update a file
         * @param {number} fileId The file ID to update.
         * @param {UpdateFile} [updateFile] The parameters for updating a file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(fileId: number, updateFile?: UpdateFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.updateFile(fileId, updateFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesFilesApi - object-oriented interface
 * @export
 * @class FilesFilesApi
 * @extends {BaseAPI}
 */
export class FilesFilesApi extends BaseAPI {
    /**
     * Adds files with the IDs specified in the request to the template list.
     * @summary Add template files
     * @param {TemplatesRequestDto} [templatesRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public addTemplates(templatesRequestDto?: TemplatesRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).addTemplates(templatesRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the version history of a file with the ID specified in the request.
     * @summary Change version history
     * @param {number} fileId The file Id to change its version history.
     * @param {ChangeHistory} [changeHistory] The parameters for changing version history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public changeHistory(fileId: number, changeHistory?: ChangeHistory, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).changeHistory(fileId, changeHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the current file is a form draft which can be filled out.
     * @summary Check the form draft filling
     * @param {number} fileId The file ID of the form draft.
     * @param {CheckFillFormDraft} [checkFillFormDraft] The parameters for checking the form draft filling.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public checkFillFormDraft(fileId: number, checkFillFormDraft?: CheckFillFormDraft, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).checkFillFormDraft(fileId, checkFillFormDraft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copies (and converts if possible) an existing file to the specified folder.
     * @summary Copy a file
     * @param {number} fileId The file ID to copy.
     * @param {CopyAsJsonElement} [copyAsJsonElement] The parameters for copying a file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public copyFileAs(fileId: number, copyAsJsonElement?: CopyAsJsonElement, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).copyFileAs(fileId, copyAsJsonElement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a session to edit the existing file with multiple chunks (needed for WebDAV).   **Note**: Information about created session which includes:  <ul>  <li><b>id:</b> unique ID of this upload session,</li>  <li><b>created:</b> UTC time when the session was created,</li>  <li><b>expired:</b> UTC time when the session will expire if no chunks are sent before that time,</li>  <li><b>location:</b> URL where you should send your next chunk,</li>  <li><b>bytes_uploaded:</b> number of bytes uploaded for the specific upload ID,</li>  <li><b>bytes_total:</b> total number of bytes which will be uploaded.</li>  </ul>
     * @summary Create the editing session
     * @param {number} fileId The file ID.
     * @param {number} [fileSize] The file size in bytes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createEditSession(fileId: number, fileSize?: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createEditSession(fileId, fileSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new file in the specified folder with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
     * @summary Create a file
     * @param {number} folderId The folder ID for the file creation.
     * @param {CreateFileJsonElement} [createFileJsonElement] The parameters for creating a file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createFile(folderId: number, createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createFile(folderId, createFileJsonElement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new file in the \"My documents\" section with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
     * @summary Create a file in the \"My documents\" section
     * @param {CreateFileJsonElement} [createFileJsonElement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createFileMyDocuments(createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createFileMyDocuments(createFileJsonElement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an HTML (.html) file in the selected folder with the title and contents specified in the request.
     * @summary Create an HTML file
     * @param {number} folderId The folder ID to create the text or HTML file.
     * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] The parameters for creating an HTML or text file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createHtmlFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createHtmlFile(folderId, createTextOrHtmlFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an HTML (.html) file in the \"My documents\" section with the title and contents specified in the request.
     * @summary Create an HTML file in the \"My documents\" section
     * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createHtmlFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createHtmlFileInMy(createTextOrHtmlFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a primary external link by the identifier specified in the request.
     * @summary Create primary external link
     * @param {number} id The file ID.
     * @param {FileLinkRequest} [fileLinkRequest] The file external link parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createPrimaryExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createPrimaryExternalLink(id, fileLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a text (.txt) file in the selected folder with the title and contents specified in the request.
     * @summary Create a text file
     * @param {number} folderId The folder ID to create the text or HTML file.
     * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] The parameters for creating an HTML or text file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createTextFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createTextFile(folderId, createTextOrHtmlFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a text (.txt) file in the \"My documents\" section with the title and contents specified in the request.
     * @summary Create a text file in the \"My documents\" section
     * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createTextFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createTextFileInMy(createTextOrHtmlFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates thumbnails for the files with the IDs specified in the request.
     * @summary Create file thumbnails
     * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createThumbnails(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createThumbnails(baseBatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a file with the ID specified in the request.
     * @summary Delete a file
     * @param {number} fileId The file ID to delete.
     * @param {Delete} _delete The parameters for deleting a file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public deleteFile(fileId: number, _delete: Delete, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).deleteFile(fileId, _delete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes files with the IDs specified in the request from the \"Recent\" section.
     * @summary Delete recent files
     * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public deleteRecent(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).deleteRecent(baseBatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes files with the IDs specified in the request from the template list.
     * @summary Delete template files
     * @param {Array<number>} [requestBody] The file IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public deleteTemplates(requestBody?: Array<number>, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).deleteTemplates(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all roles for the specified form.
     * @summary Get form roles
     * @param {number} fileId The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getAllFormRoles(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getAllFormRoles(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a URL to the changes of a file version specified in the request.
     * @summary Get changes URL
     * @param {number} fileId The file ID.
     * @param {number} [version] The file version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getEditDiffUrl(fileId: number, version?: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getEditDiffUrl(fileId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the version history of a file with the ID specified in the request.
     * @summary Get version history
     * @param {number} fileId The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getEditHistory(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getEditHistory(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of actions performed on the file with the specified identifier.
     * @summary Get file history
     * @param {number} fileId The file ID of the history request.
     * @param {ApiDateTime} [fromDate] The start date of the history.
     * @param {ApiDateTime} [toDate] The end date of the history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFileHistory(fileId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFileHistory(fileId, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about a file with the ID specified in the request.
     * @summary Get file information
     * @param {number} fileId The file ID.
     * @param {number} [version] The file version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFileInfo(fileId: number, version?: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFileInfo(fileId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary external link by the identifier specified in the request.
     * @summary Get primary external link
     * @param {number} id The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFilePrimaryExternalLink(id: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFilePrimaryExternalLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about all the available file versions with the ID specified in the request.
     * @summary Get file versions
     * @param {number} fileId The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFileVersionInfo(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFileVersionInfo(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the result of a form-filling session.
     * @summary Get form-filling result
     * @param {string} [fillingSessionId] The form-filling session ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFillResult(fillingSessionId?: string, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFillResult(fillingSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the external links of a file with the ID specified in the request.
     * @summary Get file external links
     * @param {number} id The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getLinks(id: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getLinks(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a link to download a file with the ID specified in the request asynchronously.
     * @summary Get file download link asynchronously
     * @param {number} fileId The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getPresignedFileUri(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getPresignedFileUri(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a pre-signed URL to download a file with the specified ID.  This temporary link provides secure access to the file.
     * @summary Get file download link
     * @param {number} fileId The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getPresignedUri(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getPresignedUri(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the reference data to uniquely identify a file in its system and check the availability of insering data into the destination spreadsheet by the external link.
     * @summary Get reference data
     * @param {GetReferenceDataDtoInteger} [getReferenceDataDtoInteger] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getReferenceData(getReferenceDataDtoInteger?: GetReferenceDataDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getReferenceData(getReferenceDataDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the PDF file is a form or not.
     * @summary Check the PDF file
     * @param {number} fileId The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public isFormPDF(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).isFormPDF(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Locks a file with the ID specified in the request.
     * @summary Lock a file
     * @param {number} fileId The file ID for locking.
     * @param {LockFileParameters} [lockFileParameters] The parameters for locking a file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public lockFile(fileId: number, lockFileParameters?: LockFileParameters, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).lockFile(fileId, lockFileParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs the specified form filling action.
     * @summary Perform form filling action
     * @param {string} fileId 
     * @param {ManageFormFillingDtoInteger} [manageFormFillingDtoInteger] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public manageFormFilling(fileId: string, manageFormFillingDtoInteger?: ManageFormFillingDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).manageFormFilling(fileId, manageFormFillingDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the initialization configuration of a file to open it in the editor.
     * @summary Open a file configuration
     * @param {number} fileId The file ID to open.
     * @param {number} [version] The file version to open.
     * @param {boolean} [view] Specifies if the document will be opened for viewing only or not.
     * @param {EditorType} [editorType] The editor type to open the file.
     * @param {boolean} [edit] Specifies if the document is opened in the editing mode or not.
     * @param {boolean} [fill] Specifies if the document is opened in the form-filling mode or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public openEdit(fileId: number, version?: number, view?: boolean, editorType?: EditorType, edit?: boolean, fill?: boolean, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).openEdit(fileId, version, view, editorType, edit, fill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users with their access rights to the protected file with the ID specified in the request.
     * @summary Get users access rights to the protected file
     * @param {number} fileId The file ID of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public protectUsers(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).protectUsers(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores a file version specified in the request.
     * @summary Restore a file version
     * @param {number} fileId The file ID of the restore version.
     * @param {number} [version] The file version of the restore.
     * @param {string} [url] The file version URL of the restore.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public restoreVersion(fileId: number, version?: number, url?: string, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).restoreVersion(fileId, version, url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves a file with the identifier specified in the request as a PDF document.
     * @summary Save a file as PDF
     * @param {number} id The file ID to save as PDF.
     * @param {SaveAsPdfInteger} [saveAsPdfInteger] The parameters for saving file as PDF.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public saveAsPdf(id: number, saveAsPdfInteger?: SaveAsPdfInteger, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).saveAsPdf(id, saveAsPdfInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves edits to a file with the ID specified in the request.
     * @summary Save file edits
     * @param {number} fileId The editing file ID from the request.
     * @param {string} [fileExtension] The editing file extension from the request.
     * @param {string} [downloadUri] The URI to download the editing file.
     * @param {File} [file] The request file stream.
     * @param {boolean} [forcesave] Specifies whether to force save the file or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public saveEditingFromForm(fileId: number, fileExtension?: string, downloadUri?: string, file?: File, forcesave?: boolean, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).saveEditingFromForm(fileId, fileExtension, downloadUri, file, forcesave, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the form role mapping.
     * @summary Save form role mapping
     * @param {string} fileId 
     * @param {SaveFormRoleMappingDtoInteger} [saveFormRoleMappingDtoInteger] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public saveFormRoleMapping(fileId: string, saveFormRoleMappingDtoInteger?: SaveFormRoleMappingDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).saveFormRoleMapping(fileId, saveFormRoleMappingDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the Custom Filter editing mode to a file with the ID specified in the request.
     * @summary Set the Custom Filter editing mode
     * @param {number} fileId The file ID.
     * @param {CustomFilterParameters} [customFilterParameters] The parameters for setting the Custom Filter editing mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public setCustomFilterTag(fileId: number, customFilterParameters?: CustomFilterParameters, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).setCustomFilterTag(fileId, customFilterParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets an external link to a file with the ID specified in the request.
     * @summary Set an external link
     * @param {number} id The file ID.
     * @param {FileLinkRequest} [fileLinkRequest] The file external link parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public setExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).setExternalLink(id, fileLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets order of the files.
     * @summary Set order of files
     * @param {OrdersRequestDtoInteger} [ordersRequestDtoInteger] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public setFilesOrder(ordersRequestDtoInteger?: OrdersRequestDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).setFilesOrder(ordersRequestDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets order of the file with ID specified in the request.
     * @summary Set file order
     * @param {number} fileId The file unique identifier.
     * @param {OrderRequestDto} [orderRequestDto] The file order information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public setOrderFile(fileId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).setOrderFile(fileId, orderRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Informs about opening a file with the ID specified in the request for editing, locking it from being deleted or moved (this method is called by the mobile editors).
     * @summary Start file editing
     * @param {number} fileId The file ID to start editing.
     * @param {StartEdit} [startEdit] The file parameters to start editing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public startEdit(fileId: number, startEdit?: StartEdit, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).startEdit(fileId, startEdit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts filling a file with the ID specified in the request.
     * @summary Start file filling
     * @param {number} fileId The file ID to start filling.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public startFilling(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).startFilling(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tracks file changes when editing.
     * @summary Track file editing
     * @param {number} fileId The file ID to track editing changes.
     * @param {string} [tabId] The tab ID to track editing changes.
     * @param {string} [docKeyForTrack] The document key for tracking changes.
     * @param {boolean} [isFinish] Specifies whether to finish file tracking or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public trackEditFile(fileId: number, tabId?: string, docKeyForTrack?: string, isFinish?: boolean, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).trackEditFile(fileId, tabId, docKeyForTrack, isFinish, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the information of the selected file with the parameters specified in the request.
     * @summary Update a file
     * @param {number} fileId The file ID to update.
     * @param {UpdateFile} [updateFile] The parameters for updating a file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public updateFile(fileId: number, updateFile?: UpdateFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).updateFile(fileId, updateFile, options).then((request) => request(this.axios, this.basePath));
    }
}

