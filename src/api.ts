/* tslint:disable */
/* eslint-disable */
/**
 * ASC.Web.Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountInfoArrayWrapper
 */
export interface AccountInfoArrayWrapper {
    /**
     * 
     * @type {Array<AccountInfoDto>}
     * @memberof AccountInfoArrayWrapper
     */
    'response'?: Array<AccountInfoDto>;
    /**
     * 
     * @type {number}
     * @memberof AccountInfoArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof AccountInfoArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof AccountInfoArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountInfoArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface AccountInfoDto
 */
export interface AccountInfoDto {
    /**
     * Provider
     * @type {string}
     * @memberof AccountInfoDto
     */
    'provider'?: string | null;
    /**
     * URL
     * @type {string}
     * @memberof AccountInfoDto
     */
    'url'?: string | null;
    /**
     * Specifies if an account is linked or not
     * @type {boolean}
     * @memberof AccountInfoDto
     */
    'linked'?: boolean;
}
/**
 * [0 - SSO, 1 - LDAP, 2 - Standart]
 * @export
 * @enum {number}
 */

export const AccountLoginType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type AccountLoginType = typeof AccountLoginType[keyof typeof AccountLoginType];


/**
 * 
 * @export
 * @interface AceShortWrapper
 */
export interface AceShortWrapper {
    /**
     * User
     * @type {string}
     * @memberof AceShortWrapper
     */
    'user'?: string | null;
    /**
     * User access rights to the file
     * @type {string}
     * @memberof AceShortWrapper
     */
    'permissions'?: string | null;
    /**
     * Is link
     * @type {boolean}
     * @memberof AceShortWrapper
     */
    'isLink'?: boolean;
}
/**
 * [0 - None, 1 - Create, 2 - Update, 3 - Delete, 4 - Link, 5 - Unlink, 6 - Attach, 7 - Detach, 8 - Send, 9 - Import, 10 - Export, 11 - Update access, 12 - Download, 13 - Upload, 14 - Copy, 15 - Move, 16 - Reassigns, 17 - Follow, 18 - Unfollow, 19 - Logout]
 * @export
 * @enum {number}
 */

export const ActionType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15,
    NUMBER_16: 16,
    NUMBER_17: 17,
    NUMBER_18: 18,
    NUMBER_19: 19
} as const;

export type ActionType = typeof ActionType[keyof typeof ActionType];


/**
 * 
 * @export
 * @interface ActiveConnectionsDto
 */
export interface ActiveConnectionsDto {
    /**
     * Login event
     * @type {number}
     * @memberof ActiveConnectionsDto
     */
    'loginEvent'?: number;
    /**
     * Items
     * @type {Array<ActiveConnectionsItemDto>}
     * @memberof ActiveConnectionsDto
     */
    'items'?: Array<ActiveConnectionsItemDto> | null;
}
/**
 * 
 * @export
 * @interface ActiveConnectionsItemDto
 */
export interface ActiveConnectionsItemDto {
    /**
     * Id
     * @type {number}
     * @memberof ActiveConnectionsItemDto
     */
    'id'?: number;
    /**
     * Tenant id
     * @type {number}
     * @memberof ActiveConnectionsItemDto
     */
    'tenantId'?: number;
    /**
     * User id
     * @type {string}
     * @memberof ActiveConnectionsItemDto
     */
    'userId'?: string;
    /**
     * Mobile
     * @type {boolean}
     * @memberof ActiveConnectionsItemDto
     */
    'mobile'?: boolean;
    /**
     * Ip
     * @type {string}
     * @memberof ActiveConnectionsItemDto
     */
    'ip'?: string | null;
    /**
     * Country
     * @type {string}
     * @memberof ActiveConnectionsItemDto
     */
    'country'?: string | null;
    /**
     * City
     * @type {string}
     * @memberof ActiveConnectionsItemDto
     */
    'city'?: string | null;
    /**
     * Browser
     * @type {string}
     * @memberof ActiveConnectionsItemDto
     */
    'browser'?: string | null;
    /**
     * Platform
     * @type {string}
     * @memberof ActiveConnectionsItemDto
     */
    'platform'?: string | null;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof ActiveConnectionsItemDto
     */
    'date'?: ApiDateTime;
    /**
     * Page
     * @type {string}
     * @memberof ActiveConnectionsItemDto
     */
    'page'?: string | null;
}
/**
 * 
 * @export
 * @interface ActiveConnectionsWrapper
 */
export interface ActiveConnectionsWrapper {
    /**
     * 
     * @type {ActiveConnectionsDto}
     * @memberof ActiveConnectionsWrapper
     */
    'response'?: ActiveConnectionsDto;
    /**
     * 
     * @type {number}
     * @memberof ActiveConnectionsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ActiveConnectionsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ActiveConnectionsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveConnectionsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface ActiveConnectionsWrapperLinksInner
 */
export interface ActiveConnectionsWrapperLinksInner {
    /**
     * 
     * @type {string}
     * @memberof ActiveConnectionsWrapperLinksInner
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActiveConnectionsWrapperLinksInner
     */
    'action'?: string;
}
/**
 * 
 * @export
 * @interface AdditionalWhiteLabelSettings
 */
export interface AdditionalWhiteLabelSettings {
    /**
     * Specifies if the start document is enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettings
     */
    'startDocsEnabled'?: boolean;
    /**
     * Specifies if the help center is enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettings
     */
    'helpCenterEnabled'?: boolean;
    /**
     * Specifies if feedback and support are available or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettings
     */
    'feedbackAndSupportEnabled'?: boolean;
    /**
     * Specifies if the user forum is enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettings
     */
    'userForumEnabled'?: boolean;
    /**
     * Specifies if the video guides are enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettings
     */
    'videoGuidesEnabled'?: boolean;
    /**
     * Specifies if the license agreements are enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettings
     */
    'licenseAgreementsEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface AdditionalWhiteLabelSettingsDto
 */
export interface AdditionalWhiteLabelSettingsDto {
    /**
     * Specifies if the start document is enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettingsDto
     */
    'startDocsEnabled'?: boolean;
    /**
     * Specifies if the help center is enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettingsDto
     */
    'helpCenterEnabled'?: boolean;
    /**
     * Specifies if feedback and support are available or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettingsDto
     */
    'feedbackAndSupportEnabled'?: boolean;
    /**
     * Specifies if the user forum is enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettingsDto
     */
    'userForumEnabled'?: boolean;
    /**
     * Specifies if the video guides are enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettingsDto
     */
    'videoGuidesEnabled'?: boolean;
    /**
     * Specifies if the license agreements are enabled or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettingsDto
     */
    'licenseAgreementsEnabled'?: boolean;
    /**
     * Specifies if these settings are default or not
     * @type {boolean}
     * @memberof AdditionalWhiteLabelSettingsDto
     */
    'isDefault'?: boolean;
}
/**
 * Additional white label settings
 * @export
 * @interface AdditionalWhiteLabelSettingsWrapper
 */
export interface AdditionalWhiteLabelSettingsWrapper {
    /**
     * 
     * @type {AdditionalWhiteLabelSettings}
     * @memberof AdditionalWhiteLabelSettingsWrapper
     */
    'settings'?: AdditionalWhiteLabelSettings;
}
/**
 * Request parameters for administrator message settings
 * @export
 * @interface AdminMessageBaseSettingsRequestsDto
 */
export interface AdminMessageBaseSettingsRequestsDto {
    /**
     * Email
     * @type {string}
     * @memberof AdminMessageBaseSettingsRequestsDto
     */
    'email'?: string | null;
    /**
     * Culture
     * @type {string}
     * @memberof AdminMessageBaseSettingsRequestsDto
     */
    'culture'?: string | null;
}
/**
 * Request parameters for administrator message settings
 * @export
 * @interface AdminMessageSettingsRequestsDto
 */
export interface AdminMessageSettingsRequestsDto {
    /**
     * Message
     * @type {string}
     * @memberof AdminMessageSettingsRequestsDto
     */
    'message'?: string | null;
    /**
     * Email
     * @type {string}
     * @memberof AdminMessageSettingsRequestsDto
     */
    'email'?: string | null;
    /**
     * Culture
     * @type {string}
     * @memberof AdminMessageSettingsRequestsDto
     */
    'culture'?: string | null;
}
/**
 * 
 * @export
 * @interface AnonymousConfigDto
 */
export interface AnonymousConfigDto {
    /**
     * Request
     * @type {boolean}
     * @memberof AnonymousConfigDto
     */
    'request'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiDateTime
 */
export interface ApiDateTime {
    /**
     * UtcTime
     * @type {string}
     * @memberof ApiDateTime
     */
    'utcTime'?: string;
    /**
     * TimeZoneOffset
     * @type {string}
     * @memberof ApiDateTime
     */
    'timeZoneOffset'?: string;
}
/**
 * [0 - All, 1 - Files, 2 - Folders]
 * @export
 * @enum {number}
 */

export const ApplyFilterOption = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type ApplyFilterOption = typeof ApplyFilterOption[keyof typeof ApplyFilterOption];


/**
 * Parameters for archiving a room
 * @export
 * @interface ArchiveRoomRequest
 */
export interface ArchiveRoomRequest {
    /**
     * Specifies whether to archive a room after the editing session is finished or not
     * @type {boolean}
     * @memberof ArchiveRoomRequest
     */
    'deleteAfter'?: boolean;
}
/**
 * [0 - All, 1 - People, 2 - Guests]
 * @export
 * @enum {number}
 */

export const Area = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type Area = typeof Area[keyof typeof Area];


/**
 * 
 * @export
 * @interface ArrayArrayWrapper
 */
export interface ArrayArrayWrapper {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof ArrayArrayWrapper
     */
    'response'?: Array<Array<string>>;
    /**
     * 
     * @type {number}
     * @memberof ArrayArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ArrayArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ArrayArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ArrayArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface AuditEventArrayWrapper
 */
export interface AuditEventArrayWrapper {
    /**
     * 
     * @type {Array<AuditEventDto>}
     * @memberof AuditEventArrayWrapper
     */
    'response'?: Array<AuditEventDto>;
    /**
     * 
     * @type {number}
     * @memberof AuditEventArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof AuditEventArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof AuditEventArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuditEventArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface AuditEventDto
 */
export interface AuditEventDto {
    /**
     * ID
     * @type {number}
     * @memberof AuditEventDto
     */
    'id'?: number;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof AuditEventDto
     */
    'date'?: ApiDateTime;
    /**
     * User
     * @type {string}
     * @memberof AuditEventDto
     */
    'user'?: string | null;
    /**
     * User ID
     * @type {string}
     * @memberof AuditEventDto
     */
    'userId'?: string;
    /**
     * Action
     * @type {string}
     * @memberof AuditEventDto
     */
    'action'?: string | null;
    /**
     * 
     * @type {MessageAction}
     * @memberof AuditEventDto
     */
    'actionId'?: MessageAction;
    /**
     * IP
     * @type {string}
     * @memberof AuditEventDto
     */
    'ip'?: string | null;
    /**
     * Country
     * @type {string}
     * @memberof AuditEventDto
     */
    'country'?: string | null;
    /**
     * City
     * @type {string}
     * @memberof AuditEventDto
     */
    'city'?: string | null;
    /**
     * Browser
     * @type {string}
     * @memberof AuditEventDto
     */
    'browser'?: string | null;
    /**
     * Platform
     * @type {string}
     * @memberof AuditEventDto
     */
    'platform'?: string | null;
    /**
     * Page
     * @type {string}
     * @memberof AuditEventDto
     */
    'page'?: string | null;
    /**
     * 
     * @type {ActionType}
     * @memberof AuditEventDto
     */
    'actionType'?: ActionType;
    /**
     * 
     * @type {ProductType}
     * @memberof AuditEventDto
     */
    'product'?: ProductType;
    /**
     * 
     * @type {ModuleType}
     * @memberof AuditEventDto
     */
    'module'?: ModuleType;
    /**
     * List of targets
     * @type {Array<string>}
     * @memberof AuditEventDto
     */
    'target'?: Array<string> | null;
    /**
     * List of entry types
     * @type {Array<EntryType>}
     * @memberof AuditEventDto
     */
    'entries'?: Array<EntryType> | null;
    /**
     * Context
     * @type {string}
     * @memberof AuditEventDto
     */
    'context'?: string | null;
}


/**
 * 
 * @export
 * @interface AuthData
 */
export interface AuthData {
    /**
     * Login
     * @type {string}
     * @memberof AuthData
     */
    'login'?: string | null;
    /**
     * Password
     * @type {string}
     * @memberof AuthData
     */
    'password'?: string | null;
    /**
     * Raw token
     * @type {string}
     * @memberof AuthData
     */
    'rawToken'?: string | null;
    /**
     * Url
     * @type {string}
     * @memberof AuthData
     */
    'url'?: string | null;
    /**
     * Provider
     * @type {string}
     * @memberof AuthData
     */
    'provider'?: string | null;
    /**
     * 
     * @type {OAuth20Token}
     * @memberof AuthData
     */
    'token'?: OAuth20Token;
}
/**
 * 
 * @export
 * @interface AuthKey
 */
export interface AuthKey {
    /**
     * Name
     * @type {string}
     * @memberof AuthKey
     */
    'name'?: string | null;
    /**
     * Value
     * @type {string}
     * @memberof AuthKey
     */
    'value'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof AuthKey
     */
    'title'?: string | null;
}
/**
 * Authentication request parameters
 * @export
 * @interface AuthRequestsDto
 */
export interface AuthRequestsDto {
    /**
     * Username / email
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'userName'?: string | null;
    /**
     * Password
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'password'?: string | null;
    /**
     * Password hash
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'passwordHash'?: string | null;
    /**
     * Provider type
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'provider'?: string | null;
    /**
     * Provider access token
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'accessToken'?: string | null;
    /**
     * Serialized user profile
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'serializedProfile'?: string | null;
    /**
     * Two-factor authentication code
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'code'?: string | null;
    /**
     * Code for getting a token
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'codeOAuth'?: string | null;
    /**
     * Session based authentication or not
     * @type {boolean}
     * @memberof AuthRequestsDto
     */
    'session'?: boolean;
    /**
     * 
     * @type {ConfirmData}
     * @memberof AuthRequestsDto
     */
    'confirmData'?: ConfirmData;
    /**
     * 
     * @type {RecaptchaType}
     * @memberof AuthRequestsDto
     */
    'recaptchaType'?: RecaptchaType;
    /**
     * reCAPTCHA response
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'recaptchaResponse'?: string | null;
    /**
     * Culture
     * @type {string}
     * @memberof AuthRequestsDto
     */
    'culture'?: string | null;
}


/**
 * 
 * @export
 * @interface AuthServiceRequestsArrayWrapper
 */
export interface AuthServiceRequestsArrayWrapper {
    /**
     * 
     * @type {Array<AuthServiceRequestsDto>}
     * @memberof AuthServiceRequestsArrayWrapper
     */
    'response'?: Array<AuthServiceRequestsDto>;
    /**
     * 
     * @type {number}
     * @memberof AuthServiceRequestsArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof AuthServiceRequestsArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof AuthServiceRequestsArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthServiceRequestsArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * Request parameters for authorization service
 * @export
 * @interface AuthServiceRequestsDto
 */
export interface AuthServiceRequestsDto {
    /**
     * Name
     * @type {string}
     * @memberof AuthServiceRequestsDto
     */
    'name'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof AuthServiceRequestsDto
     */
    'title'?: string | null;
    /**
     * Description
     * @type {string}
     * @memberof AuthServiceRequestsDto
     */
    'description'?: string | null;
    /**
     * Instruction
     * @type {string}
     * @memberof AuthServiceRequestsDto
     */
    'instruction'?: string | null;
    /**
     * Specifies if the authentication service can be set or not
     * @type {boolean}
     * @memberof AuthServiceRequestsDto
     */
    'canSet'?: boolean;
    /**
     * List of authorization keys
     * @type {Array<AuthKey>}
     * @memberof AuthServiceRequestsDto
     */
    'props'?: Array<AuthKey> | null;
}
/**
 * 
 * @export
 * @interface AuthenticationTokenDto
 */
export interface AuthenticationTokenDto {
    /**
     * Authentication token
     * @type {string}
     * @memberof AuthenticationTokenDto
     */
    'token'?: string | null;
    /**
     * Token expiration time
     * @type {string}
     * @memberof AuthenticationTokenDto
     */
    'expires'?: string;
    /**
     * Specifies if the authentication code is sent by SMS or not
     * @type {boolean}
     * @memberof AuthenticationTokenDto
     */
    'sms'?: boolean;
    /**
     * Phone number
     * @type {string}
     * @memberof AuthenticationTokenDto
     */
    'phoneNoise'?: string | null;
    /**
     * Specifies if the two-factor application is used or not
     * @type {boolean}
     * @memberof AuthenticationTokenDto
     */
    'tfa'?: boolean;
    /**
     * Two-factor authentication key
     * @type {string}
     * @memberof AuthenticationTokenDto
     */
    'tfaKey'?: string | null;
    /**
     * Confirmation email URL
     * @type {string}
     * @memberof AuthenticationTokenDto
     */
    'confirmUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface AuthenticationTokenWrapper
 */
export interface AuthenticationTokenWrapper {
    /**
     * 
     * @type {AuthenticationTokenDto}
     * @memberof AuthenticationTokenWrapper
     */
    'response'?: AuthenticationTokenDto;
    /**
     * 
     * @type {number}
     * @memberof AuthenticationTokenWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof AuthenticationTokenWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof AuthenticationTokenWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthenticationTokenWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface AutoCleanUpData
 */
export interface AutoCleanUpData {
    /**
     * Specifies if the auto-clearing setting is enabled or not
     * @type {boolean}
     * @memberof AutoCleanUpData
     */
    'isAutoCleanUp'?: boolean;
    /**
     * 
     * @type {DateToAutoCleanUp}
     * @memberof AutoCleanUpData
     */
    'gap'?: DateToAutoCleanUp;
}


/**
 * 
 * @export
 * @interface AutoCleanUpDataWrapper
 */
export interface AutoCleanUpDataWrapper {
    /**
     * 
     * @type {AutoCleanUpData}
     * @memberof AutoCleanUpDataWrapper
     */
    'response'?: AutoCleanUpData;
    /**
     * 
     * @type {number}
     * @memberof AutoCleanUpDataWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof AutoCleanUpDataWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof AutoCleanUpDataWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoCleanUpDataWrapper
     */
    'statusCode'?: number;
}
/**
 * Auto-clearing request parameters
 * @export
 * @interface AutoCleanupRequestDto
 */
export interface AutoCleanupRequestDto {
    /**
     * Enables the auto-clearing or not
     * @type {boolean}
     * @memberof AutoCleanupRequestDto
     */
    'set'?: boolean;
    /**
     * 
     * @type {DateToAutoCleanUp}
     * @memberof AutoCleanupRequestDto
     */
    'gap'?: DateToAutoCleanUp;
}


/**
 * Backup parameters
 * @export
 * @interface BackupDto
 */
export interface BackupDto {
    /**
     * 
     * @type {BackupStorageType}
     * @memberof BackupDto
     */
    'storageType'?: BackupStorageType;
    /**
     * Storage parameters
     * @type {Array<ItemKeyValuePairObjectObject>}
     * @memberof BackupDto
     */
    'storageParams'?: Array<ItemKeyValuePairObjectObject> | null;
    /**
     * Specifies if a dump will be created or not
     * @type {boolean}
     * @memberof BackupDto
     */
    'dump'?: boolean;
}


/**
 * 
 * @export
 * @interface BackupHistoryRecord
 */
export interface BackupHistoryRecord {
    /**
     * 
     * @type {string}
     * @memberof BackupHistoryRecord
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BackupHistoryRecord
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {BackupStorageType}
     * @memberof BackupHistoryRecord
     */
    'storageType'?: BackupStorageType;
    /**
     * 
     * @type {string}
     * @memberof BackupHistoryRecord
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BackupHistoryRecord
     */
    'expiresOn'?: string;
}


/**
 * 
 * @export
 * @interface BackupHistoryRecordArrayWrapper
 */
export interface BackupHistoryRecordArrayWrapper {
    /**
     * 
     * @type {Array<BackupHistoryRecord>}
     * @memberof BackupHistoryRecordArrayWrapper
     */
    'response'?: Array<BackupHistoryRecord>;
    /**
     * 
     * @type {number}
     * @memberof BackupHistoryRecordArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof BackupHistoryRecordArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof BackupHistoryRecordArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof BackupHistoryRecordArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Every day, 1 - Every week, 2 - Every month]
 * @export
 * @enum {number}
 */

export const BackupPeriod = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type BackupPeriod = typeof BackupPeriod[keyof typeof BackupPeriod];


/**
 * 
 * @export
 * @interface BackupProgress
 */
export interface BackupProgress {
    /**
     * 
     * @type {boolean}
     * @memberof BackupProgress
     */
    'isCompleted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BackupProgress
     */
    'progress'?: number;
    /**
     * 
     * @type {string}
     * @memberof BackupProgress
     */
    'error'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BackupProgress
     */
    'link'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BackupProgress
     */
    'tenantId'?: number;
    /**
     * 
     * @type {BackupProgressEnum}
     * @memberof BackupProgress
     */
    'backupProgressEnum'?: BackupProgressEnum;
    /**
     * 
     * @type {string}
     * @memberof BackupProgress
     */
    'taskId'?: string | null;
}


/**
 * [0 - Backup, 1 - Restore, 2 - Transfer]
 * @export
 * @enum {number}
 */

export const BackupProgressEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type BackupProgressEnum = typeof BackupProgressEnum[keyof typeof BackupProgressEnum];


/**
 * 
 * @export
 * @interface BackupProgressWrapper
 */
export interface BackupProgressWrapper {
    /**
     * 
     * @type {BackupProgress}
     * @memberof BackupProgressWrapper
     */
    'response'?: BackupProgress;
    /**
     * 
     * @type {number}
     * @memberof BackupProgressWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof BackupProgressWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof BackupProgressWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof BackupProgressWrapper
     */
    'statusCode'?: number;
}
/**
 * Restoring parameters
 * @export
 * @interface BackupRestoreDto
 */
export interface BackupRestoreDto {
    /**
     * Backup ID
     * @type {string}
     * @memberof BackupRestoreDto
     */
    'backupId'?: string | null;
    /**
     * 
     * @type {BackupStorageType}
     * @memberof BackupRestoreDto
     */
    'storageType'?: BackupStorageType;
    /**
     * Storage parameters
     * @type {Array<ItemKeyValuePairObjectObject>}
     * @memberof BackupRestoreDto
     */
    'storageParams'?: Array<ItemKeyValuePairObjectObject> | null;
    /**
     * Notifies users about portal restoring process or not
     * @type {boolean}
     * @memberof BackupRestoreDto
     */
    'notify'?: boolean;
    /**
     * Expect  dump or not
     * @type {boolean}
     * @memberof BackupRestoreDto
     */
    'dump'?: boolean;
}


/**
 * Backup schedule parameters
 * @export
 * @interface BackupScheduleDto
 */
export interface BackupScheduleDto {
    /**
     * 
     * @type {BackupStorageType}
     * @memberof BackupScheduleDto
     */
    'storageType'?: BackupStorageType;
    /**
     * Storage parameters
     * @type {Array<ItemKeyValuePairObjectObject>}
     * @memberof BackupScheduleDto
     */
    'storageParams'?: Array<ItemKeyValuePairObjectObject> | null;
    /**
     * Maximum number of the stored backup copies
     * @type {number}
     * @memberof BackupScheduleDto
     */
    'backupsStored'?: number | null;
    /**
     * 
     * @type {Cron}
     * @memberof BackupScheduleDto
     */
    'cronParams'?: Cron;
    /**
     * Specifies if a dump will be created or not
     * @type {boolean}
     * @memberof BackupScheduleDto
     */
    'dump'?: boolean;
}


/**
 * [0 - Documents, 1 - Thridparty documents, 2 - Custom cloud, 3 - Local, 4 - Data store, 5 - Thirdparty consumer]
 * @export
 * @enum {number}
 */

export const BackupStorageType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5
} as const;

export type BackupStorageType = typeof BackupStorageType[keyof typeof BackupStorageType];


/**
 * Base batch request parameters
 * @export
 * @interface BaseBatchRequestDto
 */
export interface BaseBatchRequestDto {
    /**
     * List of folder IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof BaseBatchRequestDto
     */
    'folderIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * List of file IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof BaseBatchRequestDto
     */
    'fileIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
}
/**
 * 
 * @export
 * @interface BaseBatchRequestDtoFolderIdsInner
 */
export interface BaseBatchRequestDtoFolderIdsInner {
}
/**
 * Request parameters for copying/moving files
 * @export
 * @interface BatchRequestDto
 */
export interface BatchRequestDto {
    /**
     * List of folder IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof BatchRequestDto
     */
    'folderIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * List of file IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof BatchRequestDto
     */
    'fileIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * 
     * @type {BatchRequestDtoDestFolderId}
     * @memberof BatchRequestDto
     */
    'destFolderId'?: BatchRequestDtoDestFolderId;
    /**
     * 
     * @type {FileConflictResolveType}
     * @memberof BatchRequestDto
     */
    'conflictResolveType'?: FileConflictResolveType;
    /**
     * Specifies whether to delete a folder after the editing session is finished or not
     * @type {boolean}
     * @memberof BatchRequestDto
     */
    'deleteAfter'?: boolean;
    /**
     * Content
     * @type {boolean}
     * @memberof BatchRequestDto
     */
    'content'?: boolean;
}


/**
 * @type BatchRequestDtoDestFolderId
 * Destination folder ID
 * @export
 */
export type BatchRequestDtoDestFolderId = number | string;

/**
 * Request parameters for adding tags
 * @export
 * @interface BatchTagsRequestDto
 */
export interface BatchTagsRequestDto {
    /**
     * Tag names
     * @type {Array<string>}
     * @memberof BatchTagsRequestDto
     */
    'names'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface BooleanWrapper
 */
export interface BooleanWrapper {
    /**
     * 
     * @type {boolean}
     * @memberof BooleanWrapper
     */
    'response'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BooleanWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof BooleanWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof BooleanWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof BooleanWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface CapabilitiesDto
 */
export interface CapabilitiesDto {
    /**
     * Specifies if the LDAP settings are enabled or not
     * @type {boolean}
     * @memberof CapabilitiesDto
     */
    'ldapEnabled'?: boolean;
    /**
     * Ldap domain
     * @type {string}
     * @memberof CapabilitiesDto
     */
    'ldapDomain'?: string | null;
    /**
     * List of providers
     * @type {Array<string>}
     * @memberof CapabilitiesDto
     */
    'providers'?: Array<string> | null;
    /**
     * SP login label
     * @type {string}
     * @memberof CapabilitiesDto
     */
    'ssoLabel'?: string | null;
    /**
     * Specifies if OAuth is enabled or not
     * @type {boolean}
     * @memberof CapabilitiesDto
     */
    'oauthEnabled'?: boolean;
    /**
     * SSO URL. If this parameter is empty, then the SSO settings are disabled
     * @type {string}
     * @memberof CapabilitiesDto
     */
    'ssoUrl'?: string | null;
    /**
     * Specifies if identity server is enabled or not
     * @type {boolean}
     * @memberof CapabilitiesDto
     */
    'identityServerEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface CapabilitiesWrapper
 */
export interface CapabilitiesWrapper {
    /**
     * 
     * @type {CapabilitiesDto}
     * @memberof CapabilitiesWrapper
     */
    'response'?: CapabilitiesDto;
    /**
     * 
     * @type {number}
     * @memberof CapabilitiesWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CapabilitiesWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CapabilitiesWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CapabilitiesWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface CdnStorageSettings
 */
export interface CdnStorageSettings {
    /**
     * 
     * @type {string}
     * @memberof CdnStorageSettings
     */
    'module'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * @memberof CdnStorageSettings
     */
    'props'?: { [key: string]: string | null; } | null;
}
/**
 * 
 * @export
 * @interface CdnStorageSettingsWrapper
 */
export interface CdnStorageSettingsWrapper {
    /**
     * 
     * @type {CdnStorageSettings}
     * @memberof CdnStorageSettingsWrapper
     */
    'response'?: CdnStorageSettings;
    /**
     * 
     * @type {number}
     * @memberof CdnStorageSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CdnStorageSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CdnStorageSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CdnStorageSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * Parameters for changing version history
 * @export
 * @interface ChangeHistory
 */
export interface ChangeHistory {
    /**
     * File version
     * @type {number}
     * @memberof ChangeHistory
     */
    'version'?: number;
    /**
     * Marks as a version or revision
     * @type {boolean}
     * @memberof ChangeHistory
     */
    'continueVersion'?: boolean;
}
/**
 * Request parameters for starting file conversion
 * @export
 * @interface CheckConversionRequestDtoInteger
 */
export interface CheckConversionRequestDtoInteger {
    /**
     * File ID
     * @type {number}
     * @memberof CheckConversionRequestDtoInteger
     */
    'fileId'?: number;
    /**
     * Specifies if the conversion process is synchronous or not
     * @type {boolean}
     * @memberof CheckConversionRequestDtoInteger
     */
    'sync'?: boolean;
    /**
     * Specifies whether to start a conversion process or not
     * @type {boolean}
     * @memberof CheckConversionRequestDtoInteger
     */
    'startConvert'?: boolean;
    /**
     * File version
     * @type {number}
     * @memberof CheckConversionRequestDtoInteger
     */
    'version'?: number;
    /**
     * Password
     * @type {string}
     * @memberof CheckConversionRequestDtoInteger
     */
    'password'?: string | null;
    /**
     * Output type
     * @type {string}
     * @memberof CheckConversionRequestDtoInteger
     */
    'outputType'?: string | null;
    /**
     * Create new if exists
     * @type {boolean}
     * @memberof CheckConversionRequestDtoInteger
     */
    'createNewIfExist'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckDestFolderDto
 */
export interface CheckDestFolderDto {
    /**
     * 
     * @type {CheckDestFolderResult}
     * @memberof CheckDestFolderDto
     */
    'result'?: CheckDestFolderResult;
    /**
     * Files
     * @type {Array<FileEntryDto>}
     * @memberof CheckDestFolderDto
     */
    'files'?: Array<FileEntryDto> | null;
}


/**
 * [0 - All allowed, 1 - Part allowed, 2 - None allowed]
 * @export
 * @enum {number}
 */

export const CheckDestFolderResult = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type CheckDestFolderResult = typeof CheckDestFolderResult[keyof typeof CheckDestFolderResult];


/**
 * 
 * @export
 * @interface CheckDestFolderWrapper
 */
export interface CheckDestFolderWrapper {
    /**
     * 
     * @type {CheckDestFolderDto}
     * @memberof CheckDestFolderWrapper
     */
    'response'?: CheckDestFolderDto;
    /**
     * 
     * @type {number}
     * @memberof CheckDestFolderWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CheckDestFolderWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CheckDestFolderWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CheckDestFolderWrapper
     */
    'statusCode'?: number;
}
/**
 * Request parameters for checking the document service location
 * @export
 * @interface CheckDocServiceUrlRequestDto
 */
export interface CheckDocServiceUrlRequestDto {
    /**
     * The Document Server address
     * @type {string}
     * @memberof CheckDocServiceUrlRequestDto
     */
    'docServiceUrl'?: string | null;
    /**
     * The Document Server address in the local private network
     * @type {string}
     * @memberof CheckDocServiceUrlRequestDto
     */
    'docServiceUrlInternal'?: string | null;
    /**
     * The Community Server address
     * @type {string}
     * @memberof CheckDocServiceUrlRequestDto
     */
    'docServiceUrlPortal'?: string | null;
    /**
     * Signature secret
     * @type {string}
     * @memberof CheckDocServiceUrlRequestDto
     */
    'docServiceSignatureSecret'?: string | null;
    /**
     * Signature header
     * @type {string}
     * @memberof CheckDocServiceUrlRequestDto
     */
    'docServiceSignatureHeader'?: string | null;
    /**
     * Enable SSL verification
     * @type {boolean}
     * @memberof CheckDocServiceUrlRequestDto
     */
    'docServiceSslVerification'?: boolean | null;
}
/**
 * Parameters for checking a form draft
 * @export
 * @interface CheckFillFormDraft
 */
export interface CheckFillFormDraft {
    /**
     * File version
     * @type {number}
     * @memberof CheckFillFormDraft
     */
    'version'?: number;
    /**
     * Action with a form
     * @type {string}
     * @memberof CheckFillFormDraft
     */
    'action'?: string | null;
    /**
     * Specifies whether to request a form for viewing or not
     * @type {boolean}
     * @memberof CheckFillFormDraft
     */
    'requestView'?: boolean;
    /**
     * Specifies whether to request an embedded form or not
     * @type {boolean}
     * @memberof CheckFillFormDraft
     */
    'requestEmbedded'?: boolean;
}
/**
 * Parameters for checking files uploading
 * @export
 * @interface CheckUploadRequest
 */
export interface CheckUploadRequest {
    /**
     * File title
     * @type {Array<string>}
     * @memberof CheckUploadRequest
     */
    'filesTitle'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CoEditingConfig
 */
export interface CoEditingConfig {
    /**
     * Change
     * @type {boolean}
     * @memberof CoEditingConfig
     */
    'change'?: boolean;
    /**
     * Fast
     * @type {boolean}
     * @memberof CoEditingConfig
     */
    'fast'?: boolean;
    /**
     * 
     * @type {CoEditingConfigMode}
     * @memberof CoEditingConfig
     */
    'mode'?: CoEditingConfigMode;
}


/**
 * [0 - Fast, 1 - Strict]
 * @export
 * @enum {number}
 */

export const CoEditingConfigMode = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type CoEditingConfigMode = typeof CoEditingConfigMode[keyof typeof CoEditingConfigMode];


/**
 * 
 * @export
 * @interface CompanyWhiteLabelSettings
 */
export interface CompanyWhiteLabelSettings {
    /**
     * Company name
     * @type {string}
     * @memberof CompanyWhiteLabelSettings
     */
    'companyName'?: string | null;
    /**
     * Site
     * @type {string}
     * @memberof CompanyWhiteLabelSettings
     */
    'site'?: string | null;
    /**
     * Email address
     * @type {string}
     * @memberof CompanyWhiteLabelSettings
     */
    'email'?: string | null;
    /**
     * Address
     * @type {string}
     * @memberof CompanyWhiteLabelSettings
     */
    'address'?: string | null;
    /**
     * Phone
     * @type {string}
     * @memberof CompanyWhiteLabelSettings
     */
    'phone'?: string | null;
    /**
     * Specifies if a company is a licensor or not
     * @type {boolean}
     * @memberof CompanyWhiteLabelSettings
     */
    'IsLicensor'?: boolean;
}
/**
 * 
 * @export
 * @interface CompanyWhiteLabelSettingsArrayWrapper
 */
export interface CompanyWhiteLabelSettingsArrayWrapper {
    /**
     * 
     * @type {Array<CompanyWhiteLabelSettings>}
     * @memberof CompanyWhiteLabelSettingsArrayWrapper
     */
    'response'?: Array<CompanyWhiteLabelSettings>;
    /**
     * 
     * @type {number}
     * @memberof CompanyWhiteLabelSettingsArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CompanyWhiteLabelSettingsArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CompanyWhiteLabelSettingsArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyWhiteLabelSettingsArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface CompanyWhiteLabelSettingsDto
 */
export interface CompanyWhiteLabelSettingsDto {
    /**
     * Company name
     * @type {string}
     * @memberof CompanyWhiteLabelSettingsDto
     */
    'companyName'?: string | null;
    /**
     * Site
     * @type {string}
     * @memberof CompanyWhiteLabelSettingsDto
     */
    'site'?: string | null;
    /**
     * Email
     * @type {string}
     * @memberof CompanyWhiteLabelSettingsDto
     */
    'email'?: string | null;
    /**
     * Address
     * @type {string}
     * @memberof CompanyWhiteLabelSettingsDto
     */
    'address'?: string | null;
    /**
     * Phone number
     * @type {string}
     * @memberof CompanyWhiteLabelSettingsDto
     */
    'phone'?: string | null;
    /**
     * Specifies if a company is a licensor or not
     * @type {boolean}
     * @memberof CompanyWhiteLabelSettingsDto
     */
    'isLicensor'?: boolean;
    /**
     * Specifies if these settings are default or not
     * @type {boolean}
     * @memberof CompanyWhiteLabelSettingsDto
     */
    'isDefault'?: boolean;
}
/**
 * Company white label settings
 * @export
 * @interface CompanyWhiteLabelSettingsWrapper
 */
export interface CompanyWhiteLabelSettingsWrapper {
    /**
     * 
     * @type {CompanyWhiteLabelSettings}
     * @memberof CompanyWhiteLabelSettingsWrapper
     */
    'settings'?: CompanyWhiteLabelSettings;
}
/**
 * 
 * @export
 * @interface ConfigurationDtoInteger
 */
export interface ConfigurationDtoInteger {
    /**
     * 
     * @type {DocumentConfigDto}
     * @memberof ConfigurationDtoInteger
     */
    'document'?: DocumentConfigDto;
    /**
     * Document type
     * @type {string}
     * @memberof ConfigurationDtoInteger
     */
    'documentType'?: string | null;
    /**
     * 
     * @type {EditorConfigurationDto}
     * @memberof ConfigurationDtoInteger
     */
    'editorConfig'?: EditorConfigurationDto;
    /**
     * 
     * @type {EditorType}
     * @memberof ConfigurationDtoInteger
     */
    'editorType'?: EditorType;
    /**
     * Editor URL
     * @type {string}
     * @memberof ConfigurationDtoInteger
     */
    'editorUrl'?: string | null;
    /**
     * Token
     * @type {string}
     * @memberof ConfigurationDtoInteger
     */
    'token'?: string | null;
    /**
     * Platform type
     * @type {string}
     * @memberof ConfigurationDtoInteger
     */
    'type'?: string | null;
    /**
     * 
     * @type {FileDtoInteger}
     * @memberof ConfigurationDtoInteger
     */
    'file'?: FileDtoInteger;
    /**
     * Error message
     * @type {string}
     * @memberof ConfigurationDtoInteger
     */
    'errorMessage'?: string | null;
    /**
     * Specifies if the filling has started or not
     * @type {boolean}
     * @memberof ConfigurationDtoInteger
     */
    'startFilling'?: boolean | null;
    /**
     * Filling session Id
     * @type {string}
     * @memberof ConfigurationDtoInteger
     */
    'fillingSessionId'?: string | null;
}


/**
 * 
 * @export
 * @interface ConfigurationIntegerWrapper
 */
export interface ConfigurationIntegerWrapper {
    /**
     * 
     * @type {ConfigurationDtoInteger}
     * @memberof ConfigurationIntegerWrapper
     */
    'response'?: ConfigurationDtoInteger;
    /**
     * 
     * @type {number}
     * @memberof ConfigurationIntegerWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ConfigurationIntegerWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ConfigurationIntegerWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConfigurationIntegerWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface ConfirmData
 */
export interface ConfirmData {
    /**
     * Email address
     * @type {string}
     * @memberof ConfirmData
     */
    'email'?: string | null;
    /**
     * Access an account for the first time or not
     * @type {boolean}
     * @memberof ConfirmData
     */
    'first'?: boolean | null;
    /**
     * Key
     * @type {string}
     * @memberof ConfirmData
     */
    'key'?: string | null;
}
/**
 * 
 * @export
 * @interface ConfirmDto
 */
export interface ConfirmDto {
    /**
     * 
     * @type {ValidationResult}
     * @memberof ConfirmDto
     */
    'result'?: ValidationResult;
    /**
     * Room id
     * @type {string}
     * @memberof ConfirmDto
     */
    'roomId'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof ConfirmDto
     */
    'title'?: string | null;
}


/**
 * 
 * @export
 * @enum {number}
 */

export const ConfirmType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15,
    NUMBER_16: 16,
    NUMBER_17: 17
} as const;

export type ConfirmType = typeof ConfirmType[keyof typeof ConfirmType];


/**
 * 
 * @export
 * @interface ConfirmWrapper
 */
export interface ConfirmWrapper {
    /**
     * 
     * @type {ConfirmDto}
     * @memberof ConfirmWrapper
     */
    'response'?: ConfirmDto;
    /**
     * 
     * @type {number}
     * @memberof ConfirmWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ConfirmWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ConfirmWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConfirmWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * Contact type
     * @type {string}
     * @memberof Contact
     */
    'type'?: string | null;
    /**
     * Contact value
     * @type {string}
     * @memberof Contact
     */
    'value'?: string | null;
}
/**
 * Parameters for updating user contacts
 * @export
 * @interface ContactsRequest
 */
export interface ContactsRequest {
    /**
     * List of user contacts
     * @type {Array<Contact>}
     * @memberof ContactsRequest
     */
    'contacts'?: Array<Contact> | null;
}
/**
 * 
 * @export
 * @interface ContentDisposition
 */
export interface ContentDisposition {
    /**
     * 
     * @type {string}
     * @memberof ContentDisposition
     */
    'dispositionType'?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof ContentDisposition
     */
    'parameters'?: Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof ContentDisposition
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentDisposition
     */
    'creationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentDisposition
     */
    'modificationDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContentDisposition
     */
    'inline'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ContentDisposition
     */
    'readDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContentDisposition
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface ContentType
 */
export interface ContentType {
    /**
     * 
     * @type {string}
     * @memberof ContentType
     */
    'boundary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentType
     */
    'charSet'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentType
     */
    'mediaType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentType
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof ContentType
     */
    'parameters'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface ConversationResultArrayWrapper
 */
export interface ConversationResultArrayWrapper {
    /**
     * 
     * @type {Array<ConversationResultDto>}
     * @memberof ConversationResultArrayWrapper
     */
    'response'?: Array<ConversationResultDto>;
    /**
     * 
     * @type {number}
     * @memberof ConversationResultArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ConversationResultArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ConversationResultArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConversationResultArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * Result of file conversation operation.
 * @export
 * @interface ConversationResultDto
 */
export interface ConversationResultDto {
    /**
     * Operation ID
     * @type {string}
     * @memberof ConversationResultDto
     */
    'id'?: string | null;
    /**
     * 
     * @type {FileOperationType}
     * @memberof ConversationResultDto
     */
    'Operation'?: FileOperationType;
    /**
     * Operation progress
     * @type {number}
     * @memberof ConversationResultDto
     */
    'progress'?: number;
    /**
     * Source file
     * @type {string}
     * @memberof ConversationResultDto
     */
    'source'?: string | null;
    /**
     * Resulting file
     * @type {any}
     * @memberof ConversationResultDto
     */
    'result'?: any | null;
    /**
     * Error
     * @type {string}
     * @memberof ConversationResultDto
     */
    'error'?: string | null;
    /**
     * Specifies if the operation is processed or not
     * @type {string}
     * @memberof ConversationResultDto
     */
    'processed'?: string | null;
}


/**
 * 
 * @export
 * @interface CookieSettingsDto
 */
export interface CookieSettingsDto {
    /**
     * Lifetime value in minutes
     * @type {number}
     * @memberof CookieSettingsDto
     */
    'lifeTime'?: number;
    /**
     * Specifies if the cookie settings are enabled or not
     * @type {boolean}
     * @memberof CookieSettingsDto
     */
    'enabled'?: boolean;
}
/**
 * Cookies settings request parameters
 * @export
 * @interface CookieSettingsRequestsDto
 */
export interface CookieSettingsRequestsDto {
    /**
     * Lifetime value in minutes
     * @type {number}
     * @memberof CookieSettingsRequestsDto
     */
    'lifeTime'?: number;
    /**
     * Specifies if the cookie settings are enabled or not
     * @type {boolean}
     * @memberof CookieSettingsRequestsDto
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface CookieSettingsWrapper
 */
export interface CookieSettingsWrapper {
    /**
     * 
     * @type {CookieSettingsDto}
     * @memberof CookieSettingsWrapper
     */
    'response'?: CookieSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof CookieSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CookieSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CookieSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CookieSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * Parameters for copying a file
 * @export
 * @interface CopyAsJsonElement
 */
export interface CopyAsJsonElement {
    /**
     * Destination file title
     * @type {string}
     * @memberof CopyAsJsonElement
     */
    'destTitle'?: string | null;
    /**
     * 
     * @type {BatchRequestDtoDestFolderId}
     * @memberof CopyAsJsonElement
     */
    'destFolderId'?: BatchRequestDtoDestFolderId;
    /**
     * Specifies whether to allow the creation of external extension files or not
     * @type {boolean}
     * @memberof CopyAsJsonElement
     */
    'enableExternalExt'?: boolean;
    /**
     * Password
     * @type {string}
     * @memberof CopyAsJsonElement
     */
    'password'?: string | null;
    /**
     * Convert to form
     * @type {boolean}
     * @memberof CopyAsJsonElement
     */
    'toForm'?: boolean;
}
/**
 * Parameters to change the room cover
 * @export
 * @interface CoverRequestDto
 */
export interface CoverRequestDto {
    /**
     * Color
     * @type {string}
     * @memberof CoverRequestDto
     */
    'color'?: string | null;
    /**
     * Cover
     * @type {string}
     * @memberof CoverRequestDto
     */
    'cover'?: string | null;
}
/**
 * 
 * @export
 * @interface CoversResultArrayWrapper
 */
export interface CoversResultArrayWrapper {
    /**
     * 
     * @type {Array<CoversResultDto>}
     * @memberof CoversResultArrayWrapper
     */
    'response'?: Array<CoversResultDto>;
    /**
     * 
     * @type {number}
     * @memberof CoversResultArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CoversResultArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CoversResultArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CoversResultArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * Represents the result of a covers request containing cover image data
 * @export
 * @interface CoversResultDto
 */
export interface CoversResultDto {
    /**
     * The unique identifier of the cover
     * @type {string}
     * @memberof CoversResultDto
     */
    'id'?: string | null;
    /**
     * The cover image data
     * @type {string}
     * @memberof CoversResultDto
     */
    'data'?: string | null;
}
/**
 * Parameters for creating a file
 * @export
 * @interface CreateFileJsonElement
 */
export interface CreateFileJsonElement {
    /**
     * File title
     * @type {string}
     * @memberof CreateFileJsonElement
     */
    'title'?: string | null;
    /**
     * 
     * @type {CreateFileJsonElementTemplateId}
     * @memberof CreateFileJsonElement
     */
    'templateId'?: CreateFileJsonElementTemplateId;
    /**
     * Specifies whether to allow the creation of external extension files or not
     * @type {boolean}
     * @memberof CreateFileJsonElement
     */
    'enableExternalExt'?: boolean;
    /**
     * Form ID
     * @type {number}
     * @memberof CreateFileJsonElement
     */
    'formId'?: number;
}
/**
 * @type CreateFileJsonElementTemplateId
 * Template file ID
 * @export
 */
export type CreateFileJsonElementTemplateId = number | string;

/**
 * Parameters for creating a folder: Title (string) - new folder title
 * @export
 * @interface CreateFolder
 */
export interface CreateFolder {
    /**
     * Folder title
     * @type {string}
     * @memberof CreateFolder
     */
    'title'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateRoomFromTemplateDto
 */
export interface CreateRoomFromTemplateDto {
    /**
     * Template id
     * @type {number}
     * @memberof CreateRoomFromTemplateDto
     */
    'templateId'?: number;
    /**
     * Title
     * @type {string}
     * @memberof CreateRoomFromTemplateDto
     */
    'title'?: string | null;
    /**
     * 
     * @type {LogoRequest}
     * @memberof CreateRoomFromTemplateDto
     */
    'logo'?: LogoRequest;
    /**
     * Copy logo
     * @type {boolean}
     * @memberof CreateRoomFromTemplateDto
     */
    'copyLogo'?: boolean;
    /**
     * Collection of tags
     * @type {Array<string>}
     * @memberof CreateRoomFromTemplateDto
     */
    'tags'?: Array<string> | null;
    /**
     * Color
     * @type {string}
     * @memberof CreateRoomFromTemplateDto
     */
    'color'?: string | null;
    /**
     * Cover
     * @type {string}
     * @memberof CreateRoomFromTemplateDto
     */
    'cover'?: string | null;
}
/**
 * Request parameters for creating a room
 * @export
 * @interface CreateRoomRequestDto
 */
export interface CreateRoomRequestDto {
    /**
     * Room name
     * @type {string}
     * @memberof CreateRoomRequestDto
     */
    'title'?: string | null;
    /**
     * Room quota
     * @type {number}
     * @memberof CreateRoomRequestDto
     */
    'quota'?: number | null;
    /**
     * Indexing
     * @type {boolean}
     * @memberof CreateRoomRequestDto
     */
    'indexing'?: boolean | null;
    /**
     * Room quota
     * @type {boolean}
     * @memberof CreateRoomRequestDto
     */
    'denyDownload'?: boolean | null;
    /**
     * 
     * @type {RoomDataLifetimeDto}
     * @memberof CreateRoomRequestDto
     */
    'lifetime'?: RoomDataLifetimeDto;
    /**
     * 
     * @type {WatermarkRequestDto}
     * @memberof CreateRoomRequestDto
     */
    'watermark'?: WatermarkRequestDto;
    /**
     * 
     * @type {LogoRequest}
     * @memberof CreateRoomRequestDto
     */
    'logo'?: LogoRequest;
    /**
     * List of tags
     * @type {Array<string>}
     * @memberof CreateRoomRequestDto
     */
    'tags'?: Array<string> | null;
    /**
     * Color
     * @type {string}
     * @memberof CreateRoomRequestDto
     */
    'color'?: string | null;
    /**
     * Cover
     * @type {string}
     * @memberof CreateRoomRequestDto
     */
    'cover'?: string | null;
    /**
     * 
     * @type {RoomType}
     * @memberof CreateRoomRequestDto
     */
    'roomType'?: RoomType;
    /**
     * Private
     * @type {boolean}
     * @memberof CreateRoomRequestDto
     */
    'private'?: boolean;
    /**
     * Collection of sharing parameters
     * @type {Array<FileShareParams>}
     * @memberof CreateRoomRequestDto
     */
    'share'?: Array<FileShareParams> | null;
}


/**
 * Request parameters for creating a tag
 * @export
 * @interface CreateTagRequestDto
 */
export interface CreateTagRequestDto {
    /**
     * Tag name
     * @type {string}
     * @memberof CreateTagRequestDto
     */
    'name'?: string | null;
}
/**
 * Parameters for creating an HTML file
 * @export
 * @interface CreateTextOrHtmlFile
 */
export interface CreateTextOrHtmlFile {
    /**
     * File title
     * @type {string}
     * @memberof CreateTextOrHtmlFile
     */
    'title': string;
    /**
     * File contents
     * @type {string}
     * @memberof CreateTextOrHtmlFile
     */
    'content'?: string | null;
    /**
     * Create new if exist
     * @type {boolean}
     * @memberof CreateTextOrHtmlFile
     */
    'createNewIfExist'?: boolean;
}
/**
 * Parameters for creating a room
 * @export
 * @interface CreateThirdPartyRoom
 */
export interface CreateThirdPartyRoom {
    /**
     * Create as new folder
     * @type {boolean}
     * @memberof CreateThirdPartyRoom
     */
    'createAsNewFolder'?: boolean;
    /**
     * Room name
     * @type {string}
     * @memberof CreateThirdPartyRoom
     */
    'title'?: string | null;
    /**
     * 
     * @type {RoomType}
     * @memberof CreateThirdPartyRoom
     */
    'roomType'?: RoomType;
    /**
     * Private
     * @type {boolean}
     * @memberof CreateThirdPartyRoom
     */
    'private'?: boolean;
    /**
     * Indexing
     * @type {boolean}
     * @memberof CreateThirdPartyRoom
     */
    'indexing'?: boolean;
    /**
     * Deny download
     * @type {boolean}
     * @memberof CreateThirdPartyRoom
     */
    'denyDownload'?: boolean;
    /**
     * Color
     * @type {string}
     * @memberof CreateThirdPartyRoom
     */
    'color'?: string | null;
    /**
     * Cover
     * @type {string}
     * @memberof CreateThirdPartyRoom
     */
    'cover'?: string | null;
    /**
     * Tags
     * @type {Array<string>}
     * @memberof CreateThirdPartyRoom
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {LogoRequest}
     * @memberof CreateThirdPartyRoom
     */
    'logo'?: LogoRequest;
}


/**
 * Cron parameters
 * @export
 * @interface Cron
 */
export interface Cron {
    /**
     * 
     * @type {BackupPeriod}
     * @memberof Cron
     */
    'period'?: BackupPeriod;
    /**
     * Hour
     * @type {number}
     * @memberof Cron
     */
    'hour'?: number;
    /**
     * Day
     * @type {number}
     * @memberof Cron
     */
    'day'?: number | null;
}


/**
 * 
 * @export
 * @interface CronParams
 */
export interface CronParams {
    /**
     * 
     * @type {BackupPeriod}
     * @memberof CronParams
     */
    'period'?: BackupPeriod;
    /**
     * 
     * @type {number}
     * @memberof CronParams
     */
    'hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof CronParams
     */
    'day'?: number;
}


/**
 * 
 * @export
 * @interface CspDto
 */
export interface CspDto {
    /**
     * Domains
     * @type {Array<string>}
     * @memberof CspDto
     */
    'domains'?: Array<string> | null;
    /**
     * Header
     * @type {string}
     * @memberof CspDto
     */
    'header'?: string | null;
}
/**
 * 
 * @export
 * @interface CspRequestsDto
 */
export interface CspRequestsDto {
    /**
     * Domains
     * @type {Array<string>}
     * @memberof CspRequestsDto
     */
    'domains'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CspWrapper
 */
export interface CspWrapper {
    /**
     * 
     * @type {CspDto}
     * @memberof CspWrapper
     */
    'response'?: CspDto;
    /**
     * 
     * @type {number}
     * @memberof CspWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CspWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CspWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CspWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface CultureSpecificExternalResource
 */
export interface CultureSpecificExternalResource {
    /**
     * 
     * @type {string}
     * @memberof CultureSpecificExternalResource
     */
    'domain'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * @memberof CultureSpecificExternalResource
     */
    'entries'?: { [key: string]: string | null; } | null;
}
/**
 * 
 * @export
 * @interface CultureSpecificExternalResources
 */
export interface CultureSpecificExternalResources {
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'api'?: CultureSpecificExternalResource;
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'common'?: CultureSpecificExternalResource;
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'forum'?: CultureSpecificExternalResource;
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'helpcenter'?: CultureSpecificExternalResource;
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'integrations'?: CultureSpecificExternalResource;
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'site'?: CultureSpecificExternalResource;
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'socialNetworks'?: CultureSpecificExternalResource;
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'support'?: CultureSpecificExternalResource;
    /**
     * 
     * @type {CultureSpecificExternalResource}
     * @memberof CultureSpecificExternalResources
     */
    'videoguides'?: CultureSpecificExternalResource;
}
/**
 * 
 * @export
 * @interface CurrentLicenseInfo
 */
export interface CurrentLicenseInfo {
    /**
     * Indicates whether the license is a trial version
     * @type {boolean}
     * @memberof CurrentLicenseInfo
     */
    'trial'?: boolean;
    /**
     * Date when the license expires
     * @type {string}
     * @memberof CurrentLicenseInfo
     */
    'dueDate'?: string;
}
/**
 * 
 * @export
 * @interface CustomColorThemesSettingsColorItem
 */
export interface CustomColorThemesSettingsColorItem {
    /**
     * Accent color
     * @type {string}
     * @memberof CustomColorThemesSettingsColorItem
     */
    'accent'?: string | null;
    /**
     * Button color
     * @type {string}
     * @memberof CustomColorThemesSettingsColorItem
     */
    'buttons'?: string | null;
}
/**
 * 
 * @export
 * @interface CustomColorThemesSettingsDto
 */
export interface CustomColorThemesSettingsDto {
    /**
     * Themes
     * @type {Array<CustomColorThemesSettingsItem>}
     * @memberof CustomColorThemesSettingsDto
     */
    'themes'?: Array<CustomColorThemesSettingsItem> | null;
    /**
     * Selected
     * @type {number}
     * @memberof CustomColorThemesSettingsDto
     */
    'selected'?: number;
    /**
     * Limit
     * @type {number}
     * @memberof CustomColorThemesSettingsDto
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface CustomColorThemesSettingsItem
 */
export interface CustomColorThemesSettingsItem {
    /**
     * Theme ID
     * @type {number}
     * @memberof CustomColorThemesSettingsItem
     */
    'id'?: number;
    /**
     * Theme name
     * @type {string}
     * @memberof CustomColorThemesSettingsItem
     */
    'name'?: string | null;
    /**
     * 
     * @type {CustomColorThemesSettingsColorItem}
     * @memberof CustomColorThemesSettingsItem
     */
    'main'?: CustomColorThemesSettingsColorItem;
    /**
     * 
     * @type {CustomColorThemesSettingsColorItem}
     * @memberof CustomColorThemesSettingsItem
     */
    'text'?: CustomColorThemesSettingsColorItem;
}
/**
 * Portal theme settings
 * @export
 * @interface CustomColorThemesSettingsRequestsDto
 */
export interface CustomColorThemesSettingsRequestsDto {
    /**
     * 
     * @type {CustomColorThemesSettingsItem}
     * @memberof CustomColorThemesSettingsRequestsDto
     */
    'theme'?: CustomColorThemesSettingsItem;
    /**
     * Selected or not
     * @type {number}
     * @memberof CustomColorThemesSettingsRequestsDto
     */
    'selected'?: number | null;
}
/**
 * 
 * @export
 * @interface CustomColorThemesSettingsWrapper
 */
export interface CustomColorThemesSettingsWrapper {
    /**
     * 
     * @type {CustomColorThemesSettingsDto}
     * @memberof CustomColorThemesSettingsWrapper
     */
    'response'?: CustomColorThemesSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof CustomColorThemesSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CustomColorThemesSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CustomColorThemesSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomColorThemesSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * Custom navigation parameters
 * @export
 * @interface CustomNavigationItem
 */
export interface CustomNavigationItem {
    /**
     * Id
     * @type {string}
     * @memberof CustomNavigationItem
     */
    'id'?: string;
    /**
     * Label
     * @type {string}
     * @memberof CustomNavigationItem
     */
    'label'?: string | null;
    /**
     * URL
     * @type {string}
     * @memberof CustomNavigationItem
     */
    'url'?: string | null;
    /**
     * Big image
     * @type {string}
     * @memberof CustomNavigationItem
     */
    'bigImg'?: string | null;
    /**
     * Small image
     * @type {string}
     * @memberof CustomNavigationItem
     */
    'smallImg'?: string | null;
    /**
     * Show in menu or not
     * @type {boolean}
     * @memberof CustomNavigationItem
     */
    'showInMenu'?: boolean;
    /**
     * Show on home page or not
     * @type {boolean}
     * @memberof CustomNavigationItem
     */
    'showOnHomePage'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomNavigationItemArrayWrapper
 */
export interface CustomNavigationItemArrayWrapper {
    /**
     * 
     * @type {Array<CustomNavigationItem>}
     * @memberof CustomNavigationItemArrayWrapper
     */
    'response'?: Array<CustomNavigationItem>;
    /**
     * 
     * @type {number}
     * @memberof CustomNavigationItemArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CustomNavigationItemArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CustomNavigationItemArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomNavigationItemArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface CustomNavigationItemWrapper
 */
export interface CustomNavigationItemWrapper {
    /**
     * 
     * @type {CustomNavigationItem}
     * @memberof CustomNavigationItemWrapper
     */
    'response'?: CustomNavigationItem;
    /**
     * 
     * @type {number}
     * @memberof CustomNavigationItemWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof CustomNavigationItemWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof CustomNavigationItemWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomNavigationItemWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface CustomerConfigDto
 */
export interface CustomerConfigDto {
    /**
     * Address
     * @type {string}
     * @memberof CustomerConfigDto
     */
    'address'?: string | null;
    /**
     * Logo
     * @type {string}
     * @memberof CustomerConfigDto
     */
    'logo'?: string | null;
    /**
     * Dark logo
     * @type {string}
     * @memberof CustomerConfigDto
     */
    'logoDark'?: string | null;
    /**
     * Mail
     * @type {string}
     * @memberof CustomerConfigDto
     */
    'mail'?: string | null;
    /**
     * Name
     * @type {string}
     * @memberof CustomerConfigDto
     */
    'name'?: string | null;
    /**
     * Site
     * @type {string}
     * @memberof CustomerConfigDto
     */
    'www'?: string | null;
}
/**
 * 
 * @export
 * @interface CustomizationConfigDto
 */
export interface CustomizationConfigDto {
    /**
     * About
     * @type {boolean}
     * @memberof CustomizationConfigDto
     */
    'about'?: boolean;
    /**
     * 
     * @type {CustomerConfigDto}
     * @memberof CustomizationConfigDto
     */
    'customer'?: CustomerConfigDto;
    /**
     * 
     * @type {AnonymousConfigDto}
     * @memberof CustomizationConfigDto
     */
    'anonymous'?: AnonymousConfigDto;
    /**
     * 
     * @type {FeedbackConfig}
     * @memberof CustomizationConfigDto
     */
    'feedback'?: FeedbackConfig;
    /**
     * Forcesave
     * @type {boolean}
     * @memberof CustomizationConfigDto
     */
    'forcesave'?: boolean | null;
    /**
     * 
     * @type {GobackConfig}
     * @memberof CustomizationConfigDto
     */
    'goback'?: GobackConfig;
    /**
     * 
     * @type {LogoConfigDto}
     * @memberof CustomizationConfigDto
     */
    'logo'?: LogoConfigDto;
    /**
     * MentionShare
     * @type {boolean}
     * @memberof CustomizationConfigDto
     */
    'mentionShare'?: boolean;
    /**
     * Review display
     * @type {string}
     * @memberof CustomizationConfigDto
     */
    'reviewDisplay'?: string | null;
    /**
     * Submit form
     * @type {boolean}
     * @memberof CustomizationConfigDto
     */
    'submitForm'?: boolean;
}
/**
 * 
 * @export
 * @interface DarkThemeSettings
 */
export interface DarkThemeSettings {
    /**
     * 
     * @type {DarkThemeSettingsType}
     * @memberof DarkThemeSettings
     */
    'theme'?: DarkThemeSettingsType;
}


/**
 * Theme settings request parameters
 * @export
 * @interface DarkThemeSettingsRequestDto
 */
export interface DarkThemeSettingsRequestDto {
    /**
     * 
     * @type {DarkThemeSettingsType}
     * @memberof DarkThemeSettingsRequestDto
     */
    'theme'?: DarkThemeSettingsType;
}


/**
 * [0 - Base, 1 - Dark, 2 - System]
 * @export
 * @enum {number}
 */

export const DarkThemeSettingsType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type DarkThemeSettingsType = typeof DarkThemeSettingsType[keyof typeof DarkThemeSettingsType];


/**
 * 
 * @export
 * @interface DarkThemeSettingsWrapper
 */
export interface DarkThemeSettingsWrapper {
    /**
     * 
     * @type {DarkThemeSettings}
     * @memberof DarkThemeSettingsWrapper
     */
    'response'?: DarkThemeSettings;
    /**
     * 
     * @type {number}
     * @memberof DarkThemeSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof DarkThemeSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof DarkThemeSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof DarkThemeSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * [1 - One week, 2 - Two weeks, 3 - One month, 4 - Thirty days, 5 - Two months, 6 - Three months]
 * @export
 * @enum {number}
 */

export const DateToAutoCleanUp = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type DateToAutoCleanUp = typeof DateToAutoCleanUp[keyof typeof DateToAutoCleanUp];


/**
 * 
 * @export
 * @interface DbTenant
 */
export interface DbTenant {
    /**
     * Id
     * @type {number}
     * @memberof DbTenant
     */
    'id'?: number;
    /**
     * Name
     * @type {string}
     * @memberof DbTenant
     */
    'name'?: string | null;
    /**
     * Alias
     * @type {string}
     * @memberof DbTenant
     */
    'alias'?: string | null;
    /**
     * Mapped domain
     * @type {string}
     * @memberof DbTenant
     */
    'mappedDomain'?: string | null;
    /**
     * Version
     * @type {number}
     * @memberof DbTenant
     */
    'version'?: number;
    /**
     * Version_changed
     * @type {string}
     * @memberof DbTenant
     */
    'version_Changed'?: string | null;
    /**
     * Version changed
     * @type {string}
     * @memberof DbTenant
     */
    'versionChanged'?: string;
    /**
     * Language
     * @type {string}
     * @memberof DbTenant
     */
    'language'?: string | null;
    /**
     * Time zone
     * @type {string}
     * @memberof DbTenant
     */
    'timeZone'?: string | null;
    /**
     * Trusted domains raw
     * @type {string}
     * @memberof DbTenant
     */
    'trustedDomainsRaw'?: string | null;
    /**
     * 
     * @type {TenantTrustedDomainsType}
     * @memberof DbTenant
     */
    'trustedDomainsEnabled'?: TenantTrustedDomainsType;
    /**
     * 
     * @type {TenantStatus}
     * @memberof DbTenant
     */
    'status'?: TenantStatus;
    /**
     * Status changed
     * @type {string}
     * @memberof DbTenant
     */
    'statusChanged'?: string | null;
    /**
     * Status changed hack
     * @type {string}
     * @memberof DbTenant
     */
    'statusChangedHack'?: string;
    /**
     * Creation date time
     * @type {string}
     * @memberof DbTenant
     */
    'creationDateTime'?: string;
    /**
     * Owner id
     * @type {string}
     * @memberof DbTenant
     */
    'ownerId'?: string | null;
    /**
     * Payment id
     * @type {string}
     * @memberof DbTenant
     */
    'paymentId'?: string | null;
    /**
     * 
     * @type {TenantIndustry}
     * @memberof DbTenant
     */
    'industry'?: TenantIndustry;
    /**
     * Last modified
     * @type {string}
     * @memberof DbTenant
     */
    'lastModified'?: string;
    /**
     * Calls
     * @type {boolean}
     * @memberof DbTenant
     */
    'calls'?: boolean;
    /**
     * 
     * @type {DbTenantPartner}
     * @memberof DbTenant
     */
    'partner'?: DbTenantPartner;
}


/**
 * 
 * @export
 * @interface DbTenantPartner
 */
export interface DbTenantPartner {
    /**
     * Tenant id
     * @type {number}
     * @memberof DbTenantPartner
     */
    'tenantId'?: number;
    /**
     * Partner id
     * @type {string}
     * @memberof DbTenantPartner
     */
    'partnerId'?: string | null;
    /**
     * Affiliate id
     * @type {string}
     * @memberof DbTenantPartner
     */
    'affiliateId'?: string | null;
    /**
     * Campaign
     * @type {string}
     * @memberof DbTenantPartner
     */
    'campaign'?: string | null;
}
/**
 * 
 * @export
 * @interface DeepLinkConfigurationRequestsDto
 */
export interface DeepLinkConfigurationRequestsDto {
    /**
     * 
     * @type {TenantDeepLinkSettings}
     * @memberof DeepLinkConfigurationRequestsDto
     */
    'deepLinkSettings'?: TenantDeepLinkSettings;
}
/**
 * 
 * @export
 * @interface DeepLinkDto
 */
export interface DeepLinkDto {
    /**
     * Android package name
     * @type {string}
     * @memberof DeepLinkDto
     */
    'androidPackageName'?: string | null;
    /**
     * Url
     * @type {string}
     * @memberof DeepLinkDto
     */
    'url'?: string | null;
    /**
     * Ios package id
     * @type {string}
     * @memberof DeepLinkDto
     */
    'iosPackageId'?: string | null;
}
/**
 * 
 * @export
 * @enum {number}
 */

export const DeepLinkHandlingMode = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type DeepLinkHandlingMode = typeof DeepLinkHandlingMode[keyof typeof DeepLinkHandlingMode];


/**
 * Parameters for deleting a file
 * @export
 * @interface Delete
 */
export interface Delete {
    /**
     * Specifies whether to delete a file after the editing session is finished or not
     * @type {boolean}
     * @memberof Delete
     */
    'deleteAfter'?: boolean;
    /**
     * Specifies whether to move a file to the \\\"Trash\\\" folder or delete it immediately
     * @type {boolean}
     * @memberof Delete
     */
    'immediately'?: boolean;
}
/**
 * Request parameters for deleting files
 * @export
 * @interface DeleteBatchRequestDto
 */
export interface DeleteBatchRequestDto {
    /**
     * List of folder IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof DeleteBatchRequestDto
     */
    'folderIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * List of file IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof DeleteBatchRequestDto
     */
    'fileIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * Specifies whether to delete a file after the editing session is finished or not
     * @type {boolean}
     * @memberof DeleteBatchRequestDto
     */
    'deleteAfter'?: boolean;
    /**
     * Specifies whether to move a file to the \\\"Trash\\\" folder or delete it immediately
     * @type {boolean}
     * @memberof DeleteBatchRequestDto
     */
    'immediately'?: boolean;
}
/**
 * Parameters for deleting a folder
 * @export
 * @interface DeleteFolder
 */
export interface DeleteFolder {
    /**
     * Specifies whether to delete a folder after the editing session is finished or not
     * @type {boolean}
     * @memberof DeleteFolder
     */
    'deleteAfter'?: boolean;
    /**
     * Specifies whether to move a folder to the \\\"Trash\\\" folder or delete it immediately
     * @type {boolean}
     * @memberof DeleteFolder
     */
    'immediately'?: boolean;
}
/**
 * Parameters for deleting a room
 * @export
 * @interface DeleteRoomRequest
 */
export interface DeleteRoomRequest {
    /**
     * Specifies whether to delete a room after the editing session is finished or not
     * @type {boolean}
     * @memberof DeleteRoomRequest
     */
    'deleteAfter'?: boolean;
}
/**
 * Request parameters for deleting file\'s version
 * @export
 * @interface DeleteVersionBatchRequestDto
 */
export interface DeleteVersionBatchRequestDto {
    /**
     * Specifies whether to delete a file after the editing session is finished or not
     * @type {boolean}
     * @memberof DeleteVersionBatchRequestDto
     */
    'deleteAfter'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeleteVersionBatchRequestDto
     */
    'fileId'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DeleteVersionBatchRequestDto
     */
    'versions'?: Array<number> | null;
}
/**
 * Settings request parameters
 * @export
 * @interface DisplayRequestDto
 */
export interface DisplayRequestDto {
    /**
     * Specifies whether to set the specified settings or not
     * @type {boolean}
     * @memberof DisplayRequestDto
     */
    'set'?: boolean;
}
/**
 * [0 - Created, 1 - Running, 2 - Completed, 3 - Canceled, 4 - Failted]
 * @export
 * @enum {number}
 */

export const DistributedTaskStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type DistributedTaskStatus = typeof DistributedTaskStatus[keyof typeof DistributedTaskStatus];


/**
 * DNS settings request parameters
 * @export
 * @interface DnsSettingsRequestsDto
 */
export interface DnsSettingsRequestsDto {
    /**
     * DNS
     * @type {string}
     * @memberof DnsSettingsRequestsDto
     */
    'dnsName'?: string | null;
    /**
     * Enabled or not
     * @type {boolean}
     * @memberof DnsSettingsRequestsDto
     */
    'enable'?: boolean;
}
/**
 * 
 * @export
 * @interface DocServiceUrlDto
 */
export interface DocServiceUrlDto {
    /**
     * Version
     * @type {string}
     * @memberof DocServiceUrlDto
     */
    'version': string | null;
    /**
     * Doc service url api
     * @type {string}
     * @memberof DocServiceUrlDto
     */
    'docServiceUrlApi': string | null;
    /**
     * Doc service url
     * @type {string}
     * @memberof DocServiceUrlDto
     */
    'docServiceUrl': string | null;
    /**
     * Doc service url internal
     * @type {string}
     * @memberof DocServiceUrlDto
     */
    'docServiceUrlInternal': string | null;
    /**
     * Doc service portal url
     * @type {string}
     * @memberof DocServiceUrlDto
     */
    'docServicePortalUrl': string | null;
    /**
     * Doc service signature header
     * @type {string}
     * @memberof DocServiceUrlDto
     */
    'docServiceSignatureHeader'?: string | null;
    /**
     * Enable SSL verification
     * @type {boolean}
     * @memberof DocServiceUrlDto
     */
    'docServiceSslVerification'?: boolean;
    /**
     * Is default
     * @type {boolean}
     * @memberof DocServiceUrlDto
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface DocServiceUrlWrapper
 */
export interface DocServiceUrlWrapper {
    /**
     * 
     * @type {DocServiceUrlDto}
     * @memberof DocServiceUrlWrapper
     */
    'response'?: DocServiceUrlDto;
    /**
     * 
     * @type {number}
     * @memberof DocServiceUrlWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof DocServiceUrlWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof DocServiceUrlWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocServiceUrlWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface DocumentBuilderTaskDto
 */
export interface DocumentBuilderTaskDto {
    /**
     * Id
     * @type {string}
     * @memberof DocumentBuilderTaskDto
     */
    'id'?: string | null;
    /**
     * Error
     * @type {string}
     * @memberof DocumentBuilderTaskDto
     */
    'error'?: string | null;
    /**
     * Percentage
     * @type {number}
     * @memberof DocumentBuilderTaskDto
     */
    'percentage'?: number;
    /**
     * Is completed
     * @type {boolean}
     * @memberof DocumentBuilderTaskDto
     */
    'isCompleted'?: boolean;
    /**
     * 
     * @type {DistributedTaskStatus}
     * @memberof DocumentBuilderTaskDto
     */
    'status'?: DistributedTaskStatus;
    /**
     * Result file id
     * @type {any}
     * @memberof DocumentBuilderTaskDto
     */
    'resultFileId'?: any | null;
    /**
     * Result file name
     * @type {string}
     * @memberof DocumentBuilderTaskDto
     */
    'resultFileName'?: string | null;
    /**
     * Result file url
     * @type {string}
     * @memberof DocumentBuilderTaskDto
     */
    'resultFileUrl'?: string | null;
}


/**
 * 
 * @export
 * @interface DocumentBuilderTaskWrapper
 */
export interface DocumentBuilderTaskWrapper {
    /**
     * 
     * @type {DocumentBuilderTaskDto}
     * @memberof DocumentBuilderTaskWrapper
     */
    'response'?: DocumentBuilderTaskDto;
    /**
     * 
     * @type {number}
     * @memberof DocumentBuilderTaskWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof DocumentBuilderTaskWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof DocumentBuilderTaskWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentBuilderTaskWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface DocumentConfigDto
 */
export interface DocumentConfigDto {
    /**
     * File type
     * @type {string}
     * @memberof DocumentConfigDto
     */
    'fileType'?: string | null;
    /**
     * 
     * @type {InfoConfigDto}
     * @memberof DocumentConfigDto
     */
    'info'?: InfoConfigDto;
    /**
     * Is linked for me
     * @type {boolean}
     * @memberof DocumentConfigDto
     */
    'isLinkedForMe'?: boolean;
    /**
     * Key
     * @type {string}
     * @memberof DocumentConfigDto
     */
    'key'?: string | null;
    /**
     * 
     * @type {PermissionsConfig}
     * @memberof DocumentConfigDto
     */
    'permissions'?: PermissionsConfig;
    /**
     * Shared link param
     * @type {string}
     * @memberof DocumentConfigDto
     */
    'sharedLinkParam'?: string | null;
    /**
     * Shared link key
     * @type {string}
     * @memberof DocumentConfigDto
     */
    'sharedLinkKey'?: string | null;
    /**
     * 
     * @type {FileReferenceData}
     * @memberof DocumentConfigDto
     */
    'referenceData'?: FileReferenceData;
    /**
     * Title
     * @type {string}
     * @memberof DocumentConfigDto
     */
    'title'?: string | null;
    /**
     * Url
     * @type {string}
     * @memberof DocumentConfigDto
     */
    'url'?: string | null;
    /**
     * 
     * @type {Options}
     * @memberof DocumentConfigDto
     */
    'options'?: Options;
}
/**
 * 
 * @export
 * @interface DoubleWrapper
 */
export interface DoubleWrapper {
    /**
     * 
     * @type {number}
     * @memberof DoubleWrapper
     */
    'response'?: number;
    /**
     * 
     * @type {number}
     * @memberof DoubleWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof DoubleWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof DoubleWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof DoubleWrapper
     */
    'statusCode'?: number;
}
/**
 * Request parameters for downloading files
 * @export
 * @interface DownloadRequestDto
 */
export interface DownloadRequestDto {
    /**
     * List of folder IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof DownloadRequestDto
     */
    'folderIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * List of file IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof DownloadRequestDto
     */
    'fileIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * List of file IDs which will be converted
     * @type {Array<DownloadRequestItemDto>}
     * @memberof DownloadRequestDto
     */
    'fileConvertIds'?: Array<DownloadRequestItemDto> | null;
}
/**
 * Represents an item in the download request with conversion parameters and security settings
 * @export
 * @interface DownloadRequestItemDto
 */
export interface DownloadRequestItemDto {
    /**
     * 
     * @type {DownloadRequestItemDtoKey}
     * @memberof DownloadRequestItemDto
     */
    'key'?: DownloadRequestItemDtoKey;
    /**
     * The target format or conversion type for the file download
     * @type {string}
     * @memberof DownloadRequestItemDto
     */
    'value'?: string | null;
    /**
     * Optional password for accessing protected files
     * @type {string}
     * @memberof DownloadRequestItemDto
     */
    'password'?: string | null;
}
/**
 * @type DownloadRequestItemDtoKey
 * The unique identifier or reference key for the file to be downloaded
 * @export
 */
export type DownloadRequestItemDtoKey = number | string;

/**
 * 
 * @export
 * @interface DraftLocationInteger
 */
export interface DraftLocationInteger {
    /**
     * InProcess folder ID
     * @type {number}
     * @memberof DraftLocationInteger
     */
    'folderId'?: number;
    /**
     * InProcess folder title
     * @type {string}
     * @memberof DraftLocationInteger
     */
    'folderTitle'?: string | null;
    /**
     * Draft ID
     * @type {number}
     * @memberof DraftLocationInteger
     */
    'fileId'?: number;
    /**
     * Draft title
     * @type {string}
     * @memberof DraftLocationInteger
     */
    'fileTitle'?: string | null;
}
/**
 * 
 * @export
 * @interface DuplicateRequestDto
 */
export interface DuplicateRequestDto {
    /**
     * List of folder IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof DuplicateRequestDto
     */
    'folderIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * List of file IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof DuplicateRequestDto
     */
    'fileIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
}
/**
 * 
 * @export
 * @interface EditHistoryArrayWrapper
 */
export interface EditHistoryArrayWrapper {
    /**
     * 
     * @type {Array<EditHistoryDto>}
     * @memberof EditHistoryArrayWrapper
     */
    'response'?: Array<EditHistoryDto>;
    /**
     * 
     * @type {number}
     * @memberof EditHistoryArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof EditHistoryArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof EditHistoryArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditHistoryArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface EditHistoryAuthor
 */
export interface EditHistoryAuthor {
    /**
     * Id
     * @type {string}
     * @memberof EditHistoryAuthor
     */
    'id'?: string | null;
    /**
     * Name
     * @type {string}
     * @memberof EditHistoryAuthor
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface EditHistoryChangesWrapper
 */
export interface EditHistoryChangesWrapper {
    /**
     * 
     * @type {EditHistoryAuthor}
     * @memberof EditHistoryChangesWrapper
     */
    'user'?: EditHistoryAuthor;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof EditHistoryChangesWrapper
     */
    'created'?: ApiDateTime;
    /**
     * 
     * @type {string}
     * @memberof EditHistoryChangesWrapper
     */
    'documentSha256'?: string | null;
}
/**
 * 
 * @export
 * @interface EditHistoryDataDto
 */
export interface EditHistoryDataDto {
    /**
     * URL to the file changes
     * @type {string}
     * @memberof EditHistoryDataDto
     */
    'changesUrl'?: string | null;
    /**
     * Key
     * @type {string}
     * @memberof EditHistoryDataDto
     */
    'key'?: string | null;
    /**
     * 
     * @type {EditHistoryUrl}
     * @memberof EditHistoryDataDto
     */
    'previous'?: EditHistoryUrl;
    /**
     * Token
     * @type {string}
     * @memberof EditHistoryDataDto
     */
    'token'?: string | null;
    /**
     * File URL
     * @type {string}
     * @memberof EditHistoryDataDto
     */
    'url'?: string | null;
    /**
     * File version
     * @type {number}
     * @memberof EditHistoryDataDto
     */
    'version'?: number;
    /**
     * File type
     * @type {string}
     * @memberof EditHistoryDataDto
     */
    'fileType'?: string | null;
}
/**
 * 
 * @export
 * @interface EditHistoryDataWrapper
 */
export interface EditHistoryDataWrapper {
    /**
     * 
     * @type {EditHistoryDataDto}
     * @memberof EditHistoryDataWrapper
     */
    'response'?: EditHistoryDataDto;
    /**
     * 
     * @type {number}
     * @memberof EditHistoryDataWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof EditHistoryDataWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof EditHistoryDataWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditHistoryDataWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface EditHistoryDto
 */
export interface EditHistoryDto {
    /**
     * File ID
     * @type {number}
     * @memberof EditHistoryDto
     */
    'id'?: number;
    /**
     * Key
     * @type {string}
     * @memberof EditHistoryDto
     */
    'key'?: string | null;
    /**
     * File version
     * @type {number}
     * @memberof EditHistoryDto
     */
    'version'?: number;
    /**
     * Version group
     * @type {number}
     * @memberof EditHistoryDto
     */
    'versionGroup'?: number;
    /**
     * 
     * @type {EditHistoryAuthor}
     * @memberof EditHistoryDto
     */
    'user'?: EditHistoryAuthor;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof EditHistoryDto
     */
    'created'?: ApiDateTime;
    /**
     * History changes in the string format
     * @type {string}
     * @memberof EditHistoryDto
     */
    'changesHistory'?: string | null;
    /**
     * List of history changes
     * @type {Array<EditHistoryChangesWrapper>}
     * @memberof EditHistoryDto
     */
    'changes'?: Array<EditHistoryChangesWrapper> | null;
    /**
     * Server version
     * @type {string}
     * @memberof EditHistoryDto
     */
    'serverVersion'?: string | null;
}
/**
 * 
 * @export
 * @interface EditHistoryUrl
 */
export interface EditHistoryUrl {
    /**
     * Key
     * @type {string}
     * @memberof EditHistoryUrl
     */
    'key'?: string | null;
    /**
     * Url
     * @type {string}
     * @memberof EditHistoryUrl
     */
    'url'?: string | null;
    /**
     * File type
     * @type {string}
     * @memberof EditHistoryUrl
     */
    'fileType'?: string | null;
}
/**
 * 
 * @export
 * @interface EditorConfigurationDto
 */
export interface EditorConfigurationDto {
    /**
     * Callback url
     * @type {string}
     * @memberof EditorConfigurationDto
     */
    'callbackUrl'?: string | null;
    /**
     * 
     * @type {CoEditingConfig}
     * @memberof EditorConfigurationDto
     */
    'coEditing'?: CoEditingConfig;
    /**
     * Create url
     * @type {string}
     * @memberof EditorConfigurationDto
     */
    'createUrl'?: string | null;
    /**
     * 
     * @type {CustomizationConfigDto}
     * @memberof EditorConfigurationDto
     */
    'customization'?: CustomizationConfigDto;
    /**
     * 
     * @type {EmbeddedConfig}
     * @memberof EditorConfigurationDto
     */
    'embedded'?: EmbeddedConfig;
    /**
     * 
     * @type {EncryptionKeysConfig}
     * @memberof EditorConfigurationDto
     */
    'encryptionKeys'?: EncryptionKeysConfig;
    /**
     * Lang
     * @type {string}
     * @memberof EditorConfigurationDto
     */
    'lang'?: string | null;
    /**
     * Mode
     * @type {string}
     * @memberof EditorConfigurationDto
     */
    'mode'?: string | null;
    /**
     * Mode write
     * @type {boolean}
     * @memberof EditorConfigurationDto
     */
    'modeWrite'?: boolean;
    /**
     * 
     * @type {PluginsConfig}
     * @memberof EditorConfigurationDto
     */
    'plugins'?: PluginsConfig;
    /**
     * Recent
     * @type {Array<RecentConfig>}
     * @memberof EditorConfigurationDto
     */
    'recent'?: Array<RecentConfig> | null;
    /**
     * Templates
     * @type {Array<TemplatesConfig>}
     * @memberof EditorConfigurationDto
     */
    'templates'?: Array<TemplatesConfig> | null;
    /**
     * 
     * @type {UserConfig}
     * @memberof EditorConfigurationDto
     */
    'user'?: UserConfig;
}
/**
 * [0 - Desktop, 1 - Mobile, 2 - Embedded]
 * @export
 * @enum {number}
 */

export const EditorType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type EditorType = typeof EditorType[keyof typeof EditorType];


/**
 * Email activation settings
 * @export
 * @interface EmailActivationSettings
 */
export interface EmailActivationSettings {
    /**
     * Shown or hidden
     * @type {boolean}
     * @memberof EmailActivationSettings
     */
    'show'?: boolean;
}
/**
 * 
 * @export
 * @interface EmailActivationSettingsWrapper
 */
export interface EmailActivationSettingsWrapper {
    /**
     * 
     * @type {EmailActivationSettings}
     * @memberof EmailActivationSettingsWrapper
     */
    'response'?: EmailActivationSettings;
    /**
     * 
     * @type {number}
     * @memberof EmailActivationSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof EmailActivationSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof EmailActivationSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailActivationSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * Member request parameters
 * @export
 * @interface EmailMemberRequestDto
 */
export interface EmailMemberRequestDto {
    /**
     * Email
     * @type {string}
     * @memberof EmailMemberRequestDto
     */
    'email'?: string | null;
}
/**
 * Confirmation email parameters
 * @export
 * @interface EmailValidationKeyModel
 */
export interface EmailValidationKeyModel {
    /**
     * Key
     * @type {string}
     * @memberof EmailValidationKeyModel
     */
    'key'?: string | null;
    /**
     * 
     * @type {EmployeeType}
     * @memberof EmailValidationKeyModel
     */
    'emplType'?: EmployeeType;
    /**
     * Email
     * @type {string}
     * @memberof EmailValidationKeyModel
     */
    'email'?: string | null;
    /**
     * User ID
     * @type {string}
     * @memberof EmailValidationKeyModel
     */
    'uiD'?: string | null;
    /**
     * 
     * @type {ConfirmType}
     * @memberof EmailValidationKeyModel
     */
    'type'?: ConfirmType;
    /**
     * Access an account for the first time or not
     * @type {string}
     * @memberof EmailValidationKeyModel
     */
    'first'?: string | null;
    /**
     * Room ID
     * @type {string}
     * @memberof EmailValidationKeyModel
     */
    'roomId'?: string | null;
}


/**
 * 
 * @export
 * @interface EmbeddedConfig
 */
export interface EmbeddedConfig {
    /**
     * Embed url
     * @type {string}
     * @memberof EmbeddedConfig
     */
    'embedUrl'?: string | null;
    /**
     * Save url
     * @type {string}
     * @memberof EmbeddedConfig
     */
    'saveUrl'?: string | null;
    /**
     * Share link param
     * @type {string}
     * @memberof EmbeddedConfig
     */
    'shareLinkParam'?: string | null;
    /**
     * Share url
     * @type {string}
     * @memberof EmbeddedConfig
     */
    'shareUrl'?: string | null;
    /**
     * Toolbar docked
     * @type {string}
     * @memberof EmbeddedConfig
     */
    'toolbarDocked'?: string | null;
}
/**
 * [0 - Not activated, 1 - Activated, 2 - Pending, 4 - Auto generated]
 * @export
 * @enum {number}
 */

export const EmployeeActivationStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4
} as const;

export type EmployeeActivationStatus = typeof EmployeeActivationStatus[keyof typeof EmployeeActivationStatus];


/**
 * 
 * @export
 * @interface EmployeeArrayWrapper
 */
export interface EmployeeArrayWrapper {
    /**
     * 
     * @type {Array<EmployeeDto>}
     * @memberof EmployeeArrayWrapper
     */
    'response'?: Array<EmployeeDto>;
    /**
     * 
     * @type {number}
     * @memberof EmployeeArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof EmployeeArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof EmployeeArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface EmployeeDto
 */
export interface EmployeeDto {
    /**
     * ID
     * @type {string}
     * @memberof EmployeeDto
     */
    'id'?: string;
    /**
     * Display name
     * @type {string}
     * @memberof EmployeeDto
     */
    'displayName'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof EmployeeDto
     */
    'title'?: string | null;
    /**
     * Avatar
     * @type {string}
     * @memberof EmployeeDto
     */
    'avatar'?: string | null;
    /**
     * Original size avatar
     * @type {string}
     * @memberof EmployeeDto
     */
    'avatarOriginal'?: string | null;
    /**
     * Maximum size avatar
     * @type {string}
     * @memberof EmployeeDto
     */
    'avatarMax'?: string | null;
    /**
     * Medium size avatar
     * @type {string}
     * @memberof EmployeeDto
     */
    'avatarMedium'?: string | null;
    /**
     * Small avatar
     * @type {string}
     * @memberof EmployeeDto
     */
    'avatarSmall'?: string | null;
    /**
     * Profile URL
     * @type {string}
     * @memberof EmployeeDto
     */
    'profileUrl'?: string | null;
    /**
     * Specifies if the user has an avatar or not
     * @type {boolean}
     * @memberof EmployeeDto
     */
    'hasAvatar'?: boolean;
    /**
     * Specifies if the user is an anonim or not
     * @type {boolean}
     * @memberof EmployeeDto
     */
    'isAnonim'?: boolean;
}
/**
 * 
 * @export
 * @interface EmployeeFullArrayWrapper
 */
export interface EmployeeFullArrayWrapper {
    /**
     * 
     * @type {Array<EmployeeFullDto>}
     * @memberof EmployeeFullArrayWrapper
     */
    'response'?: Array<EmployeeFullDto>;
    /**
     * 
     * @type {number}
     * @memberof EmployeeFullArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof EmployeeFullArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof EmployeeFullArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeFullArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface EmployeeFullDto
 */
export interface EmployeeFullDto {
    /**
     * ID
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'id'?: string;
    /**
     * Display name
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'displayName'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'title'?: string | null;
    /**
     * Avatar
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'avatar'?: string | null;
    /**
     * Original size avatar
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'avatarOriginal'?: string | null;
    /**
     * Maximum size avatar
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'avatarMax'?: string | null;
    /**
     * Medium size avatar
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'avatarMedium'?: string | null;
    /**
     * Small avatar
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'avatarSmall'?: string | null;
    /**
     * Profile URL
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'profileUrl'?: string | null;
    /**
     * Specifies if the user has an avatar or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'hasAvatar'?: boolean;
    /**
     * Specifies if the user is an anonim or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isAnonim'?: boolean;
    /**
     * First name
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'firstName'?: string | null;
    /**
     * Last name
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'lastName'?: string | null;
    /**
     * Username
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'userName'?: string | null;
    /**
     * Email
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'email'?: string | null;
    /**
     * List of contacts
     * @type {Array<Contact>}
     * @memberof EmployeeFullDto
     */
    'contacts'?: Array<Contact> | null;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof EmployeeFullDto
     */
    'birthday'?: ApiDateTime;
    /**
     * Sex
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'sex'?: string | null;
    /**
     * 
     * @type {EmployeeStatus}
     * @memberof EmployeeFullDto
     */
    'status'?: EmployeeStatus;
    /**
     * 
     * @type {EmployeeActivationStatus}
     * @memberof EmployeeFullDto
     */
    'activationStatus'?: EmployeeActivationStatus;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof EmployeeFullDto
     */
    'terminated'?: ApiDateTime;
    /**
     * Department
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'department'?: string | null;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof EmployeeFullDto
     */
    'workFrom'?: ApiDateTime;
    /**
     * List of groups
     * @type {Array<GroupSummaryDto>}
     * @memberof EmployeeFullDto
     */
    'groups'?: Array<GroupSummaryDto> | null;
    /**
     * Location
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'location'?: string | null;
    /**
     * Notes
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'notes'?: string | null;
    /**
     * Specifies if the user is an administrator or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isAdmin'?: boolean;
    /**
     * Specifies if the user is a room administrator or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isRoomAdmin'?: boolean;
    /**
     * Specifies if the LDAP settings are enabled for the user or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isLDAP'?: boolean;
    /**
     * List of administrator modules
     * @type {Array<string>}
     * @memberof EmployeeFullDto
     */
    'listAdminModules'?: Array<string> | null;
    /**
     * Specifies if the user is a portal owner or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isOwner'?: boolean;
    /**
     * Specifies if the user is a portal visitor or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isVisitor'?: boolean;
    /**
     * Specifies if the user is a portal collaborator or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isCollaborator'?: boolean;
    /**
     * Language
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'cultureName'?: string | null;
    /**
     * Mobile phone number
     * @type {string}
     * @memberof EmployeeFullDto
     */
    'mobilePhone'?: string | null;
    /**
     * 
     * @type {MobilePhoneActivationStatus}
     * @memberof EmployeeFullDto
     */
    'mobilePhoneActivationStatus'?: MobilePhoneActivationStatus;
    /**
     * Specifies if the SSO settings are enabled for the user or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isSSO'?: boolean;
    /**
     * 
     * @type {DarkThemeSettingsType}
     * @memberof EmployeeFullDto
     */
    'theme'?: DarkThemeSettingsType;
    /**
     * Quota limit
     * @type {number}
     * @memberof EmployeeFullDto
     */
    'quotaLimit'?: number | null;
    /**
     * Portal used space
     * @type {number}
     * @memberof EmployeeFullDto
     */
    'usedSpace'?: number | null;
    /**
     * Shared
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'shared'?: boolean | null;
    /**
     * Specifies if the user has a custom quota or not
     * @type {boolean}
     * @memberof EmployeeFullDto
     */
    'isCustomQuota'?: boolean | null;
    /**
     * Current login event ID
     * @type {number}
     * @memberof EmployeeFullDto
     */
    'loginEventId'?: number | null;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof EmployeeFullDto
     */
    'createdBy'?: EmployeeDto;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof EmployeeFullDto
     */
    'registrationDate'?: ApiDateTime;
}


/**
 * 
 * @export
 * @interface EmployeeFullWrapper
 */
export interface EmployeeFullWrapper {
    /**
     * 
     * @type {EmployeeFullDto}
     * @memberof EmployeeFullWrapper
     */
    'response'?: EmployeeFullDto;
    /**
     * 
     * @type {number}
     * @memberof EmployeeFullWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof EmployeeFullWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof EmployeeFullWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeFullWrapper
     */
    'statusCode'?: number;
}
/**
 * [1 - Active, 2 - Terminated, 4 - Pending, 5 - Default, 7 - All]
 * @export
 * @enum {number}
 */

export const EmployeeStatus = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type EmployeeStatus = typeof EmployeeStatus[keyof typeof EmployeeStatus];


/**
 * [0 - All, 1 - Room admin, 2 - Guest, 3 - DocSpace admin, 4 - User]
 * @export
 * @enum {number}
 */

export const EmployeeType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type EmployeeType = typeof EmployeeType[keyof typeof EmployeeType];


/**
 * 
 * @export
 * @interface EncryptionKeysConfig
 */
export interface EncryptionKeysConfig {
    /**
     * Crypto engine id
     * @type {string}
     * @memberof EncryptionKeysConfig
     */
    'cryptoEngineId'?: string | null;
    /**
     * Private key enc
     * @type {string}
     * @memberof EncryptionKeysConfig
     */
    'privateKeyEnc'?: string | null;
    /**
     * Public key
     * @type {string}
     * @memberof EncryptionKeysConfig
     */
    'publicKey'?: string | null;
}
/**
 * [0 - None, 1 - File, 2 - Folder, 23 - User, 24 - Group, 25 - Room, 26 - Tag]
 * @export
 * @enum {number}
 */

export const EntryType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_23: 23,
    NUMBER_24: 24,
    NUMBER_25: 25,
    NUMBER_26: 26
} as const;

export type EntryType = typeof EntryType[keyof typeof EntryType];


/**
 * 
 * @export
 * @interface FeedbackConfig
 */
export interface FeedbackConfig {
    /**
     * Url
     * @type {string}
     * @memberof FeedbackConfig
     */
    'url'?: string | null;
    /**
     * Visible
     * @type {boolean}
     * @memberof FeedbackConfig
     */
    'visible'?: boolean;
}
/**
 * [0 - Skip, 1 - Overwrite, 2 - Duplicate]
 * @export
 * @enum {number}
 */

export const FileConflictResolveType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type FileConflictResolveType = typeof FileConflictResolveType[keyof typeof FileConflictResolveType];


/**
 * 
 * @export
 * @interface FileDtoInteger
 */
export interface FileDtoInteger {
    /**
     * Title
     * @type {string}
     * @memberof FileDtoInteger
     */
    'title'?: string | null;
    /**
     * 
     * @type {FileShare}
     * @memberof FileDtoInteger
     */
    'access'?: FileShare;
    /**
     * Specifies if the file is shared or not
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'shared'?: boolean;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileDtoInteger
     */
    'created'?: ApiDateTime;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof FileDtoInteger
     */
    'createdBy'?: EmployeeDto;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileDtoInteger
     */
    'updated'?: ApiDateTime;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileDtoInteger
     */
    'autoDelete'?: ApiDateTime;
    /**
     * 
     * @type {FolderType}
     * @memberof FileDtoInteger
     */
    'rootFolderType'?: FolderType;
    /**
     * 
     * @type {FolderType}
     * @memberof FileDtoInteger
     */
    'parentRoomType'?: FolderType;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof FileDtoInteger
     */
    'updatedBy'?: EmployeeDto;
    /**
     * Provider is specified or not
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'providerItem'?: boolean | null;
    /**
     * Provider key
     * @type {string}
     * @memberof FileDtoInteger
     */
    'providerKey'?: string | null;
    /**
     * Provider ID
     * @type {number}
     * @memberof FileDtoInteger
     */
    'providerId'?: number | null;
    /**
     * Order
     * @type {string}
     * @memberof FileDtoInteger
     */
    'order'?: string | null;
    /**
     * Id
     * @type {number}
     * @memberof FileDtoInteger
     */
    'id'?: number;
    /**
     * Root folder id
     * @type {number}
     * @memberof FileDtoInteger
     */
    'rootFolderId'?: number;
    /**
     * Origin id
     * @type {number}
     * @memberof FileDtoInteger
     */
    'originId'?: number;
    /**
     * Origin room id
     * @type {number}
     * @memberof FileDtoInteger
     */
    'originRoomId'?: number;
    /**
     * Origin title
     * @type {string}
     * @memberof FileDtoInteger
     */
    'originTitle'?: string | null;
    /**
     * Origin room title
     * @type {string}
     * @memberof FileDtoInteger
     */
    'originRoomTitle'?: string | null;
    /**
     * Can share
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'canShare'?: boolean;
    /**
     * 
     * @type {FileDtoIntegerSecurity}
     * @memberof FileDtoInteger
     */
    'security'?: FileDtoIntegerSecurity | null;
    /**
     * 
     * @type {string}
     * @memberof FileDtoInteger
     */
    'requestToken'?: string | null;
    /**
     * Folder ID
     * @type {number}
     * @memberof FileDtoInteger
     */
    'folderId'?: number;
    /**
     * Version
     * @type {number}
     * @memberof FileDtoInteger
     */
    'version'?: number;
    /**
     * Version group
     * @type {number}
     * @memberof FileDtoInteger
     */
    'versionGroup'?: number;
    /**
     * Content length
     * @type {string}
     * @memberof FileDtoInteger
     */
    'contentLength'?: string | null;
    /**
     * Pure content length
     * @type {number}
     * @memberof FileDtoInteger
     */
    'pureContentLength'?: number | null;
    /**
     * 
     * @type {FileStatus}
     * @memberof FileDtoInteger
     */
    'fileStatus'?: FileStatus;
    /**
     * Muted or not
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'mute'?: boolean;
    /**
     * URL to view a file
     * @type {string}
     * @memberof FileDtoInteger
     */
    'viewUrl'?: string | null;
    /**
     * Web URL
     * @type {string}
     * @memberof FileDtoInteger
     */
    'webUrl'?: string | null;
    /**
     * 
     * @type {FileType}
     * @memberof FileDtoInteger
     */
    'fileType'?: FileType;
    /**
     * File extension
     * @type {string}
     * @memberof FileDtoInteger
     */
    'fileExst'?: string | null;
    /**
     * Comment
     * @type {string}
     * @memberof FileDtoInteger
     */
    'comment'?: string | null;
    /**
     * Encrypted or not
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'encrypted'?: boolean | null;
    /**
     * Thumbnail URL
     * @type {string}
     * @memberof FileDtoInteger
     */
    'thumbnailUrl'?: string | null;
    /**
     * 
     * @type {Thumbnail}
     * @memberof FileDtoInteger
     */
    'thumbnailStatus'?: Thumbnail;
    /**
     * Locked or not
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'locked'?: boolean | null;
    /**
     * User ID who locked a file
     * @type {string}
     * @memberof FileDtoInteger
     */
    'lockedBy'?: string | null;
    /**
     * Is there a draft or not
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'hasDraft'?: boolean | null;
    /**
     * Is there a form or not
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'isForm'?: boolean | null;
    /**
     * Specifies if the filling has started or not
     * @type {boolean}
     * @memberof FileDtoInteger
     */
    'startFilling'?: boolean | null;
    /**
     * InProcess folder ID
     * @type {number}
     * @memberof FileDtoInteger
     */
    'inProcessFolderId'?: number | null;
    /**
     * InProcess folder title
     * @type {string}
     * @memberof FileDtoInteger
     */
    'inProcessFolderTitle'?: string | null;
    /**
     * 
     * @type {DraftLocationInteger}
     * @memberof FileDtoInteger
     */
    'draftLocation'?: DraftLocationInteger;
    /**
     * 
     * @type {FileDtoIntegerViewAccessibility}
     * @memberof FileDtoInteger
     */
    'viewAccessibility'?: FileDtoIntegerViewAccessibility | null;
    /**
     * Available external rights
     * @type {{ [key: string]: boolean; }}
     * @memberof FileDtoInteger
     */
    'availableExternalRights'?: { [key: string]: boolean; } | null;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileDtoInteger
     */
    'lastOpened'?: ApiDateTime;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileDtoInteger
     */
    'expired'?: ApiDateTime;
    /**
     * 
     * @type {FileEntryType}
     * @memberof FileDtoInteger
     */
    'fileEntryType'?: FileEntryType;
}


/**
 * Security
 * @export
 * @interface FileDtoIntegerSecurity
 */
export interface FileDtoIntegerSecurity {
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Read'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Comment'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'FillForms'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Review'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Create'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'CreateFrom'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Edit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Delete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'CustomFilter'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'EditRoom'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Rename'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'ReadHistory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Lock'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'EditHistory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'CopyTo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Copy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'MoveTo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Move'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Pin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Mute'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'EditAccess'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Duplicate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'SubmitToFormGallery'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Download'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Convert'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'CopySharedLink'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'ReadLinks'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Reconnect'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'CreateRoomFrom'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'CopyLink'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'Embed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'ChangeOwner'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerSecurity
     */
    'IndexExport'?: boolean;
}
/**
 * File accessibility
 * @export
 * @interface FileDtoIntegerViewAccessibility
 */
export interface FileDtoIntegerViewAccessibility {
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'ImageView'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'MediaView'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'WebView'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'WebEdit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'WebReview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'WebCustomFilterEditing'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'WebRestrictedEditing'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'WebComment'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'CoAuhtoring'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'CanConvert'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileDtoIntegerViewAccessibility
     */
    'MustConvert'?: boolean;
}
/**
 * 
 * @export
 * @interface FileEntryArrayWrapper
 */
export interface FileEntryArrayWrapper {
    /**
     * 
     * @type {Array<FileEntryDto>}
     * @memberof FileEntryArrayWrapper
     */
    'response'?: Array<FileEntryDto>;
    /**
     * 
     * @type {number}
     * @memberof FileEntryArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileEntryArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileEntryArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileEntryArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FileEntryDto
 */
export interface FileEntryDto {
    /**
     * Title
     * @type {string}
     * @memberof FileEntryDto
     */
    'title'?: string | null;
    /**
     * 
     * @type {FileShare}
     * @memberof FileEntryDto
     */
    'access'?: FileShare;
    /**
     * Specifies if the file is shared or not
     * @type {boolean}
     * @memberof FileEntryDto
     */
    'shared'?: boolean;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileEntryDto
     */
    'created'?: ApiDateTime;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof FileEntryDto
     */
    'createdBy'?: EmployeeDto;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileEntryDto
     */
    'updated'?: ApiDateTime;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileEntryDto
     */
    'autoDelete'?: ApiDateTime;
    /**
     * 
     * @type {FolderType}
     * @memberof FileEntryDto
     */
    'rootFolderType'?: FolderType;
    /**
     * 
     * @type {FolderType}
     * @memberof FileEntryDto
     */
    'parentRoomType'?: FolderType;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof FileEntryDto
     */
    'updatedBy'?: EmployeeDto;
    /**
     * Provider is specified or not
     * @type {boolean}
     * @memberof FileEntryDto
     */
    'providerItem'?: boolean | null;
    /**
     * Provider key
     * @type {string}
     * @memberof FileEntryDto
     */
    'providerKey'?: string | null;
    /**
     * Provider ID
     * @type {number}
     * @memberof FileEntryDto
     */
    'providerId'?: number | null;
    /**
     * Order
     * @type {string}
     * @memberof FileEntryDto
     */
    'order'?: string | null;
    /**
     * 
     * @type {FileEntryType}
     * @memberof FileEntryDto
     */
    'fileEntryType'?: FileEntryType;
}


/**
 * [1 - Folder, 2 - File]
 * @export
 * @enum {number}
 */

export const FileEntryType = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type FileEntryType = typeof FileEntryType[keyof typeof FileEntryType];


/**
 * 
 * @export
 * @interface FileEntryWrapper
 */
export interface FileEntryWrapper {
    /**
     * 
     * @type {FileEntryDto}
     * @memberof FileEntryWrapper
     */
    'response'?: FileEntryDto;
    /**
     * 
     * @type {number}
     * @memberof FileEntryWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileEntryWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileEntryWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileEntryWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FileIntegerArrayWrapper
 */
export interface FileIntegerArrayWrapper {
    /**
     * 
     * @type {Array<FileDtoInteger>}
     * @memberof FileIntegerArrayWrapper
     */
    'response'?: Array<FileDtoInteger>;
    /**
     * 
     * @type {number}
     * @memberof FileIntegerArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileIntegerArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileIntegerArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileIntegerArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FileIntegerWrapper
 */
export interface FileIntegerWrapper {
    /**
     * 
     * @type {FileDtoInteger}
     * @memberof FileIntegerWrapper
     */
    'response'?: FileDtoInteger;
    /**
     * 
     * @type {number}
     * @memberof FileIntegerWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileIntegerWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileIntegerWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileIntegerWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FileLink
 */
export interface FileLink {
    /**
     * File type
     * @type {string}
     * @memberof FileLink
     */
    'filetype'?: string | null;
    /**
     * Token
     * @type {string}
     * @memberof FileLink
     */
    'token'?: string | null;
    /**
     * Url
     * @type {string}
     * @memberof FileLink
     */
    'url'?: string | null;
}
/**
 * External link parameters
 * @export
 * @interface FileLinkRequest
 */
export interface FileLinkRequest {
    /**
     * Link ID
     * @type {string}
     * @memberof FileLinkRequest
     */
    'linkId'?: string;
    /**
     * 
     * @type {FileShare}
     * @memberof FileLinkRequest
     */
    'access'?: FileShare;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FileLinkRequest
     */
    'expirationDate'?: ApiDateTime;
    /**
     * Link scope
     * @type {boolean}
     * @memberof FileLinkRequest
     */
    'internal'?: boolean;
    /**
     * Primary link flag
     * @type {boolean}
     * @memberof FileLinkRequest
     */
    'primary'?: boolean;
}


/**
 * 
 * @export
 * @interface FileLinkWrapper
 */
export interface FileLinkWrapper {
    /**
     * 
     * @type {FileLink}
     * @memberof FileLinkWrapper
     */
    'response'?: FileLink;
    /**
     * 
     * @type {number}
     * @memberof FileLinkWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileLinkWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileLinkWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileLinkWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FileOperationArrayWrapper
 */
export interface FileOperationArrayWrapper {
    /**
     * 
     * @type {Array<FileOperationDto>}
     * @memberof FileOperationArrayWrapper
     */
    'response'?: Array<FileOperationDto>;
    /**
     * 
     * @type {number}
     * @memberof FileOperationArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileOperationArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileOperationArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileOperationArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FileOperationDto
 */
export interface FileOperationDto {
    /**
     * Operation ID
     * @type {string}
     * @memberof FileOperationDto
     */
    'id'?: string | null;
    /**
     * 
     * @type {FileOperationType}
     * @memberof FileOperationDto
     */
    'Operation'?: FileOperationType;
    /**
     * Operation progress
     * @type {number}
     * @memberof FileOperationDto
     */
    'progress'?: number;
    /**
     * Error
     * @type {string}
     * @memberof FileOperationDto
     */
    'error'?: string | null;
    /**
     * Processing status
     * @type {string}
     * @memberof FileOperationDto
     */
    'processed'?: string | null;
    /**
     * Specifies if the operation is finished or not
     * @type {boolean}
     * @memberof FileOperationDto
     */
    'finished'?: boolean;
    /**
     * URL
     * @type {string}
     * @memberof FileOperationDto
     */
    'url'?: string | null;
    /**
     * List of files
     * @type {Array<FileEntryDto>}
     * @memberof FileOperationDto
     */
    'files'?: Array<FileEntryDto> | null;
    /**
     * List of folders
     * @type {Array<FileEntryDto>}
     * @memberof FileOperationDto
     */
    'folders'?: Array<FileEntryDto> | null;
}


/**
 * [0 - Move, 1 - Copy, 2 - Delete, 3 - Download, 4 - MarkAsRead, 5 - Import, 6 - Convert, 7 - Duplicate]
 * @export
 * @enum {number}
 */

export const FileOperationType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7
} as const;

export type FileOperationType = typeof FileOperationType[keyof typeof FileOperationType];


/**
 * 
 * @export
 * @interface FileOperationWrapper
 */
export interface FileOperationWrapper {
    /**
     * 
     * @type {FileOperationDto}
     * @memberof FileOperationWrapper
     */
    'response'?: FileOperationDto;
    /**
     * 
     * @type {number}
     * @memberof FileOperationWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileOperationWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileOperationWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileOperationWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FileReference
 */
export interface FileReference {
    /**
     * 
     * @type {FileReferenceData}
     * @memberof FileReference
     */
    'referenceData'?: FileReferenceData;
    /**
     * Error
     * @type {string}
     * @memberof FileReference
     */
    'error'?: string | null;
    /**
     * Path
     * @type {string}
     * @memberof FileReference
     */
    'path'?: string | null;
    /**
     * URL
     * @type {string}
     * @memberof FileReference
     */
    'url'?: string | null;
    /**
     * File type
     * @type {string}
     * @memberof FileReference
     */
    'fileType'?: string | null;
    /**
     * Key
     * @type {string}
     * @memberof FileReference
     */
    'key'?: string | null;
    /**
     * Link
     * @type {string}
     * @memberof FileReference
     */
    'link'?: string | null;
    /**
     * Token
     * @type {string}
     * @memberof FileReference
     */
    'token'?: string | null;
}
/**
 * 
 * @export
 * @interface FileReferenceData
 */
export interface FileReferenceData {
    /**
     * File key
     * @type {string}
     * @memberof FileReferenceData
     */
    'fileKey'?: string | null;
    /**
     * Instance ID
     * @type {string}
     * @memberof FileReferenceData
     */
    'instanceId'?: string | null;
}
/**
 * 
 * @export
 * @interface FileReferenceWrapper
 */
export interface FileReferenceWrapper {
    /**
     * 
     * @type {FileReference}
     * @memberof FileReferenceWrapper
     */
    'response'?: FileReference;
    /**
     * 
     * @type {number}
     * @memberof FileReferenceWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileReferenceWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileReferenceWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileReferenceWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - None, 1 - Read and write, 2 - Read, 3 - Restrict, 4 - Varies, 5 - Review, 6 - Comment, 7 - Fill forms, 8 - Custom filter, 9 - Room manager, 10 - Editing, 11 - Content creator]
 * @export
 * @enum {number}
 */

export const FileShare = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11
} as const;

export type FileShare = typeof FileShare[keyof typeof FileShare];


/**
 * 
 * @export
 * @interface FileShareArrayWrapper
 */
export interface FileShareArrayWrapper {
    /**
     * 
     * @type {Array<FileShareDto>}
     * @memberof FileShareArrayWrapper
     */
    'response'?: Array<FileShareDto>;
    /**
     * 
     * @type {number}
     * @memberof FileShareArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileShareArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileShareArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileShareArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * Represents file sharing information and access rights
 * @export
 * @interface FileShareDto
 */
export interface FileShareDto {
    /**
     * 
     * @type {FileShare}
     * @memberof FileShareDto
     */
    'access'?: FileShare;
    /**
     * A user who has the access to the specified file
     * @type {any}
     * @memberof FileShareDto
     */
    'sharedTo'?: any | null;
    /**
     * Specifies if the file is locked by this user or not
     * @type {boolean}
     * @memberof FileShareDto
     */
    'isLocked'?: boolean;
    /**
     * Specifies if this user is an owner of the specified file or not
     * @type {boolean}
     * @memberof FileShareDto
     */
    'isOwner'?: boolean;
    /**
     * Spceifies if this user can edit the access to the specified file or not
     * @type {boolean}
     * @memberof FileShareDto
     */
    'canEditAccess'?: boolean;
    /**
     * 
     * @type {SubjectType}
     * @memberof FileShareDto
     */
    'subjectType'?: SubjectType;
}


/**
 * 
 * @export
 * @interface FileShareParams
 */
export interface FileShareParams {
    /**
     * ID of the user with whom we want to share a file
     * @type {string}
     * @memberof FileShareParams
     */
    'shareTo'?: string;
    /**
     * User email address
     * @type {string}
     * @memberof FileShareParams
     */
    'email'?: string | null;
    /**
     * 
     * @type {FileShare}
     * @memberof FileShareParams
     */
    'access'?: FileShare;
}


/**
 * 
 * @export
 * @interface FileShareWrapper
 */
export interface FileShareWrapper {
    /**
     * 
     * @type {FileShareDto}
     * @memberof FileShareWrapper
     */
    'response'?: FileShareDto;
    /**
     * 
     * @type {number}
     * @memberof FileShareWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileShareWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileShareWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileShareWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - None, 1 - Is editing, 2 - Is new, 4 - Is converting, 8 - Is original, 16 - Is editing alone, 32 - Is favorite, 64 - Is template, 128 - Is fill form draft]
 * @export
 * @enum {number}
 */

export const FileStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4,
    NUMBER_8: 8,
    NUMBER_16: 16,
    NUMBER_32: 32,
    NUMBER_64: 64,
    NUMBER_128: 128
} as const;

export type FileStatus = typeof FileStatus[keyof typeof FileStatus];


/**
 * [0 - Unknown, 1 - Archive, 2 - Video, 3 - Audio, 4 - Image, 5 - Spreadsheet, 6 - Presentation, 7 - Document, 10 - Pdf]
 * @export
 * @enum {number}
 */

export const FileType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_10: 10
} as const;

export type FileType = typeof FileType[keyof typeof FileType];


/**
 * File upload result dto
 * @export
 * @interface FileUploadResultDto
 */
export interface FileUploadResultDto {
    /**
     * Specifies if the operation is successful or not
     * @type {boolean}
     * @memberof FileUploadResultDto
     */
    'success'?: boolean;
    /**
     * Data
     * @type {any}
     * @memberof FileUploadResultDto
     */
    'data'?: any | null;
    /**
     * Message
     * @type {string}
     * @memberof FileUploadResultDto
     */
    'message'?: string | null;
}
/**
 * 
 * @export
 * @interface FileUploadResultWrapper
 */
export interface FileUploadResultWrapper {
    /**
     * 
     * @type {FileUploadResultDto}
     * @memberof FileUploadResultWrapper
     */
    'response'?: FileUploadResultDto;
    /**
     * 
     * @type {number}
     * @memberof FileUploadResultWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FileUploadResultWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FileUploadResultWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileUploadResultWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FilesSettingsDto
 */
export interface FilesSettingsDto {
    /**
     * Exts image previewed
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsImagePreviewed'?: Array<string> | null;
    /**
     * Exts media previewed
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsMediaPreviewed'?: Array<string> | null;
    /**
     * Exts web previewed
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsWebPreviewed'?: Array<string> | null;
    /**
     * Exts web edited
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsWebEdited'?: Array<string> | null;
    /**
     * Exts web encrypt
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsWebEncrypt'?: Array<string> | null;
    /**
     * Exts web reviewed
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsWebReviewed'?: Array<string> | null;
    /**
     * Exts web custom filter editing
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsWebCustomFilterEditing'?: Array<string> | null;
    /**
     * Exts web restricted editing
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsWebRestrictedEditing'?: Array<string> | null;
    /**
     * Exts web commented
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsWebCommented'?: Array<string> | null;
    /**
     * Exts web template
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsWebTemplate'?: Array<string> | null;
    /**
     * Exts co authoring
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsCoAuthoring'?: Array<string> | null;
    /**
     * Exts must convert
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsMustConvert'?: Array<string> | null;
    /**
     * Exts convertible
     * @type {{ [key: string]: Array<string> | null; }}
     * @memberof FilesSettingsDto
     */
    'extsConvertible'?: { [key: string]: Array<string> | null; } | null;
    /**
     * Exts uploadable
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsUploadable'?: Array<string> | null;
    /**
     * Exts archive
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsArchive'?: Array<string> | null;
    /**
     * Exts video
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsVideo'?: Array<string> | null;
    /**
     * Exts audio
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsAudio'?: Array<string> | null;
    /**
     * Exts image
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsImage'?: Array<string> | null;
    /**
     * Exts spreadsheet
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsSpreadsheet'?: Array<string> | null;
    /**
     * Exts presentation
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsPresentation'?: Array<string> | null;
    /**
     * Exts document
     * @type {Array<string>}
     * @memberof FilesSettingsDto
     */
    'extsDocument'?: Array<string> | null;
    /**
     * 
     * @type {FilesSettingsDtoInternalFormats}
     * @memberof FilesSettingsDto
     */
    'internalFormats'?: FilesSettingsDtoInternalFormats | null;
    /**
     * Master form extension
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'masterFormExtension'?: string | null;
    /**
     * Param version
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'paramVersion'?: string | null;
    /**
     * Param out type
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'paramOutType'?: string | null;
    /**
     * File download url string
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'fileDownloadUrlString'?: string | null;
    /**
     * File web viewer url string
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'fileWebViewerUrlString'?: string | null;
    /**
     * File web viewer external url string
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'fileWebViewerExternalUrlString'?: string | null;
    /**
     * File web editor url string
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'fileWebEditorUrlString'?: string | null;
    /**
     * File web editor external url string
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'fileWebEditorExternalUrlString'?: string | null;
    /**
     * File redirect preview url string
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'fileRedirectPreviewUrlString'?: string | null;
    /**
     * File thumbnail url string
     * @type {string}
     * @memberof FilesSettingsDto
     */
    'fileThumbnailUrlString'?: string | null;
    /**
     * Confirm delete
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'confirmDelete'?: boolean;
    /**
     * EnableT third party
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'enableThirdParty'?: boolean;
    /**
     * External share
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'externalShare'?: boolean;
    /**
     * External share social media
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'externalShareSocialMedia'?: boolean;
    /**
     * Store original files
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'storeOriginalFiles'?: boolean;
    /**
     * Keep new file name
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'keepNewFileName'?: boolean;
    /**
     * Display file extension
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'displayFileExtension'?: boolean;
    /**
     * Convert notify
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'convertNotify'?: boolean;
    /**
     * Hide confirm cancel operation
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'hideConfirmCancelOperation'?: boolean;
    /**
     * HideC confirm convert save
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'hideConfirmConvertSave'?: boolean;
    /**
     * Hide confirm convert open
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'hideConfirmConvertOpen'?: boolean;
    /**
     * Hide confirm room lifetime
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'hideConfirmRoomLifetime'?: boolean;
    /**
     * 
     * @type {OrderBy}
     * @memberof FilesSettingsDto
     */
    'defaultOrder'?: OrderBy;
    /**
     * Forcesave
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'forcesave'?: boolean;
    /**
     * Store forcesave
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'storeForcesave'?: boolean;
    /**
     * Recent section
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'recentSection'?: boolean;
    /**
     * Favorites section
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'favoritesSection'?: boolean;
    /**
     * Templates section
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'templatesSection'?: boolean;
    /**
     * Download tar gz
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'downloadTarGz'?: boolean;
    /**
     * 
     * @type {AutoCleanUpData}
     * @memberof FilesSettingsDto
     */
    'automaticallyCleanUp'?: AutoCleanUpData;
    /**
     * Can search by content
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'canSearchByContent'?: boolean;
    /**
     * Default sharing access rights
     * @type {Array<FileShare>}
     * @memberof FilesSettingsDto
     */
    'defaultSharingAccessRights'?: Array<FileShare> | null;
    /**
     * Max upload thread count
     * @type {number}
     * @memberof FilesSettingsDto
     */
    'maxUploadThreadCount'?: number;
    /**
     * Chunk upload size
     * @type {number}
     * @memberof FilesSettingsDto
     */
    'chunkUploadSize'?: number;
    /**
     * Open editor in same tab
     * @type {boolean}
     * @memberof FilesSettingsDto
     */
    'openEditorInSameTab'?: boolean;
}
/**
 * Internal formats
 * @export
 * @interface FilesSettingsDtoInternalFormats
 */
export interface FilesSettingsDtoInternalFormats {
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Unknown'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Archive'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Video'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Audio'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Spreadsheet'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Presentation'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Document'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilesSettingsDtoInternalFormats
     */
    'Pdf'?: string;
}
/**
 * 
 * @export
 * @interface FilesSettingsWrapper
 */
export interface FilesSettingsWrapper {
    /**
     * 
     * @type {FilesSettingsDto}
     * @memberof FilesSettingsWrapper
     */
    'response'?: FilesSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof FilesSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FilesSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FilesSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FilesSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FilesStatisticsFolder
 */
export interface FilesStatisticsFolder {
    /**
     * Folder title
     * @type {string}
     * @memberof FilesStatisticsFolder
     */
    'title'?: string | null;
    /**
     * Used space
     * @type {number}
     * @memberof FilesStatisticsFolder
     */
    'usedSpace'?: number;
}
/**
 * 
 * @export
 * @interface FilesStatisticsResultDto
 */
export interface FilesStatisticsResultDto {
    /**
     * 
     * @type {FilesStatisticsFolder}
     * @memberof FilesStatisticsResultDto
     */
    'myDocumentsUsedSpace'?: FilesStatisticsFolder;
    /**
     * 
     * @type {FilesStatisticsFolder}
     * @memberof FilesStatisticsResultDto
     */
    'trashUsedSpace'?: FilesStatisticsFolder;
    /**
     * 
     * @type {FilesStatisticsFolder}
     * @memberof FilesStatisticsResultDto
     */
    'archiveUsedSpace'?: FilesStatisticsFolder;
    /**
     * 
     * @type {FilesStatisticsFolder}
     * @memberof FilesStatisticsResultDto
     */
    'roomsUsedSpace'?: FilesStatisticsFolder;
}
/**
 * 
 * @export
 * @interface FilesStatisticsResultWrapper
 */
export interface FilesStatisticsResultWrapper {
    /**
     * 
     * @type {FilesStatisticsResultDto}
     * @memberof FilesStatisticsResultWrapper
     */
    'response'?: FilesStatisticsResultDto;
    /**
     * 
     * @type {number}
     * @memberof FilesStatisticsResultWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FilesStatisticsResultWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FilesStatisticsResultWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FilesStatisticsResultWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FillingFormResultDtoInteger
 */
export interface FillingFormResultDtoInteger {
    /**
     * Form number
     * @type {number}
     * @memberof FillingFormResultDtoInteger
     */
    'formNumber'?: number;
    /**
     * 
     * @type {FileDtoInteger}
     * @memberof FillingFormResultDtoInteger
     */
    'completedForm'?: FileDtoInteger;
    /**
     * 
     * @type {FileDtoInteger}
     * @memberof FillingFormResultDtoInteger
     */
    'originalForm'?: FileDtoInteger;
    /**
     * 
     * @type {EmployeeFullDto}
     * @memberof FillingFormResultDtoInteger
     */
    'manager'?: EmployeeFullDto;
    /**
     * Room Id
     * @type {number}
     * @memberof FillingFormResultDtoInteger
     */
    'roomId'?: number;
    /**
     * Is room member
     * @type {boolean}
     * @memberof FillingFormResultDtoInteger
     */
    'isRoomMember'?: boolean;
}
/**
 * 
 * @export
 * @interface FillingFormResultIntegerWrapper
 */
export interface FillingFormResultIntegerWrapper {
    /**
     * 
     * @type {FillingFormResultDtoInteger}
     * @memberof FillingFormResultIntegerWrapper
     */
    'response'?: FillingFormResultDtoInteger;
    /**
     * 
     * @type {number}
     * @memberof FillingFormResultIntegerWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FillingFormResultIntegerWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FillingFormResultIntegerWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FillingFormResultIntegerWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - None, 1 - Files  only, 2 - Folders only, 3 - Documents only, 4 - Presentations only, 5 - Spreadsheets only, 7 - Images only, 8 - By user, 9 - By department, 10 - Archive only, 11 - By extension, 12 - Media only, 13 - Filling forms rooms, 14 - Editing rooms, 17 - Custom rooms, 20 - Public rooms, 22 - Pdf, 23 - Pdf form]
 * @export
 * @enum {number}
 */

export const FilterType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_17: 17,
    NUMBER_20: 20,
    NUMBER_22: 22,
    NUMBER_23: 23
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


/**
 * 
 * @export
 * @interface FinishDto
 */
export interface FinishDto {
    /**
     * Is send welcome email
     * @type {boolean}
     * @memberof FinishDto
     */
    'isSendWelcomeEmail'?: boolean;
}
/**
 * 
 * @export
 * @interface FireBaseUser
 */
export interface FireBaseUser {
    /**
     * ID
     * @type {number}
     * @memberof FireBaseUser
     */
    'id'?: number;
    /**
     * User ID
     * @type {string}
     * @memberof FireBaseUser
     */
    'userId'?: string;
    /**
     * Tenant ID
     * @type {number}
     * @memberof FireBaseUser
     */
    'tenantId'?: number;
    /**
     * Firebase device token
     * @type {string}
     * @memberof FireBaseUser
     */
    'firebaseDeviceToken'?: string | null;
    /**
     * Application
     * @type {string}
     * @memberof FireBaseUser
     */
    'application'?: string | null;
    /**
     * Specifies if the user is subscribed to the push notifications or not
     * @type {boolean}
     * @memberof FireBaseUser
     */
    'isSubscribed'?: boolean | null;
    /**
     * 
     * @type {DbTenant}
     * @memberof FireBaseUser
     */
    'tenant'?: DbTenant;
}
/**
 * 
 * @export
 * @interface FireBaseUserWrapper
 */
export interface FireBaseUserWrapper {
    /**
     * 
     * @type {FireBaseUser}
     * @memberof FireBaseUserWrapper
     */
    'response'?: FireBaseUser;
    /**
     * 
     * @type {number}
     * @memberof FireBaseUserWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FireBaseUserWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FireBaseUserWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FireBaseUserWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FirebaseDto
 */
export interface FirebaseDto {
    /**
     * API key
     * @type {string}
     * @memberof FirebaseDto
     */
    'apiKey'?: string | null;
    /**
     * Authentication domain
     * @type {string}
     * @memberof FirebaseDto
     */
    'authDomain'?: string | null;
    /**
     * Project ID
     * @type {string}
     * @memberof FirebaseDto
     */
    'projectId'?: string | null;
    /**
     * Storage bucket
     * @type {string}
     * @memberof FirebaseDto
     */
    'storageBucket'?: string | null;
    /**
     * Message sender ID
     * @type {string}
     * @memberof FirebaseDto
     */
    'messagingSenderId'?: string | null;
    /**
     * Application ID
     * @type {string}
     * @memberof FirebaseDto
     */
    'appId'?: string | null;
    /**
     * Measurement ID
     * @type {string}
     * @memberof FirebaseDto
     */
    'measurementId'?: string | null;
    /**
     * Database URL
     * @type {string}
     * @memberof FirebaseDto
     */
    'databaseURL'?: string | null;
}
/**
 * Firebase request parameters
 * @export
 * @interface FirebaseRequestsDto
 */
export interface FirebaseRequestsDto {
    /**
     * Firebase device token
     * @type {string}
     * @memberof FirebaseRequestsDto
     */
    'firebaseDeviceToken'?: string | null;
    /**
     * Specifies if the user is subscribed to the push notification or not
     * @type {boolean}
     * @memberof FirebaseRequestsDto
     */
    'isSubscribed'?: boolean;
}
/**
 * 
 * @export
 * @interface FolderContentDtoInteger
 */
export interface FolderContentDtoInteger {
    /**
     * List of files
     * @type {Array<FileEntryDto>}
     * @memberof FolderContentDtoInteger
     */
    'files'?: Array<FileEntryDto> | null;
    /**
     * List of folders
     * @type {Array<FileEntryDto>}
     * @memberof FolderContentDtoInteger
     */
    'folders'?: Array<FileEntryDto> | null;
    /**
     * 
     * @type {FolderDtoInteger}
     * @memberof FolderContentDtoInteger
     */
    'current'?: FolderDtoInteger;
    /**
     * Folder path
     * @type {any}
     * @memberof FolderContentDtoInteger
     */
    'pathParts'?: any | null;
    /**
     * Folder start index
     * @type {number}
     * @memberof FolderContentDtoInteger
     */
    'startIndex'?: number;
    /**
     * Number of folder elements
     * @type {number}
     * @memberof FolderContentDtoInteger
     */
    'count'?: number;
    /**
     * Total number of elements in the folder
     * @type {number}
     * @memberof FolderContentDtoInteger
     */
    'total'?: number;
    /**
     * New element index
     * @type {number}
     * @memberof FolderContentDtoInteger
     */
    'new'?: number;
}
/**
 * 
 * @export
 * @interface FolderContentIntegerArrayWrapper
 */
export interface FolderContentIntegerArrayWrapper {
    /**
     * 
     * @type {Array<FolderContentDtoInteger>}
     * @memberof FolderContentIntegerArrayWrapper
     */
    'response'?: Array<FolderContentDtoInteger>;
    /**
     * 
     * @type {number}
     * @memberof FolderContentIntegerArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FolderContentIntegerArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FolderContentIntegerArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FolderContentIntegerArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FolderContentIntegerWrapper
 */
export interface FolderContentIntegerWrapper {
    /**
     * 
     * @type {FolderContentDtoInteger}
     * @memberof FolderContentIntegerWrapper
     */
    'response'?: FolderContentDtoInteger;
    /**
     * 
     * @type {number}
     * @memberof FolderContentIntegerWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FolderContentIntegerWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FolderContentIntegerWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FolderContentIntegerWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FolderDtoInteger
 */
export interface FolderDtoInteger {
    /**
     * Title
     * @type {string}
     * @memberof FolderDtoInteger
     */
    'title'?: string | null;
    /**
     * 
     * @type {FileShare}
     * @memberof FolderDtoInteger
     */
    'access'?: FileShare;
    /**
     * Specifies if the file is shared or not
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'shared'?: boolean;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FolderDtoInteger
     */
    'created'?: ApiDateTime;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof FolderDtoInteger
     */
    'createdBy'?: EmployeeDto;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FolderDtoInteger
     */
    'updated'?: ApiDateTime;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FolderDtoInteger
     */
    'autoDelete'?: ApiDateTime;
    /**
     * 
     * @type {FolderType}
     * @memberof FolderDtoInteger
     */
    'rootFolderType'?: FolderType;
    /**
     * 
     * @type {FolderType}
     * @memberof FolderDtoInteger
     */
    'parentRoomType'?: FolderType;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof FolderDtoInteger
     */
    'updatedBy'?: EmployeeDto;
    /**
     * Provider is specified or not
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'providerItem'?: boolean | null;
    /**
     * Provider key
     * @type {string}
     * @memberof FolderDtoInteger
     */
    'providerKey'?: string | null;
    /**
     * Provider ID
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'providerId'?: number | null;
    /**
     * Order
     * @type {string}
     * @memberof FolderDtoInteger
     */
    'order'?: string | null;
    /**
     * Id
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'id'?: number;
    /**
     * Root folder id
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'rootFolderId'?: number;
    /**
     * Origin id
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'originId'?: number;
    /**
     * Origin room id
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'originRoomId'?: number;
    /**
     * Origin title
     * @type {string}
     * @memberof FolderDtoInteger
     */
    'originTitle'?: string | null;
    /**
     * Origin room title
     * @type {string}
     * @memberof FolderDtoInteger
     */
    'originRoomTitle'?: string | null;
    /**
     * Can share
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'canShare'?: boolean;
    /**
     * 
     * @type {FileDtoIntegerSecurity}
     * @memberof FolderDtoInteger
     */
    'security'?: FileDtoIntegerSecurity | null;
    /**
     * 
     * @type {string}
     * @memberof FolderDtoInteger
     */
    'requestToken'?: string | null;
    /**
     * Parent folder ID
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'parentId'?: number;
    /**
     * Number of files
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'filesCount'?: number;
    /**
     * Number of folders
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'foldersCount'?: number;
    /**
     * Specifies if a folder is shareable or not
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'isShareable'?: boolean | null;
    /**
     * Specifies if a folder is favorite or not
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'isFavorite'?: boolean | null;
    /**
     * Number for a new folder
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'new'?: number;
    /**
     * Specifies if a folder is muted or not
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'mute'?: boolean;
    /**
     * List of tags
     * @type {Array<string>}
     * @memberof FolderDtoInteger
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {Logo}
     * @memberof FolderDtoInteger
     */
    'logo'?: Logo;
    /**
     * Specifies if a folder is pinned or not
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'pinned'?: boolean;
    /**
     * 
     * @type {RoomType}
     * @memberof FolderDtoInteger
     */
    'roomType'?: RoomType;
    /**
     * Specifies if a folder is private or not
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'private'?: boolean;
    /**
     * Indexing
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'indexing'?: boolean;
    /**
     * Deny download
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'denyDownload'?: boolean;
    /**
     * 
     * @type {RoomDataLifetimeDto}
     * @memberof FolderDtoInteger
     */
    'lifetime'?: RoomDataLifetimeDto;
    /**
     * 
     * @type {WatermarkDto}
     * @memberof FolderDtoInteger
     */
    'watermark'?: WatermarkDto;
    /**
     * 
     * @type {FolderType}
     * @memberof FolderDtoInteger
     */
    'type'?: FolderType;
    /**
     * InRoom
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'inRoom'?: boolean | null;
    /**
     * Quota
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'quotaLimit'?: number | null;
    /**
     * Specifies if the room has a custom quota or not
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'isCustomQuota'?: boolean | null;
    /**
     * Counter
     * @type {number}
     * @memberof FolderDtoInteger
     */
    'usedSpace'?: number | null;
    /**
     * Specifies if the link external
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'external'?: boolean | null;
    /**
     * Specifies if the password protected
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'passwordProtected'?: boolean | null;
    /**
     * Expired
     * @type {boolean}
     * @memberof FolderDtoInteger
     */
    'expired'?: boolean | null;
    /**
     * 
     * @type {FileEntryType}
     * @memberof FolderDtoInteger
     */
    'fileEntryType'?: FileEntryType;
}


/**
 * 
 * @export
 * @interface FolderDtoString
 */
export interface FolderDtoString {
    /**
     * Title
     * @type {string}
     * @memberof FolderDtoString
     */
    'title'?: string | null;
    /**
     * 
     * @type {FileShare}
     * @memberof FolderDtoString
     */
    'access'?: FileShare;
    /**
     * Specifies if the file is shared or not
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'shared'?: boolean;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FolderDtoString
     */
    'created'?: ApiDateTime;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof FolderDtoString
     */
    'createdBy'?: EmployeeDto;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FolderDtoString
     */
    'updated'?: ApiDateTime;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof FolderDtoString
     */
    'autoDelete'?: ApiDateTime;
    /**
     * 
     * @type {FolderType}
     * @memberof FolderDtoString
     */
    'rootFolderType'?: FolderType;
    /**
     * 
     * @type {FolderType}
     * @memberof FolderDtoString
     */
    'parentRoomType'?: FolderType;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof FolderDtoString
     */
    'updatedBy'?: EmployeeDto;
    /**
     * Provider is specified or not
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'providerItem'?: boolean | null;
    /**
     * Provider key
     * @type {string}
     * @memberof FolderDtoString
     */
    'providerKey'?: string | null;
    /**
     * Provider ID
     * @type {number}
     * @memberof FolderDtoString
     */
    'providerId'?: number | null;
    /**
     * Order
     * @type {string}
     * @memberof FolderDtoString
     */
    'order'?: string | null;
    /**
     * Id
     * @type {string}
     * @memberof FolderDtoString
     */
    'id'?: string | null;
    /**
     * Root folder id
     * @type {string}
     * @memberof FolderDtoString
     */
    'rootFolderId'?: string | null;
    /**
     * Origin id
     * @type {string}
     * @memberof FolderDtoString
     */
    'originId'?: string | null;
    /**
     * Origin room id
     * @type {string}
     * @memberof FolderDtoString
     */
    'originRoomId'?: string | null;
    /**
     * Origin title
     * @type {string}
     * @memberof FolderDtoString
     */
    'originTitle'?: string | null;
    /**
     * Origin room title
     * @type {string}
     * @memberof FolderDtoString
     */
    'originRoomTitle'?: string | null;
    /**
     * Can share
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'canShare'?: boolean;
    /**
     * 
     * @type {FileDtoIntegerSecurity}
     * @memberof FolderDtoString
     */
    'security'?: FileDtoIntegerSecurity | null;
    /**
     * 
     * @type {string}
     * @memberof FolderDtoString
     */
    'requestToken'?: string | null;
    /**
     * Parent folder ID
     * @type {string}
     * @memberof FolderDtoString
     */
    'parentId'?: string | null;
    /**
     * Number of files
     * @type {number}
     * @memberof FolderDtoString
     */
    'filesCount'?: number;
    /**
     * Number of folders
     * @type {number}
     * @memberof FolderDtoString
     */
    'foldersCount'?: number;
    /**
     * Specifies if a folder is shareable or not
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'isShareable'?: boolean | null;
    /**
     * Specifies if a folder is favorite or not
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'isFavorite'?: boolean | null;
    /**
     * Number for a new folder
     * @type {number}
     * @memberof FolderDtoString
     */
    'new'?: number;
    /**
     * Specifies if a folder is muted or not
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'mute'?: boolean;
    /**
     * List of tags
     * @type {Array<string>}
     * @memberof FolderDtoString
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {Logo}
     * @memberof FolderDtoString
     */
    'logo'?: Logo;
    /**
     * Specifies if a folder is pinned or not
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'pinned'?: boolean;
    /**
     * 
     * @type {RoomType}
     * @memberof FolderDtoString
     */
    'roomType'?: RoomType;
    /**
     * Specifies if a folder is private or not
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'private'?: boolean;
    /**
     * Indexing
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'indexing'?: boolean;
    /**
     * Deny download
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'denyDownload'?: boolean;
    /**
     * 
     * @type {RoomDataLifetimeDto}
     * @memberof FolderDtoString
     */
    'lifetime'?: RoomDataLifetimeDto;
    /**
     * 
     * @type {WatermarkDto}
     * @memberof FolderDtoString
     */
    'watermark'?: WatermarkDto;
    /**
     * 
     * @type {FolderType}
     * @memberof FolderDtoString
     */
    'type'?: FolderType;
    /**
     * InRoom
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'inRoom'?: boolean | null;
    /**
     * Quota
     * @type {number}
     * @memberof FolderDtoString
     */
    'quotaLimit'?: number | null;
    /**
     * Specifies if the room has a custom quota or not
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'isCustomQuota'?: boolean | null;
    /**
     * Counter
     * @type {number}
     * @memberof FolderDtoString
     */
    'usedSpace'?: number | null;
    /**
     * Specifies if the link external
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'external'?: boolean | null;
    /**
     * Specifies if the password protected
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'passwordProtected'?: boolean | null;
    /**
     * Expired
     * @type {boolean}
     * @memberof FolderDtoString
     */
    'expired'?: boolean | null;
    /**
     * 
     * @type {FileEntryType}
     * @memberof FolderDtoString
     */
    'fileEntryType'?: FileEntryType;
}


/**
 * 
 * @export
 * @interface FolderIntegerArrayWrapper
 */
export interface FolderIntegerArrayWrapper {
    /**
     * 
     * @type {Array<FolderDtoInteger>}
     * @memberof FolderIntegerArrayWrapper
     */
    'response'?: Array<FolderDtoInteger>;
    /**
     * 
     * @type {number}
     * @memberof FolderIntegerArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FolderIntegerArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FolderIntegerArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FolderIntegerArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FolderIntegerWrapper
 */
export interface FolderIntegerWrapper {
    /**
     * 
     * @type {FolderDtoInteger}
     * @memberof FolderIntegerWrapper
     */
    'response'?: FolderDtoInteger;
    /**
     * 
     * @type {number}
     * @memberof FolderIntegerWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FolderIntegerWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FolderIntegerWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FolderIntegerWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FolderStringArrayWrapper
 */
export interface FolderStringArrayWrapper {
    /**
     * 
     * @type {Array<FolderDtoString>}
     * @memberof FolderStringArrayWrapper
     */
    'response'?: Array<FolderDtoString>;
    /**
     * 
     * @type {number}
     * @memberof FolderStringArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FolderStringArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FolderStringArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FolderStringArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FolderStringWrapper
 */
export interface FolderStringWrapper {
    /**
     * 
     * @type {FolderDtoString}
     * @memberof FolderStringWrapper
     */
    'response'?: FolderDtoString;
    /**
     * 
     * @type {number}
     * @memberof FolderStringWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FolderStringWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FolderStringWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FolderStringWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Default, 1 - Coomon, 2 - Bunch, 3 - Trash, 5 - User, 6 - Share, 8 - Projects, 10 - Favourites, 11 - Recent, 12 - Templates, 13 - Privacy, 14 - Virtual rooms, 15 - Filling forms room, 16 - Editing room, 19 - Custom room, 20 - Archive, 21 - Thirdparty backup, 22 - Public room, 25 - Ready form folder, 26 - In process form folder, 27 - Form filling folder done, 28 - Form filling folder in progress, 29 - Virtual Data Room, 30 - Room templates folder]
 * @export
 * @enum {number}
 */

export const FolderType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_8: 8,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15,
    NUMBER_16: 16,
    NUMBER_19: 19,
    NUMBER_20: 20,
    NUMBER_21: 21,
    NUMBER_22: 22,
    NUMBER_25: 25,
    NUMBER_26: 26,
    NUMBER_27: 27,
    NUMBER_28: 28,
    NUMBER_29: 29,
    NUMBER_30: 30
} as const;

export type FolderType = typeof FolderType[keyof typeof FolderType];


/**
 * 
 * @export
 * @interface FormGalleryDto
 */
export interface FormGalleryDto {
    /**
     * Path
     * @type {string}
     * @memberof FormGalleryDto
     */
    'path'?: string | null;
    /**
     * Domain
     * @type {string}
     * @memberof FormGalleryDto
     */
    'domain'?: string | null;
    /**
     * Ext
     * @type {string}
     * @memberof FormGalleryDto
     */
    'ext'?: string | null;
    /**
     * Upload path
     * @type {string}
     * @memberof FormGalleryDto
     */
    'uploadPath'?: string | null;
    /**
     * Upload domain
     * @type {string}
     * @memberof FormGalleryDto
     */
    'uploadDomain'?: string | null;
    /**
     * Upload ext
     * @type {string}
     * @memberof FormGalleryDto
     */
    'uploadExt'?: string | null;
    /**
     * Upload dashboard
     * @type {string}
     * @memberof FormGalleryDto
     */
    'uploadDashboard'?: string | null;
}
/**
 * 
 * @export
 * @interface FormsItemArrayWrapper
 */
export interface FormsItemArrayWrapper {
    /**
     * 
     * @type {Array<FormsItemDto>}
     * @memberof FormsItemArrayWrapper
     */
    'response'?: Array<FormsItemDto>;
    /**
     * 
     * @type {number}
     * @memberof FormsItemArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof FormsItemArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof FormsItemArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof FormsItemArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface FormsItemDto
 */
export interface FormsItemDto {
    /**
     * 
     * @type {string}
     * @memberof FormsItemDto
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FormsItemDto
     */
    'type'?: string | null;
}
/**
 * Request parameters for getting reference data
 * @export
 * @interface GetReferenceDataDtoInteger
 */
export interface GetReferenceDataDtoInteger {
    /**
     * The unique document identifier used by the service to get a link to the file
     * @type {number}
     * @memberof GetReferenceDataDtoInteger
     */
    'fileKey'?: number;
    /**
     * The unique system identifier
     * @type {string}
     * @memberof GetReferenceDataDtoInteger
     */
    'instanceId'?: string | null;
    /**
     * Source file ID
     * @type {number}
     * @memberof GetReferenceDataDtoInteger
     */
    'sourceFileId'?: number;
    /**
     * The file name or relative path for the formula editor
     * @type {string}
     * @memberof GetReferenceDataDtoInteger
     */
    'path'?: string | null;
    /**
     * Link to file
     * @type {string}
     * @memberof GetReferenceDataDtoInteger
     */
    'link'?: string | null;
}
/**
 * 
 * @export
 * @interface GobackConfig
 */
export interface GobackConfig {
    /**
     * Url
     * @type {string}
     * @memberof GobackConfig
     */
    'url'?: string | null;
}
/**
 * Greeting settings
 * @export
 * @interface GreetingSettingsRequestsDto
 */
export interface GreetingSettingsRequestsDto {
    /**
     * Tenant name
     * @type {string}
     * @memberof GreetingSettingsRequestsDto
     */
    'title'?: string | null;
}
/**
 * 
 * @export
 * @interface GroupArrayWrapper
 */
export interface GroupArrayWrapper {
    /**
     * 
     * @type {Array<GroupDto>}
     * @memberof GroupArrayWrapper
     */
    'response'?: Array<GroupDto>;
    /**
     * 
     * @type {number}
     * @memberof GroupArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof GroupArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof GroupArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof GroupArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
    /**
     * Name
     * @type {string}
     * @memberof GroupDto
     */
    'name'?: string | null;
    /**
     * Parent
     * @type {string}
     * @memberof GroupDto
     */
    'parent'?: string | null;
    /**
     * Category
     * @type {string}
     * @memberof GroupDto
     */
    'category'?: string;
    /**
     * ID
     * @type {string}
     * @memberof GroupDto
     */
    'id'?: string;
    /**
     * Specifies if the LDAP settings are enabled for the group or not
     * @type {boolean}
     * @memberof GroupDto
     */
    'isLDAP'?: boolean;
    /**
     * 
     * @type {EmployeeFullDto}
     * @memberof GroupDto
     */
    'manager'?: EmployeeFullDto;
    /**
     * List of members
     * @type {Array<EmployeeFullDto>}
     * @memberof GroupDto
     */
    'members'?: Array<EmployeeFullDto> | null;
    /**
     * Shared
     * @type {boolean}
     * @memberof GroupDto
     */
    'shared'?: boolean | null;
    /**
     * Members count
     * @type {number}
     * @memberof GroupDto
     */
    'membersCount'?: number;
}
/**
 * Group request parameters
 * @export
 * @interface GroupRequestDto
 */
export interface GroupRequestDto {
    /**
     * List of group member IDs
     * @type {Array<string>}
     * @memberof GroupRequestDto
     */
    'members'?: Array<string> | null;
    /**
     * Group manager ID
     * @type {string}
     * @memberof GroupRequestDto
     */
    'groupManager'?: string;
    /**
     * Group name
     * @type {string}
     * @memberof GroupRequestDto
     */
    'groupName'?: string | null;
}
/**
 * 
 * @export
 * @interface GroupSummaryArrayWrapper
 */
export interface GroupSummaryArrayWrapper {
    /**
     * 
     * @type {Array<GroupSummaryDto>}
     * @memberof GroupSummaryArrayWrapper
     */
    'response'?: Array<GroupSummaryDto>;
    /**
     * 
     * @type {number}
     * @memberof GroupSummaryArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof GroupSummaryArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof GroupSummaryArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof GroupSummaryArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface GroupSummaryDto
 */
export interface GroupSummaryDto {
    /**
     * ID
     * @type {string}
     * @memberof GroupSummaryDto
     */
    'id'?: string;
    /**
     * Name
     * @type {string}
     * @memberof GroupSummaryDto
     */
    'name'?: string | null;
    /**
     * Manager
     * @type {string}
     * @memberof GroupSummaryDto
     */
    'manager'?: string | null;
}
/**
 * 
 * @export
 * @interface GroupWrapper
 */
export interface GroupWrapper {
    /**
     * 
     * @type {GroupDto}
     * @memberof GroupWrapper
     */
    'response'?: GroupDto;
    /**
     * 
     * @type {number}
     * @memberof GroupWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof GroupWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof GroupWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof GroupWrapper
     */
    'statusCode'?: number;
}
/**
 * Request parameters for hiding the confirmation dialog
 * @export
 * @interface HideConfirmConvertRequestDto
 */
export interface HideConfirmConvertRequestDto {
    /**
     * Specifies whether to set the specified settings or not
     * @type {boolean}
     * @memberof HideConfirmConvertRequestDto
     */
    'save'?: boolean;
}
/**
 * 
 * @export
 * @interface HistoryAction
 */
export interface HistoryAction {
    /**
     * 
     * @type {MessageAction}
     * @memberof HistoryAction
     */
    'id'?: MessageAction;
    /**
     * 
     * @type {string}
     * @memberof HistoryAction
     */
    'key'?: string | null;
}


/**
 * 
 * @export
 * @interface HistoryArrayWrapper
 */
export interface HistoryArrayWrapper {
    /**
     * 
     * @type {Array<HistoryDto>}
     * @memberof HistoryArrayWrapper
     */
    'response'?: Array<HistoryDto>;
    /**
     * 
     * @type {number}
     * @memberof HistoryArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof HistoryArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof HistoryArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof HistoryArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface HistoryData
 */
export interface HistoryData {
    /**
     * 
     * @type {string}
     * @memberof HistoryData
     */
    'initiatorName'?: string | null;
}
/**
 * 
 * @export
 * @interface HistoryDto
 */
export interface HistoryDto {
    /**
     * 
     * @type {HistoryAction}
     * @memberof HistoryDto
     */
    'action'?: HistoryAction;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof HistoryDto
     */
    'initiator'?: EmployeeDto;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof HistoryDto
     */
    'date'?: ApiDateTime;
    /**
     * 
     * @type {HistoryData}
     * @memberof HistoryDto
     */
    'data'?: HistoryData;
    /**
     * Related
     * @type {Array<HistoryDto>}
     * @memberof HistoryDto
     */
    'related'?: Array<HistoryDto> | null;
}
/**
 * 
 * @export
 * @interface ICompressWrapper
 */
export interface ICompressWrapper {
    /**
     * Archiving Class Unification Interface
     * @type {object}
     * @memberof ICompressWrapper
     */
    'response'?: object;
    /**
     * 
     * @type {number}
     * @memberof ICompressWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ICompressWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ICompressWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ICompressWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface IMagickGeometry
 */
export interface IMagickGeometry {
    /**
     * 
     * @type {boolean}
     * @memberof IMagickGeometry
     */
    'aspectRatio'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IMagickGeometry
     */
    'fillArea'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IMagickGeometry
     */
    'greater'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IMagickGeometry
     */
    'height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IMagickGeometry
     */
    'ignoreAspectRatio'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IMagickGeometry
     */
    'isPercentage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IMagickGeometry
     */
    'less'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IMagickGeometry
     */
    'limitPixels'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IMagickGeometry
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof IMagickGeometry
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof IMagickGeometry
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface IPRestriction
 */
export interface IPRestriction {
    /**
     * 
     * @type {string}
     * @memberof IPRestriction
     */
    'ip'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IPRestriction
     */
    'forAdmin'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IPRestriction
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof IPRestriction
     */
    'tenantId'?: number;
}
/**
 * 
 * @export
 * @interface IPRestrictionArrayWrapper
 */
export interface IPRestrictionArrayWrapper {
    /**
     * 
     * @type {Array<IPRestriction>}
     * @memberof IPRestrictionArrayWrapper
     */
    'response'?: Array<IPRestriction>;
    /**
     * 
     * @type {number}
     * @memberof IPRestrictionArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof IPRestrictionArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof IPRestrictionArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof IPRestrictionArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface IPRestrictionsSettings
 */
export interface IPRestrictionsSettings {
    /**
     * 
     * @type {boolean}
     * @memberof IPRestrictionsSettings
     */
    'enable'?: boolean;
}
/**
 * 
 * @export
 * @interface IPRestrictionsSettingsWrapper
 */
export interface IPRestrictionsSettingsWrapper {
    /**
     * 
     * @type {IPRestrictionsSettings}
     * @memberof IPRestrictionsSettingsWrapper
     */
    'response'?: IPRestrictionsSettings;
    /**
     * 
     * @type {number}
     * @memberof IPRestrictionsSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof IPRestrictionsSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof IPRestrictionsSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof IPRestrictionsSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface InfoConfigDto
 */
export interface InfoConfigDto {
    /**
     * Favorite
     * @type {boolean}
     * @memberof InfoConfigDto
     */
    'favorite'?: boolean | null;
    /**
     * Folder
     * @type {string}
     * @memberof InfoConfigDto
     */
    'folder'?: string | null;
    /**
     * Owner
     * @type {string}
     * @memberof InfoConfigDto
     */
    'owner'?: string | null;
    /**
     * Sharing settings
     * @type {Array<AceShortWrapper>}
     * @memberof InfoConfigDto
     */
    'sharingSettings'?: Array<AceShortWrapper> | null;
    /**
     * 
     * @type {EditorType}
     * @memberof InfoConfigDto
     */
    'type'?: EditorType;
    /**
     * Uploaded
     * @type {string}
     * @memberof InfoConfigDto
     */
    'uploaded'?: string | null;
}


/**
 * 
 * @export
 * @interface Int64Wrapper
 */
export interface Int64Wrapper {
    /**
     * 
     * @type {number}
     * @memberof Int64Wrapper
     */
    'response'?: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Wrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof Int64Wrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof Int64Wrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Wrapper
     */
    'statusCode'?: number;
}
/**
 * Request parameters for inviting users
 * @export
 * @interface InviteUsersRequestDto
 */
export interface InviteUsersRequestDto {
    /**
     * List of user invitations
     * @type {Array<UserInvitationRequestDto>}
     * @memberof InviteUsersRequestDto
     */
    'invitations': Array<UserInvitationRequestDto>;
    /**
     * Culture
     * @type {string}
     * @memberof InviteUsersRequestDto
     */
    'culture'?: string | null;
}
/**
 * 
 * @export
 * @interface IpRestrictionBase
 */
export interface IpRestrictionBase {
    /**
     * 
     * @type {string}
     * @memberof IpRestrictionBase
     */
    'ip'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IpRestrictionBase
     */
    'forAdmin'?: boolean;
}
/**
 * New IP restriction settings
 * @export
 * @interface IpRestrictionsDto
 */
export interface IpRestrictionsDto {
    /**
     * List of IP addresses
     * @type {Array<IpRestrictionBase>}
     * @memberof IpRestrictionsDto
     */
    'ipRestrictions'?: Array<IpRestrictionBase> | null;
    /**
     * Enables IP restrictions or not
     * @type {boolean}
     * @memberof IpRestrictionsDto
     */
    'enable'?: boolean | null;
}
/**
 * 
 * @export
 * @interface IpRestrictionsWrapper
 */
export interface IpRestrictionsWrapper {
    /**
     * 
     * @type {IpRestrictionsDto}
     * @memberof IpRestrictionsWrapper
     */
    'response'?: IpRestrictionsDto;
    /**
     * 
     * @type {number}
     * @memberof IpRestrictionsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof IpRestrictionsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof IpRestrictionsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof IpRestrictionsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface IsDefaultWhiteLabelLogosArrayWrapper
 */
export interface IsDefaultWhiteLabelLogosArrayWrapper {
    /**
     * 
     * @type {Array<IsDefaultWhiteLabelLogosDto>}
     * @memberof IsDefaultWhiteLabelLogosArrayWrapper
     */
    'response'?: Array<IsDefaultWhiteLabelLogosDto>;
    /**
     * 
     * @type {number}
     * @memberof IsDefaultWhiteLabelLogosArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof IsDefaultWhiteLabelLogosArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof IsDefaultWhiteLabelLogosArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof IsDefaultWhiteLabelLogosArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface IsDefaultWhiteLabelLogosDto
 */
export interface IsDefaultWhiteLabelLogosDto {
    /**
     * White label logo name
     * @type {string}
     * @memberof IsDefaultWhiteLabelLogosDto
     */
    'name'?: string | null;
    /**
     * Specifies if the white label logo is default or not
     * @type {boolean}
     * @memberof IsDefaultWhiteLabelLogosDto
     */
    'default'?: boolean;
}
/**
 * 
 * @export
 * @interface IsDefaultWhiteLabelLogosWrapper
 */
export interface IsDefaultWhiteLabelLogosWrapper {
    /**
     * 
     * @type {IsDefaultWhiteLabelLogosDto}
     * @memberof IsDefaultWhiteLabelLogosWrapper
     */
    'response'?: IsDefaultWhiteLabelLogosDto;
    /**
     * 
     * @type {number}
     * @memberof IsDefaultWhiteLabelLogosWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof IsDefaultWhiteLabelLogosWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof IsDefaultWhiteLabelLogosWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof IsDefaultWhiteLabelLogosWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface ItemKeyValuePairObjectObject
 */
export interface ItemKeyValuePairObjectObject {
    /**
     * 
     * @type {any}
     * @memberof ItemKeyValuePairObjectObject
     */
    'key'?: any | null;
    /**
     * 
     * @type {any}
     * @memberof ItemKeyValuePairObjectObject
     */
    'value'?: any | null;
}
/**
 * 
 * @export
 * @interface ItemKeyValuePairStringBoolean
 */
export interface ItemKeyValuePairStringBoolean {
    /**
     * 
     * @type {string}
     * @memberof ItemKeyValuePairStringBoolean
     */
    'key'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ItemKeyValuePairStringBoolean
     */
    'value'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemKeyValuePairStringLogoRequestsDto
 */
export interface ItemKeyValuePairStringLogoRequestsDto {
    /**
     * 
     * @type {string}
     * @memberof ItemKeyValuePairStringLogoRequestsDto
     */
    'key'?: string | null;
    /**
     * 
     * @type {LogoRequestsDto}
     * @memberof ItemKeyValuePairStringLogoRequestsDto
     */
    'value'?: LogoRequestsDto;
}
/**
 * 
 * @export
 * @interface ItemKeyValuePairStringString
 */
export interface ItemKeyValuePairStringString {
    /**
     * 
     * @type {string}
     * @memberof ItemKeyValuePairStringString
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemKeyValuePairStringString
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface KeyValuePairBooleanString
 */
export interface KeyValuePairBooleanString {
    /**
     * 
     * @type {boolean}
     * @memberof KeyValuePairBooleanString
     */
    'key'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KeyValuePairBooleanString
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface KeyValuePairBooleanStringWrapper
 */
export interface KeyValuePairBooleanStringWrapper {
    /**
     * 
     * @type {KeyValuePairBooleanString}
     * @memberof KeyValuePairBooleanStringWrapper
     */
    'response'?: KeyValuePairBooleanString;
    /**
     * 
     * @type {number}
     * @memberof KeyValuePairBooleanStringWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof KeyValuePairBooleanStringWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof KeyValuePairBooleanStringWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof KeyValuePairBooleanStringWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface KeyValuePairStringStringValues
 */
export interface KeyValuePairStringStringValues {
    /**
     * 
     * @type {string}
     * @memberof KeyValuePairStringStringValues
     */
    'key'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof KeyValuePairStringStringValues
     */
    'value'?: Array<string>;
}
/**
 * Request parameters for linking accounts
 * @export
 * @interface LinkAccountRequestDto
 */
export interface LinkAccountRequestDto {
    /**
     * Third-party profile in the serialized format
     * @type {string}
     * @memberof LinkAccountRequestDto
     */
    'serializedProfile'?: string | null;
}
/**
 * Defines the types of sharing links available
 * @export
 * @enum {number}
 */

export const LinkType = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type LinkType = typeof LinkType[keyof typeof LinkType];


/**
 * Parameters for locking a file
 * @export
 * @interface LockFileParameters
 */
export interface LockFileParameters {
    /**
     * Specifies whether to lock a file or not
     * @type {boolean}
     * @memberof LockFileParameters
     */
    'lockFile'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginEventArrayWrapper
 */
export interface LoginEventArrayWrapper {
    /**
     * 
     * @type {Array<LoginEventDto>}
     * @memberof LoginEventArrayWrapper
     */
    'response'?: Array<LoginEventDto>;
    /**
     * 
     * @type {number}
     * @memberof LoginEventArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof LoginEventArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof LoginEventArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoginEventArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface LoginEventDto
 */
export interface LoginEventDto {
    /**
     * ID
     * @type {number}
     * @memberof LoginEventDto
     */
    'id'?: number;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof LoginEventDto
     */
    'date'?: ApiDateTime;
    /**
     * User
     * @type {string}
     * @memberof LoginEventDto
     */
    'user'?: string | null;
    /**
     * User ID
     * @type {string}
     * @memberof LoginEventDto
     */
    'userId'?: string;
    /**
     * Login
     * @type {string}
     * @memberof LoginEventDto
     */
    'login'?: string | null;
    /**
     * Action
     * @type {string}
     * @memberof LoginEventDto
     */
    'action'?: string | null;
    /**
     * 
     * @type {MessageAction}
     * @memberof LoginEventDto
     */
    'actionId'?: MessageAction;
    /**
     * IP
     * @type {string}
     * @memberof LoginEventDto
     */
    'ip'?: string | null;
    /**
     * Country
     * @type {string}
     * @memberof LoginEventDto
     */
    'country'?: string | null;
    /**
     * City
     * @type {string}
     * @memberof LoginEventDto
     */
    'city'?: string | null;
    /**
     * Browser
     * @type {string}
     * @memberof LoginEventDto
     */
    'browser'?: string | null;
    /**
     * Platform
     * @type {string}
     * @memberof LoginEventDto
     */
    'platform'?: string | null;
    /**
     * Page
     * @type {string}
     * @memberof LoginEventDto
     */
    'page'?: string | null;
}


/**
 * 
 * @export
 * @interface LoginSettingsDto
 */
export interface LoginSettingsDto {
    /**
     * Maximum number of the user attempts to log in
     * @type {number}
     * @memberof LoginSettingsDto
     */
    'attemptCount'?: number;
    /**
     * The time for which the user will be blocked after unsuccessful login attempts
     * @type {number}
     * @memberof LoginSettingsDto
     */
    'blockTime'?: number;
    /**
     * The time to wait for a response from the server
     * @type {number}
     * @memberof LoginSettingsDto
     */
    'checkPeriod'?: number;
    /**
     * Specifies if these settings are default or not
     * @type {boolean}
     * @memberof LoginSettingsDto
     */
    'isDefault'?: boolean;
}
/**
 * Login settings request parameters
 * @export
 * @interface LoginSettingsRequestDto
 */
export interface LoginSettingsRequestDto {
    /**
     * Maximum number of the user attempts to log in
     * @type {number}
     * @memberof LoginSettingsRequestDto
     */
    'attemptCount'?: number;
    /**
     * The duration of the account suspension for unsuccessful login attempts
     * @type {number}
     * @memberof LoginSettingsRequestDto
     */
    'blockTime'?: number;
    /**
     * Expected server response time
     * @type {number}
     * @memberof LoginSettingsRequestDto
     */
    'checkPeriod'?: number;
}
/**
 * 
 * @export
 * @interface LoginSettingsWrapper
 */
export interface LoginSettingsWrapper {
    /**
     * 
     * @type {LoginSettingsDto}
     * @memberof LoginSettingsWrapper
     */
    'response'?: LoginSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof LoginSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof LoginSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof LoginSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoginSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface Logo
 */
export interface Logo {
    /**
     * Original
     * @type {string}
     * @memberof Logo
     */
    'original'?: string | null;
    /**
     * Large
     * @type {string}
     * @memberof Logo
     */
    'large'?: string | null;
    /**
     * Medium
     * @type {string}
     * @memberof Logo
     */
    'medium'?: string | null;
    /**
     * Small
     * @type {string}
     * @memberof Logo
     */
    'small'?: string | null;
    /**
     * Color
     * @type {string}
     * @memberof Logo
     */
    'color'?: string | null;
    /**
     * 
     * @type {LogoCover}
     * @memberof Logo
     */
    'cover'?: LogoCover;
}
/**
 * 
 * @export
 * @interface LogoConfigDto
 */
export interface LogoConfigDto {
    /**
     * Image
     * @type {string}
     * @memberof LogoConfigDto
     */
    'image'?: string | null;
    /**
     * Image dark
     * @type {string}
     * @memberof LogoConfigDto
     */
    'imageDark'?: string | null;
    /**
     * Image embedded
     * @type {string}
     * @memberof LogoConfigDto
     */
    'imageEmbedded'?: string | null;
    /**
     * Url
     * @type {string}
     * @memberof LogoConfigDto
     */
    'url'?: string | null;
    /**
     * Visible
     * @type {boolean}
     * @memberof LogoConfigDto
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface LogoCover
 */
export interface LogoCover {
    /**
     * 
     * @type {string}
     * @memberof LogoCover
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogoCover
     */
    'data'?: string | null;
}
/**
 * Logo request parameters
 * @export
 * @interface LogoRequest
 */
export interface LogoRequest {
    /**
     * The path to the temporary image file
     * @type {string}
     * @memberof LogoRequest
     */
    'tmpFile'?: string | null;
    /**
     * The X coordinate of the rectangle starting point
     * @type {number}
     * @memberof LogoRequest
     */
    'x'?: number;
    /**
     * The Y coordinate of the rectangle starting point
     * @type {number}
     * @memberof LogoRequest
     */
    'y'?: number;
    /**
     * The rectangle width
     * @type {number}
     * @memberof LogoRequest
     */
    'width'?: number;
    /**
     * The rectangle height
     * @type {number}
     * @memberof LogoRequest
     */
    'height'?: number;
}
/**
 * 
 * @export
 * @interface LogoRequestsDto
 */
export interface LogoRequestsDto {
    /**
     * Light theme logo
     * @type {string}
     * @memberof LogoRequestsDto
     */
    'light'?: string | null;
    /**
     * Dark theme logo
     * @type {string}
     * @memberof LogoRequestsDto
     */
    'dark'?: string | null;
}
/**
 * Request parameters for mail domain settings
 * @export
 * @interface MailDomainSettingsRequestsDto
 */
export interface MailDomainSettingsRequestsDto {
    /**
     * 
     * @type {TenantTrustedDomainsType}
     * @memberof MailDomainSettingsRequestsDto
     */
    'type'?: TenantTrustedDomainsType;
    /**
     * List of trusted domains
     * @type {Array<string>}
     * @memberof MailDomainSettingsRequestsDto
     */
    'domains'?: Array<string> | null;
    /**
     * Invites as a user or not
     * @type {boolean}
     * @memberof MailDomainSettingsRequestsDto
     */
    'inviteUsersAsVisitors'?: boolean;
}


/**
 * Request parameters for setting new password
 * @export
 * @interface MemberBaseRequestDto
 */
export interface MemberBaseRequestDto {
    /**
     * Password
     * @type {string}
     * @memberof MemberBaseRequestDto
     */
    'password'?: string | null;
    /**
     * Password hash
     * @type {string}
     * @memberof MemberBaseRequestDto
     */
    'passwordHash'?: string | null;
    /**
     * Email
     * @type {string}
     * @memberof MemberBaseRequestDto
     */
    'email'?: string | null;
}
/**
 * Member request parameters
 * @export
 * @interface MemberRequestDto
 */
export interface MemberRequestDto {
    /**
     * Password
     * @type {string}
     * @memberof MemberRequestDto
     */
    'password'?: string | null;
    /**
     * Password hash
     * @type {string}
     * @memberof MemberRequestDto
     */
    'passwordHash'?: string | null;
    /**
     * Email
     * @type {string}
     * @memberof MemberRequestDto
     */
    'email'?: string | null;
    /**
     * 
     * @type {EmployeeType}
     * @memberof MemberRequestDto
     */
    'type'?: EmployeeType;
    /**
     * Specifies if this is a guest or a user
     * @type {boolean}
     * @memberof MemberRequestDto
     */
    'isUser'?: boolean | null;
    /**
     * First name
     * @type {string}
     * @memberof MemberRequestDto
     */
    'firstName'?: string | null;
    /**
     * Last name
     * @type {string}
     * @memberof MemberRequestDto
     */
    'lastName'?: string | null;
    /**
     * List of user departments
     * @type {Array<string>}
     * @memberof MemberRequestDto
     */
    'department'?: Array<string> | null;
    /**
     * Title
     * @type {string}
     * @memberof MemberRequestDto
     */
    'title'?: string | null;
    /**
     * Location
     * @type {string}
     * @memberof MemberRequestDto
     */
    'location'?: string | null;
    /**
     * 
     * @type {SexEnum}
     * @memberof MemberRequestDto
     */
    'sex'?: SexEnum;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof MemberRequestDto
     */
    'birthday'?: ApiDateTime;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof MemberRequestDto
     */
    'worksfrom'?: ApiDateTime;
    /**
     * Comment
     * @type {string}
     * @memberof MemberRequestDto
     */
    'comment'?: string | null;
    /**
     * List of user contacts
     * @type {Array<Contact>}
     * @memberof MemberRequestDto
     */
    'contacts'?: Array<Contact> | null;
    /**
     * Avatar photo URL
     * @type {string}
     * @memberof MemberRequestDto
     */
    'files'?: string | null;
    /**
     * Specifies if the user is added via the invitation link or not
     * @type {boolean}
     * @memberof MemberRequestDto
     */
    'fromInviteLink'?: boolean;
    /**
     * Key
     * @type {string}
     * @memberof MemberRequestDto
     */
    'key'?: string | null;
    /**
     * Language
     * @type {string}
     * @memberof MemberRequestDto
     */
    'cultureName'?: string | null;
    /**
     * Target
     * @type {string}
     * @memberof MemberRequestDto
     */
    'target'?: string;
    /**
     * Spam
     * @type {boolean}
     * @memberof MemberRequestDto
     */
    'spam'?: boolean | null;
}


/**
 * Group request parameters
 * @export
 * @interface MembersRequest
 */
export interface MembersRequest {
    /**
     * List of group member IDs
     * @type {Array<string>}
     * @memberof MembersRequest
     */
    'members'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface MentionWrapper
 */
export interface MentionWrapper {
    /**
     * 
     * @type {UserInfo}
     * @memberof MentionWrapper
     */
    'user'?: UserInfo;
    /**
     * User email
     * @type {string}
     * @memberof MentionWrapper
     */
    'email'?: string | null;
    /**
     * User ID
     * @type {string}
     * @memberof MentionWrapper
     */
    'id'?: string | null;
    /**
     * User image
     * @type {string}
     * @memberof MentionWrapper
     */
    'image'?: string | null;
    /**
     * Specifies if the user has the access to the file or not
     * @type {boolean}
     * @memberof MentionWrapper
     */
    'hasAccess'?: boolean;
    /**
     * User display name
     * @type {string}
     * @memberof MentionWrapper
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface MentionWrapperArrayWrapper
 */
export interface MentionWrapperArrayWrapper {
    /**
     * 
     * @type {Array<MentionWrapper>}
     * @memberof MentionWrapperArrayWrapper
     */
    'response'?: Array<MentionWrapper>;
    /**
     * 
     * @type {number}
     * @memberof MentionWrapperArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof MentionWrapperArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof MentionWrapperArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof MentionWrapperArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * [1000 - Login success, 1001 - Login success via social account, 1002 - Login fail invalid combination, 1003 - Login fail social account not found, 1004 - Login fail disabled profile, 1005 - Login fail, 1006 - Logout, 1007 - Login success via sms, 1008 - Login fail via sms, 1009 - Login fail ip security, 1010 - Login success via api, 1011 - Login success via social app, 1012 - Login success via api sms, 1013 - Login fail via api, 1014 - Login fail via api sms, 1015 - Login success via SSO, 1016 - Session started, 1017 - Session completed, 1018 - Login fail via SSO, 1019 - Login success via api social account, 1020 - Login fail via api social account, 1021 - Login succes via tfa app, 1022 - Login fail via Tfa app, 1023 - Login fail brute force, 1024 - Login success via api tfa, 1025 - Login fail via api tfa, 1026 - Login fail recaptcha, 4000 - User created, 4001 - Guest created, 4002 - User created via invite, 4003 - Guest created via invite, 4004 - User activated, 4005 - Guest activated, 4006 - User updated, 4007 - User updated language, 4008 - User added avatar, 4009 - User deleted avatar, 4010 - User updated avatar thumbnails, 4011 - User linked social account, 4012 - User unlinked social account, 4013 - User sent activation instructions, 4014 - User sent email change instructions, 4015 - User sent password change instructions, 4016 - User sent delete instructions, 4017 - User updated password, 4018 - User deleted, 4019 - Users updated type, 4020 - Users updated status, 4021 - Users sent activation instructions, 4022 - Users deleted, 4023 - Sent invite instructions, 4024 - User imported, 4025 - Guest imported, 4026 - Group created, 4027 - Group updated, 4028 - Group deleted, 4029 - User updated mobile number, 4030 - User data reassigns, 4031 - User data removing, 4032 - User connected tfa app, 4033 - User disconnected tfa app, 4034 - User logout active connections, 4035 - User logout active connection, 4036 - User logout active connections for user, 4037 - Send join invite, 5000 - File created, 5001 - File renamed, 5002 - File updated, 5003 - File created version, 5004 - File deleted version, 5005 - File updated revision comment, 5006 - File locked, 5007 - File unlocked, 5008 - File updated access, 5009 - File downloaded, 5010 - File downloaded as, 5011 - File uploaded, 5012 - File imported, 5013 - File copied, 5014 - File copied with overwriting, 5015 - File moved, 5016 - File moved with overwriting, 5017 - File moved to trash, 5018 - File deleted, 5019 - Folder created, 5020 - Folder renamed, 5021 - Folder updated access, 5022 - Folder copied, 5023 - Folder copied with overwriting, 5024 - Folder moved, 5025 - Folder moved with overwriting, 5026 - Folder moved to trash, 5027 - Folder deleted, 5028 - ThirdParty created, 5029 - ThirdParty updated, 5030 - ThirdParty deleted, 5031 - Documents ThirdParty settings updated, 5032 - Documents overwriting settings updated, 5033 - Documents uploading formats settings updated, 5034 - User file updated, 5035 - File converted, 5036 - File send access link, 5037 - Document service location setting, 5038 - Authorization keys setting, 5039 - Full text search setting, 5040 - Start transfer setting, 5041 - Start backup setting, 5042 - License key uploaded, 5043 - File change owner, 5044 - File restore version, 5045 - Document send to sign, 5046 - Document sign complete, 5047 - User updated email, 5048 - Documents store forcesave, 5049 - Documents forcesave, 5050 - Start storage encryption, 5051 - Privacy room enable, 5052 - Privacy room disable, 5053 - Start storage decryption, 5054 - File opened for change, 5055 - File marked as favorite, 5056 - File removed from favorite, 5057 - Folder downloaded, 5058 - File removed from list, 5059 - Folder removed from list, 5060 - File external link access updated, 5061 - Trash emptied, 5062 - File revision downloaded, 5063 - File marked as read, 5064 - File readed, 5065 - Folder marked as read, 5066 - Folder updated access for, 5068 - File updated access for, 5069 - Documents external share settings updated, 5070 - Room created, 5071 - Room renamed, 5072 - Room archived, 5073 - Room unarchived, 5074 - Room deleted, 5075 - Room update access for user, 5076 - Tag created, 5077 - Tags deleted, 5078 - Added room tags, 5079 - Deleted room tags, 5080 - Room logo created, 5081 - Room logo deleted, 5082 - Room invitation link updated, 5083 - Documents keep new file name settings updated, 5084 - Room remove user, 5085 - Room create user, 5086 - Room invitation link created, 5087 - Room invitation link deleted, 5088 - Room external link created, 5089 - Room external link updated, 5090 - Room external link deleted, 5091 - File external link created, 5092 - File external link updated, 5093 - File external link deleted, 5094 - Room group added, 5095 - Room update access for group, 5096 - Room group remove, 5097 - Room external link revoked, 5098 - Room external link renamed, 5099 - File uploaded with overwriting, 5100 - Room copied, 5101 - Documents display file extension updated, 5102 - Room color changed, 5103 - Room cover changed, 5104 - Room indexing changed, 5105 - Room deny download changed, 5106 - Room index export saved, 5107 - Folder index changed, 5108 - Folder index reordered, 5109 - Room deny download enabled, 5110 - Room deny download disabled, 5111 - File index changed, 5112 - Room watermark set, 5113 - Room watermark disabled, 5114 - Room index export saved, 5115 - Room indexing disabled, 5116 - Room life time set, 5117 - Room life time disabled, 5118 - Room invite resend, 5119 - File version deleted, 6000 - Language settings updated, 6001 - Time zone settings updated, 6002 - Dns settings updated, 6003 - Trusted mail domain settings updated, 6004 - Password strength settings updated, 6005 - Two factor authentication settings updated, 6006 - Administrator message settings updated, 6007 - Default start page settings updated, 6008 - Products list updated, 6009 - Administrator added, 6010 - Administrator opened full access, 6011 - Administrator deleted, 6012 - Users opened product access, 6013 - Groups opened product access, 6014 - Product access opened, 6015 - Product access restricted, 6016 - Product added administrator, 6017 - Product deleted administrator, 6018 - Greeting settings updated, 6019 - Team template changed, 6020 - Color theme changed, 6021 - Owner sent change owner instructions, 6022 - Owner updated, 6023 - Owner sent portal deactivation instructions, 6024 - Owner sent portal delete instructions, 6025 - Portal deactivated, 6026 - Portal deleted, 6027 - Login history report downloaded, 6028 - Audit trail report downloaded, 6029 - SSO enabled, 6030 - SSO disabled, 6031 - Portal access settings updated, 6032 - Cookie settings updated, 6033 - Mail service settings updated, 6034 - Custom navigation settings updated, 6035 - Audit settings updated, 6036 - Two factor authentication disabled, 6037 - Two factor authentication enabled by sms, 6038 - Two factor authentication enabled by tfa app, 6039 - Portal renamed, 6040 - Quota per room changed, 6041 - Quota per room disabled, 6042 - Quota per user changed, 6043 - Quota per user disabled, 6044 - Quota per portal changed, 6045 - Quota per portal disabled, 6046 - Form submit, 6047 - Form opened for filling, 6048 - Custom quota per room default, 6049 - Custom quota per room changed, 6050 - Custom quota per room disabled, 6051 - Custom quota per user default, 6052 - Custom quota per user changed, 6053 - Custom quota per user disabled, 7000 - Contact admin mail sent, 7001 - Room invite link used, 7002 - User created and added to room, 7003 - Guest created and added to room, 7004 - Contact sales mail sent, 9901 - Create client, 9902 - Update client, 9903 - Regenerate secret, 9904 - Delete client, 9905 - Change client activation, 9906 - Change client visibility, 9907 - Revoke user client, 9908 - Generate authorization code token, 9909 - Generate personal access token, -1 - None]
 * @export
 * @enum {number}
 */

export const MessageAction = {
    NUMBER_1000: 1000,
    NUMBER_1001: 1001,
    NUMBER_1002: 1002,
    NUMBER_1003: 1003,
    NUMBER_1004: 1004,
    NUMBER_1005: 1005,
    NUMBER_1006: 1006,
    NUMBER_1007: 1007,
    NUMBER_1008: 1008,
    NUMBER_1009: 1009,
    NUMBER_1010: 1010,
    NUMBER_1011: 1011,
    NUMBER_1012: 1012,
    NUMBER_1013: 1013,
    NUMBER_1014: 1014,
    NUMBER_1015: 1015,
    NUMBER_1016: 1016,
    NUMBER_1017: 1017,
    NUMBER_1018: 1018,
    NUMBER_1019: 1019,
    NUMBER_1020: 1020,
    NUMBER_1021: 1021,
    NUMBER_1022: 1022,
    NUMBER_1023: 1023,
    NUMBER_1024: 1024,
    NUMBER_1025: 1025,
    NUMBER_1026: 1026,
    NUMBER_4000: 4000,
    NUMBER_4001: 4001,
    NUMBER_4002: 4002,
    NUMBER_4003: 4003,
    NUMBER_4004: 4004,
    NUMBER_4005: 4005,
    NUMBER_4006: 4006,
    NUMBER_4007: 4007,
    NUMBER_4008: 4008,
    NUMBER_4009: 4009,
    NUMBER_4010: 4010,
    NUMBER_4011: 4011,
    NUMBER_4012: 4012,
    NUMBER_4013: 4013,
    NUMBER_4014: 4014,
    NUMBER_4015: 4015,
    NUMBER_4016: 4016,
    NUMBER_4017: 4017,
    NUMBER_4018: 4018,
    NUMBER_4019: 4019,
    NUMBER_4020: 4020,
    NUMBER_4021: 4021,
    NUMBER_4022: 4022,
    NUMBER_4023: 4023,
    NUMBER_4024: 4024,
    NUMBER_4025: 4025,
    NUMBER_4026: 4026,
    NUMBER_4027: 4027,
    NUMBER_4028: 4028,
    NUMBER_4029: 4029,
    NUMBER_4030: 4030,
    NUMBER_4031: 4031,
    NUMBER_4032: 4032,
    NUMBER_4033: 4033,
    NUMBER_4034: 4034,
    NUMBER_4035: 4035,
    NUMBER_4036: 4036,
    NUMBER_4037: 4037,
    NUMBER_5000: 5000,
    NUMBER_5001: 5001,
    NUMBER_5002: 5002,
    NUMBER_5003: 5003,
    NUMBER_5004: 5004,
    NUMBER_5005: 5005,
    NUMBER_5006: 5006,
    NUMBER_5007: 5007,
    NUMBER_5008: 5008,
    NUMBER_5009: 5009,
    NUMBER_5010: 5010,
    NUMBER_5011: 5011,
    NUMBER_5012: 5012,
    NUMBER_5013: 5013,
    NUMBER_5014: 5014,
    NUMBER_5015: 5015,
    NUMBER_5016: 5016,
    NUMBER_5017: 5017,
    NUMBER_5018: 5018,
    NUMBER_5019: 5019,
    NUMBER_5020: 5020,
    NUMBER_5021: 5021,
    NUMBER_5022: 5022,
    NUMBER_5023: 5023,
    NUMBER_5024: 5024,
    NUMBER_5025: 5025,
    NUMBER_5026: 5026,
    NUMBER_5027: 5027,
    NUMBER_5028: 5028,
    NUMBER_5029: 5029,
    NUMBER_5030: 5030,
    NUMBER_5031: 5031,
    NUMBER_5032: 5032,
    NUMBER_5033: 5033,
    NUMBER_5034: 5034,
    NUMBER_5035: 5035,
    NUMBER_5036: 5036,
    NUMBER_5037: 5037,
    NUMBER_5038: 5038,
    NUMBER_5039: 5039,
    NUMBER_5040: 5040,
    NUMBER_5041: 5041,
    NUMBER_5042: 5042,
    NUMBER_5043: 5043,
    NUMBER_5044: 5044,
    NUMBER_5045: 5045,
    NUMBER_5046: 5046,
    NUMBER_5047: 5047,
    NUMBER_5048: 5048,
    NUMBER_5049: 5049,
    NUMBER_5050: 5050,
    NUMBER_5051: 5051,
    NUMBER_5052: 5052,
    NUMBER_5053: 5053,
    NUMBER_5054: 5054,
    NUMBER_5055: 5055,
    NUMBER_5056: 5056,
    NUMBER_5057: 5057,
    NUMBER_5058: 5058,
    NUMBER_5059: 5059,
    NUMBER_5060: 5060,
    NUMBER_5061: 5061,
    NUMBER_5062: 5062,
    NUMBER_5063: 5063,
    NUMBER_5064: 5064,
    NUMBER_5065: 5065,
    NUMBER_5066: 5066,
    NUMBER_5068: 5068,
    NUMBER_5069: 5069,
    NUMBER_5070: 5070,
    NUMBER_5071: 5071,
    NUMBER_5072: 5072,
    NUMBER_5073: 5073,
    NUMBER_5074: 5074,
    NUMBER_5075: 5075,
    NUMBER_5076: 5076,
    NUMBER_5077: 5077,
    NUMBER_5078: 5078,
    NUMBER_5079: 5079,
    NUMBER_5080: 5080,
    NUMBER_5081: 5081,
    NUMBER_5082: 5082,
    NUMBER_5083: 5083,
    NUMBER_5084: 5084,
    NUMBER_5085: 5085,
    NUMBER_5086: 5086,
    NUMBER_5087: 5087,
    NUMBER_5088: 5088,
    NUMBER_5089: 5089,
    NUMBER_5090: 5090,
    NUMBER_5091: 5091,
    NUMBER_5092: 5092,
    NUMBER_5093: 5093,
    NUMBER_5094: 5094,
    NUMBER_5095: 5095,
    NUMBER_5096: 5096,
    NUMBER_5097: 5097,
    NUMBER_5098: 5098,
    NUMBER_5099: 5099,
    NUMBER_5100: 5100,
    NUMBER_5101: 5101,
    NUMBER_5102: 5102,
    NUMBER_5103: 5103,
    NUMBER_5104: 5104,
    NUMBER_5105: 5105,
    NUMBER_5106: 5106,
    NUMBER_5107: 5107,
    NUMBER_5108: 5108,
    NUMBER_5109: 5109,
    NUMBER_5110: 5110,
    NUMBER_5111: 5111,
    NUMBER_5112: 5112,
    NUMBER_5113: 5113,
    NUMBER_5114: 5114,
    NUMBER_5115: 5115,
    NUMBER_5116: 5116,
    NUMBER_5117: 5117,
    NUMBER_5118: 5118,
    NUMBER_5119: 5119,
    NUMBER_6000: 6000,
    NUMBER_6001: 6001,
    NUMBER_6002: 6002,
    NUMBER_6003: 6003,
    NUMBER_6004: 6004,
    NUMBER_6005: 6005,
    NUMBER_6006: 6006,
    NUMBER_6007: 6007,
    NUMBER_6008: 6008,
    NUMBER_6009: 6009,
    NUMBER_6010: 6010,
    NUMBER_6011: 6011,
    NUMBER_6012: 6012,
    NUMBER_6013: 6013,
    NUMBER_6014: 6014,
    NUMBER_6015: 6015,
    NUMBER_6016: 6016,
    NUMBER_6017: 6017,
    NUMBER_6018: 6018,
    NUMBER_6019: 6019,
    NUMBER_6020: 6020,
    NUMBER_6021: 6021,
    NUMBER_6022: 6022,
    NUMBER_6023: 6023,
    NUMBER_6024: 6024,
    NUMBER_6025: 6025,
    NUMBER_6026: 6026,
    NUMBER_6027: 6027,
    NUMBER_6028: 6028,
    NUMBER_6029: 6029,
    NUMBER_6030: 6030,
    NUMBER_6031: 6031,
    NUMBER_6032: 6032,
    NUMBER_6033: 6033,
    NUMBER_6034: 6034,
    NUMBER_6035: 6035,
    NUMBER_6036: 6036,
    NUMBER_6037: 6037,
    NUMBER_6038: 6038,
    NUMBER_6039: 6039,
    NUMBER_6040: 6040,
    NUMBER_6041: 6041,
    NUMBER_6042: 6042,
    NUMBER_6043: 6043,
    NUMBER_6044: 6044,
    NUMBER_6045: 6045,
    NUMBER_6046: 6046,
    NUMBER_6047: 6047,
    NUMBER_6048: 6048,
    NUMBER_6049: 6049,
    NUMBER_6050: 6050,
    NUMBER_6051: 6051,
    NUMBER_6052: 6052,
    NUMBER_6053: 6053,
    NUMBER_7000: 7000,
    NUMBER_7001: 7001,
    NUMBER_7002: 7002,
    NUMBER_7003: 7003,
    NUMBER_7004: 7004,
    NUMBER_9901: 9901,
    NUMBER_9902: 9902,
    NUMBER_9903: 9903,
    NUMBER_9904: 9904,
    NUMBER_9905: 9905,
    NUMBER_9906: 9906,
    NUMBER_9907: 9907,
    NUMBER_9908: 9908,
    NUMBER_9909: 9909,
    NUMBER_MINUS_1: -1
} as const;

export type MessageAction = typeof MessageAction[keyof typeof MessageAction];


/**
 * 
 * @export
 * @interface MigratingApiFiles
 */
export interface MigratingApiFiles {
    /**
     * 
     * @type {number}
     * @memberof MigratingApiFiles
     */
    'foldersCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof MigratingApiFiles
     */
    'filesCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof MigratingApiFiles
     */
    'bytesTotal'?: number;
}
/**
 * 
 * @export
 * @interface MigratingApiGroup
 */
export interface MigratingApiGroup {
    /**
     * 
     * @type {boolean}
     * @memberof MigratingApiGroup
     */
    'shouldImport'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MigratingApiGroup
     */
    'groupName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MigratingApiGroup
     */
    'moduleName'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MigratingApiGroup
     */
    'userUidList'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface MigratingApiUser
 */
export interface MigratingApiUser {
    /**
     * 
     * @type {boolean}
     * @memberof MigratingApiUser
     */
    'shouldImport'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MigratingApiUser
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MigratingApiUser
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MigratingApiUser
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MigratingApiUser
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MigratingApiUser
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {EmployeeType}
     * @memberof MigratingApiUser
     */
    'userType'?: EmployeeType;
    /**
     * 
     * @type {MigratingApiFiles}
     * @memberof MigratingApiUser
     */
    'migratingFiles'?: MigratingApiFiles;
}


/**
 * 
 * @export
 * @interface MigrationApiInfo
 */
export interface MigrationApiInfo {
    /**
     * 
     * @type {string}
     * @memberof MigrationApiInfo
     */
    'migratorName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MigrationApiInfo
     */
    'operation'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MigrationApiInfo
     */
    'failedArchives'?: Array<string> | null;
    /**
     * 
     * @type {Array<MigratingApiUser>}
     * @memberof MigrationApiInfo
     */
    'users'?: Array<MigratingApiUser> | null;
    /**
     * 
     * @type {Array<MigratingApiUser>}
     * @memberof MigrationApiInfo
     */
    'withoutEmailUsers'?: Array<MigratingApiUser> | null;
    /**
     * 
     * @type {Array<MigratingApiUser>}
     * @memberof MigrationApiInfo
     */
    'existUsers'?: Array<MigratingApiUser> | null;
    /**
     * 
     * @type {Array<MigratingApiGroup>}
     * @memberof MigrationApiInfo
     */
    'groups'?: Array<MigratingApiGroup> | null;
    /**
     * 
     * @type {boolean}
     * @memberof MigrationApiInfo
     */
    'importPersonalFiles'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrationApiInfo
     */
    'importSharedFiles'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrationApiInfo
     */
    'importSharedFolders'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrationApiInfo
     */
    'importCommonFiles'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrationApiInfo
     */
    'importProjectFiles'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MigrationApiInfo
     */
    'importGroups'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MigrationApiInfo
     */
    'successedUsers'?: number;
    /**
     * 
     * @type {number}
     * @memberof MigrationApiInfo
     */
    'failedUsers'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MigrationApiInfo
     */
    'files'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MigrationApiInfo
     */
    'errors'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface MigrationStatusDto
 */
export interface MigrationStatusDto {
    /**
     * Migration progress
     * @type {number}
     * @memberof MigrationStatusDto
     */
    'progress'?: number;
    /**
     * Migration error
     * @type {string}
     * @memberof MigrationStatusDto
     */
    'error'?: string | null;
    /**
     * 
     * @type {MigrationApiInfo}
     * @memberof MigrationStatusDto
     */
    'parseResult'?: MigrationApiInfo;
    /**
     * Specifies whether the migration is completed
     * @type {boolean}
     * @memberof MigrationStatusDto
     */
    'isCompleted'?: boolean;
}
/**
 * 
 * @export
 * @interface MigrationStatusWrapper
 */
export interface MigrationStatusWrapper {
    /**
     * 
     * @type {MigrationStatusDto}
     * @memberof MigrationStatusWrapper
     */
    'response'?: MigrationStatusDto;
    /**
     * 
     * @type {number}
     * @memberof MigrationStatusWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof MigrationStatusWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof MigrationStatusWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof MigrationStatusWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Not activated, 1 - Activated]
 * @export
 * @enum {number}
 */

export const MobilePhoneActivationStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MobilePhoneActivationStatus = typeof MobilePhoneActivationStatus[keyof typeof MobilePhoneActivationStatus];


/**
 * Mobile phone request parameters
 * @export
 * @interface MobileRequestsDto
 */
export interface MobileRequestsDto {
    /**
     * Mobile phone
     * @type {string}
     * @memberof MobileRequestsDto
     */
    'mobilePhone'?: string | null;
}
/**
 * 
 * @export
 * @interface Module
 */
export interface Module {
    /**
     * ID
     * @type {string}
     * @memberof Module
     */
    'id'?: string;
    /**
     * Product class name
     * @type {string}
     * @memberof Module
     */
    'appName'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof Module
     */
    'title'?: string | null;
    /**
     * Start link
     * @type {string}
     * @memberof Module
     */
    'link'?: string | null;
    /**
     * Icon URL
     * @type {string}
     * @memberof Module
     */
    'iconUrl'?: string | null;
    /**
     * Large image URL
     * @type {string}
     * @memberof Module
     */
    'imageUrl'?: string | null;
    /**
     * Help URL
     * @type {string}
     * @memberof Module
     */
    'helpUrl'?: string | null;
    /**
     * Description
     * @type {string}
     * @memberof Module
     */
    'description'?: string | null;
    /**
     * Specifies if the module is primary or not
     * @type {boolean}
     * @memberof Module
     */
    'isPrimary'?: boolean;
}
/**
 * 
 * @export
 * @interface ModuleArrayWrapper
 */
export interface ModuleArrayWrapper {
    /**
     * 
     * @type {Array<Module>}
     * @memberof ModuleArrayWrapper
     */
    'response'?: Array<Module>;
    /**
     * 
     * @type {number}
     * @memberof ModuleArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ModuleArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ModuleArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - None, 1 - Files, 2 - Folders, 3 - Documents settings, 4 - Companies, 5 - Persons, 6 - Contacts, 7 - Crm tasks, 8 - Opportunities, 9 - Invoices, 10 - Cases, 11 - Common crm settings, 12 - Contacts settings, 13 - Contact types, 14 - Invoice settings, 15 - Other crm settings, 16 - Users, 17 - Groups, 18 - Projects, 19 - Milestones, 20 - Tasks, 21 - Discussions, 22 - Time tracking, 23 - Reports, 24 - Projects settings, 25 - General, 26 - Products, 27 - Rooms, 28 - OAuth]
 * @export
 * @enum {number}
 */

export const ModuleType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15,
    NUMBER_16: 16,
    NUMBER_17: 17,
    NUMBER_18: 18,
    NUMBER_19: 19,
    NUMBER_20: 20,
    NUMBER_21: 21,
    NUMBER_22: 22,
    NUMBER_23: 23,
    NUMBER_24: 24,
    NUMBER_25: 25,
    NUMBER_26: 26,
    NUMBER_27: 27,
    NUMBER_28: 28
} as const;

export type ModuleType = typeof ModuleType[keyof typeof ModuleType];


/**
 * 
 * @export
 * @interface ModuleWrapper
 */
export interface ModuleWrapper {
    /**
     * 
     * @type {Module}
     * @memberof ModuleWrapper
     */
    'response'?: Module;
    /**
     * 
     * @type {number}
     * @memberof ModuleWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ModuleWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ModuleWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface NewItemsDtoFileEntryDto
 */
export interface NewItemsDtoFileEntryDto {
    /**
     * 
     * @type {ApiDateTime}
     * @memberof NewItemsDtoFileEntryDto
     */
    'date'?: ApiDateTime;
    /**
     * Items
     * @type {Array<FileEntryDto>}
     * @memberof NewItemsDtoFileEntryDto
     */
    'items'?: Array<FileEntryDto> | null;
}
/**
 * 
 * @export
 * @interface NewItemsDtoRoomNewItemsDto
 */
export interface NewItemsDtoRoomNewItemsDto {
    /**
     * 
     * @type {ApiDateTime}
     * @memberof NewItemsDtoRoomNewItemsDto
     */
    'date'?: ApiDateTime;
    /**
     * Items
     * @type {Array<RoomNewItemsDto>}
     * @memberof NewItemsDtoRoomNewItemsDto
     */
    'items'?: Array<RoomNewItemsDto> | null;
}
/**
 * 
 * @export
 * @interface NewItemsFileEntryArrayWrapper
 */
export interface NewItemsFileEntryArrayWrapper {
    /**
     * 
     * @type {Array<NewItemsDtoFileEntryDto>}
     * @memberof NewItemsFileEntryArrayWrapper
     */
    'response'?: Array<NewItemsDtoFileEntryDto>;
    /**
     * 
     * @type {number}
     * @memberof NewItemsFileEntryArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof NewItemsFileEntryArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof NewItemsFileEntryArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewItemsFileEntryArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface NewItemsRoomNewItemsArrayWrapper
 */
export interface NewItemsRoomNewItemsArrayWrapper {
    /**
     * 
     * @type {Array<NewItemsDtoRoomNewItemsDto>}
     * @memberof NewItemsRoomNewItemsArrayWrapper
     */
    'response'?: Array<NewItemsDtoRoomNewItemsDto>;
    /**
     * 
     * @type {number}
     * @memberof NewItemsRoomNewItemsArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof NewItemsRoomNewItemsArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof NewItemsRoomNewItemsArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewItemsRoomNewItemsArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface NoContentResult
 */
export interface NoContentResult {
    /**
     * 
     * @type {number}
     * @memberof NoContentResult
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface NoContentResultWrapper
 */
export interface NoContentResultWrapper {
    /**
     * 
     * @type {NoContentResult}
     * @memberof NoContentResultWrapper
     */
    'response'?: NoContentResult;
    /**
     * 
     * @type {number}
     * @memberof NoContentResultWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof NoContentResultWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof NoContentResultWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof NoContentResultWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface NotificationSettingsDto
 */
export interface NotificationSettingsDto {
    /**
     * 
     * @type {NotificationType}
     * @memberof NotificationSettingsDto
     */
    'type'?: NotificationType;
    /**
     * Specifies if the notification type is enabled or not
     * @type {boolean}
     * @memberof NotificationSettingsDto
     */
    'isEnabled'?: boolean;
}


/**
 * Notification settings request parameters
 * @export
 * @interface NotificationSettingsRequestsDto
 */
export interface NotificationSettingsRequestsDto {
    /**
     * 
     * @type {NotificationType}
     * @memberof NotificationSettingsRequestsDto
     */
    'type'?: NotificationType;
    /**
     * Specifies if the notification type is enabled or not
     * @type {boolean}
     * @memberof NotificationSettingsRequestsDto
     */
    'isEnabled'?: boolean;
}


/**
 * 
 * @export
 * @interface NotificationSettingsWrapper
 */
export interface NotificationSettingsWrapper {
    /**
     * 
     * @type {NotificationSettingsDto}
     * @memberof NotificationSettingsWrapper
     */
    'response'?: NotificationSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof NotificationSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof NotificationSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof NotificationSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Badges, 1 - Rooms activity, 2 - Daily feed, 3 - Usefull tips]
 * @export
 * @enum {number}
 */

export const NotificationType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


/**
 * 
 * @export
 * @interface OAuth20Token
 */
export interface OAuth20Token {
    /**
     * 
     * @type {string}
     * @memberof OAuth20Token
     */
    'access_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuth20Token
     */
    'refresh_token'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OAuth20Token
     */
    'expires_in'?: number;
    /**
     * 
     * @type {string}
     * @memberof OAuth20Token
     */
    'client_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuth20Token
     */
    'client_secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuth20Token
     */
    'redirect_uri'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuth20Token
     */
    'timestamp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuth20Token
     */
    'isExpired'?: boolean;
}
/**
 * 
 * @export
 * @interface ObjectArrayWrapper
 */
export interface ObjectArrayWrapper {
    /**
     * 
     * @type {Array<object>}
     * @memberof ObjectArrayWrapper
     */
    'response'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof ObjectArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ObjectArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ObjectArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ObjectArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface ObjectWrapper
 */
export interface ObjectWrapper {
    /**
     * 
     * @type {object}
     * @memberof ObjectWrapper
     */
    'response'?: object;
    /**
     * 
     * @type {number}
     * @memberof ObjectWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ObjectWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ObjectWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ObjectWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface Options
 */
export interface Options {
    /**
     * 
     * @type {WatermarkOnDraw}
     * @memberof Options
     */
    'watermark_on_draw'?: WatermarkOnDraw;
}
/**
 * 
 * @export
 * @interface OrderBy
 */
export interface OrderBy {
    /**
     * Is asc
     * @type {boolean}
     * @memberof OrderBy
     */
    'is_asc'?: boolean;
    /**
     * 
     * @type {SortedByType}
     * @memberof OrderBy
     */
    'property'?: SortedByType;
}


/**
 * Represents the parameters for ordering requests
 * @export
 * @interface OrderRequestDto
 */
export interface OrderRequestDto {
    /**
     * The order value
     * @type {number}
     * @memberof OrderRequestDto
     */
    'order'?: number;
}
/**
 * Represents an item in the ordering request with its entry type and ID
 * @export
 * @interface OrdersItemRequestDtoInteger
 */
export interface OrdersItemRequestDtoInteger {
    /**
     * The unique identifier of the entry (file or folder)
     * @type {number}
     * @memberof OrdersItemRequestDtoInteger
     */
    'entryId'?: number;
    /**
     * 
     * @type {FileEntryType}
     * @memberof OrdersItemRequestDtoInteger
     */
    'entryType'?: FileEntryType;
    /**
     * The order value
     * @type {number}
     * @memberof OrdersItemRequestDtoInteger
     */
    'order'?: number;
}


/**
 * Collection of items to be ordered
 * @export
 * @interface OrdersRequestDtoInteger
 */
export interface OrdersRequestDtoInteger {
    /**
     * List of items with their ordering information
     * @type {Array<OrdersItemRequestDtoInteger>}
     * @memberof OrdersRequestDtoInteger
     */
    'items'?: Array<OrdersItemRequestDtoInteger> | null;
}
/**
 * 
 * @export
 * @interface OwnerChangeInstructionsDto
 */
export interface OwnerChangeInstructionsDto {
    /**
     * Status
     * @type {number}
     * @memberof OwnerChangeInstructionsDto
     */
    'status'?: number;
    /**
     * Message
     * @type {string}
     * @memberof OwnerChangeInstructionsDto
     */
    'message'?: string | null;
}
/**
 * 
 * @export
 * @interface OwnerChangeInstructionsWrapper
 */
export interface OwnerChangeInstructionsWrapper {
    /**
     * 
     * @type {OwnerChangeInstructionsDto}
     * @memberof OwnerChangeInstructionsWrapper
     */
    'response'?: OwnerChangeInstructionsDto;
    /**
     * 
     * @type {number}
     * @memberof OwnerChangeInstructionsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof OwnerChangeInstructionsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof OwnerChangeInstructionsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof OwnerChangeInstructionsWrapper
     */
    'statusCode'?: number;
}
/**
 * Settings request parameters
 * @export
 * @interface OwnerIdSettingsRequestDto
 */
export interface OwnerIdSettingsRequestDto {
    /**
     * Owner ID
     * @type {string}
     * @memberof OwnerIdSettingsRequestDto
     */
    'ownerId'?: string;
}
/**
 * 
 * @export
 * @interface Paragraph
 */
export interface Paragraph {
    /**
     * 
     * @type {number}
     * @memberof Paragraph
     */
    'align'?: number;
    /**
     * 
     * @type {Array<Run>}
     * @memberof Paragraph
     */
    'runs'?: Array<Run> | null;
}
/**
 * 
 * @export
 * @interface PasswordHasher
 */
export interface PasswordHasher {
    /**
     * 
     * @type {number}
     * @memberof PasswordHasher
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PasswordHasher
     */
    'iterations'?: number;
    /**
     * 
     * @type {string}
     * @memberof PasswordHasher
     */
    'salt'?: string | null;
}
/**
 * 
 * @export
 * @interface PasswordSettingsDto
 */
export interface PasswordSettingsDto {
    /**
     * Min length
     * @type {number}
     * @memberof PasswordSettingsDto
     */
    'minLength'?: number;
    /**
     * Upper case
     * @type {boolean}
     * @memberof PasswordSettingsDto
     */
    'upperCase'?: boolean;
    /**
     * Digits
     * @type {boolean}
     * @memberof PasswordSettingsDto
     */
    'digits'?: boolean;
    /**
     * Spec symbols
     * @type {boolean}
     * @memberof PasswordSettingsDto
     */
    'specSymbols'?: boolean;
    /**
     * Allowed characters regex str
     * @type {string}
     * @memberof PasswordSettingsDto
     */
    'allowedCharactersRegexStr'?: string | null;
    /**
     * Digits regex str
     * @type {string}
     * @memberof PasswordSettingsDto
     */
    'digitsRegexStr'?: string | null;
    /**
     * Upper case regex str
     * @type {string}
     * @memberof PasswordSettingsDto
     */
    'upperCaseRegexStr'?: string | null;
    /**
     * Spec symbols regex str
     * @type {string}
     * @memberof PasswordSettingsDto
     */
    'specSymbolsRegexStr'?: string | null;
}
/**
 * Password settings
 * @export
 * @interface PasswordSettingsRequestsDto
 */
export interface PasswordSettingsRequestsDto {
    /**
     * Minimum password length
     * @type {number}
     * @memberof PasswordSettingsRequestsDto
     */
    'minLength'?: number;
    /**
     * Specifies if the password must include the uppercase letters or not
     * @type {boolean}
     * @memberof PasswordSettingsRequestsDto
     */
    'upperCase'?: boolean;
    /**
     * Specifies if the password must include the digits or not
     * @type {boolean}
     * @memberof PasswordSettingsRequestsDto
     */
    'digits'?: boolean;
    /**
     * Specifies if the password must include the special symbols or not
     * @type {boolean}
     * @memberof PasswordSettingsRequestsDto
     */
    'specSymbols'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordSettingsWrapper
 */
export interface PasswordSettingsWrapper {
    /**
     * 
     * @type {PasswordSettingsDto}
     * @memberof PasswordSettingsWrapper
     */
    'response'?: PasswordSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof PasswordSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof PasswordSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof PasswordSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof PasswordSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface PaymentSettingsDto
 */
export interface PaymentSettingsDto {
    /**
     * Email address for sales inquiries and support
     * @type {string}
     * @memberof PaymentSettingsDto
     */
    'salesEmail'?: string | null;
    /**
     * URL for accessing feedback and support resources
     * @type {string}
     * @memberof PaymentSettingsDto
     */
    'feedbackAndSupportUrl'?: string | null;
    /**
     * URL for purchasing or upgrading the product
     * @type {string}
     * @memberof PaymentSettingsDto
     */
    'buyUrl'?: string | null;
    /**
     * Indicates whether the system is running in standalone mode
     * @type {boolean}
     * @memberof PaymentSettingsDto
     */
    'standalone'?: boolean;
    /**
     * 
     * @type {CurrentLicenseInfo}
     * @memberof PaymentSettingsDto
     */
    'currentLicense'?: CurrentLicenseInfo;
    /**
     * Maximum value for a specific setting
     * @type {number}
     * @memberof PaymentSettingsDto
     */
    'max'?: number;
}
/**
 * 
 * @export
 * @interface PaymentSettingsWrapper
 */
export interface PaymentSettingsWrapper {
    /**
     * 
     * @type {PaymentSettingsDto}
     * @memberof PaymentSettingsWrapper
     */
    'response'?: PaymentSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof PaymentSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof PaymentSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof PaymentSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Paid, 1 - Free]
 * @export
 * @enum {number}
 */

export const Payments = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type Payments = typeof Payments[keyof typeof Payments];


/**
 * 
 * @export
 * @interface PermissionsConfig
 */
export interface PermissionsConfig {
    /**
     * Change history
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'changeHistory'?: boolean;
    /**
     * Comment
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'comment'?: boolean;
    /**
     * Chat
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'chat'?: boolean;
    /**
     * Download
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'download'?: boolean;
    /**
     * Edit
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'edit'?: boolean;
    /**
     * FillForms
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'fillForms'?: boolean;
    /**
     * ModifyFilter
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'modifyFilter'?: boolean;
    /**
     * Protect
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'protect'?: boolean;
    /**
     * Print
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'print'?: boolean;
    /**
     * Rename
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'rename'?: boolean;
    /**
     * Review
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'review'?: boolean;
    /**
     * Copy
     * @type {boolean}
     * @memberof PermissionsConfig
     */
    'copy'?: boolean;
}
/**
 * 
 * @export
 * @interface PluginsConfig
 */
export interface PluginsConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof PluginsConfig
     */
    'pluginsData'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface PluginsDto
 */
export interface PluginsDto {
    /**
     * Specifies if the plugins are enabled or not
     * @type {boolean}
     * @memberof PluginsDto
     */
    'enabled'?: boolean;
    /**
     * Specifies if the plugins can be uploaded or not
     * @type {boolean}
     * @memberof PluginsDto
     */
    'upload'?: boolean;
    /**
     * Specifies if the plugins can be deleted or not
     * @type {boolean}
     * @memberof PluginsDto
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductAdministratorDto
 */
export interface ProductAdministratorDto {
    /**
     * Unique identifier of the product
     * @type {string}
     * @memberof ProductAdministratorDto
     */
    'productId'?: string;
    /**
     * Unique identifier of the user
     * @type {string}
     * @memberof ProductAdministratorDto
     */
    'userId'?: string;
    /**
     * Indicates whether the user has administrator privileges for the product
     * @type {boolean}
     * @memberof ProductAdministratorDto
     */
    'administrator'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductAdministratorWrapper
 */
export interface ProductAdministratorWrapper {
    /**
     * 
     * @type {ProductAdministratorDto}
     * @memberof ProductAdministratorWrapper
     */
    'response'?: ProductAdministratorDto;
    /**
     * 
     * @type {number}
     * @memberof ProductAdministratorWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ProductAdministratorWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ProductAdministratorWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductAdministratorWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - None, 2 - Documents, 3 - Login, 4 - Others, 5 - People, 7 - Settings]
 * @export
 * @enum {number}
 */

export const ProductType = {
    NUMBER_0: 0,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type ProductType = typeof ProductType[keyof typeof ProductType];


/**
 * 
 * @export
 * @interface ProviderArrayWrapper
 */
export interface ProviderArrayWrapper {
    /**
     * 
     * @type {Array<ProviderDto>}
     * @memberof ProviderArrayWrapper
     */
    'response'?: Array<ProviderDto>;
    /**
     * 
     * @type {number}
     * @memberof ProviderArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ProviderArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ProviderArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProviderArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface ProviderDto
 */
export interface ProviderDto {
    /**
     * Provider name
     * @type {string}
     * @memberof ProviderDto
     */
    'name'?: string | null;
    /**
     * Provider key
     * @type {string}
     * @memberof ProviderDto
     */
    'key'?: string | null;
    /**
     * Connected flag
     * @type {boolean}
     * @memberof ProviderDto
     */
    'connected'?: boolean;
    /**
     * Oauth flag
     * @type {boolean}
     * @memberof ProviderDto
     */
    'oauth'?: boolean;
    /**
     * Redirect url
     * @type {string}
     * @memberof ProviderDto
     */
    'redirectUrl'?: string | null;
    /**
     * Required connection url flag
     * @type {boolean}
     * @memberof ProviderDto
     */
    'requiredConnectionUrl'?: boolean;
    /**
     * Oauth client id
     * @type {string}
     * @memberof ProviderDto
     */
    'clientId'?: string | null;
}
/**
 * [0 - None, 1 - Box, 2 - DropBox, 3 - GoogleDrive, 4 - kDrive, 5 - OneDrive, 6 - SharePoint, 7 - WebDav, 8 - Yandex, 9 - Storage]
 * @export
 * @enum {number}
 */

export const ProviderFilter = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9
} as const;

export type ProviderFilter = typeof ProviderFilter[keyof typeof ProviderFilter];


/**
 * 
 * @export
 * @interface Quota
 */
export interface Quota {
    /**
     * ID
     * @type {number}
     * @memberof Quota
     */
    'id'?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof Quota
     */
    'quantity'?: number;
}
/**
 * [0 - All, 1 - Default, 2 - Custom]
 * @export
 * @enum {number}
 */

export const QuotaFilter = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type QuotaFilter = typeof QuotaFilter[keyof typeof QuotaFilter];


/**
 * Request parameters for the user quota settings
 * @export
 * @interface QuotaSettingsRequestsDto
 */
export interface QuotaSettingsRequestsDto {
    /**
     * Specifies if the quota settings are enabled or not
     * @type {boolean}
     * @memberof QuotaSettingsRequestsDto
     */
    'enableQuota'?: boolean;
    /**
     * 
     * @type {QuotaSettingsRequestsDtoDefaultQuota}
     * @memberof QuotaSettingsRequestsDto
     */
    'defaultQuota'?: QuotaSettingsRequestsDtoDefaultQuota;
}
/**
 * @type QuotaSettingsRequestsDtoDefaultQuota
 * Default quota value
 * @export
 */
export type QuotaSettingsRequestsDtoDefaultQuota = number | string;

/**
 * [0 - Default, 1 - AndroidV2, 2 - iOSV2, 3 - hCaptcha]
 * @export
 * @enum {number}
 */

export const RecaptchaType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type RecaptchaType = typeof RecaptchaType[keyof typeof RecaptchaType];


/**
 * 
 * @export
 * @interface RecentConfig
 */
export interface RecentConfig {
    /**
     * Folder
     * @type {string}
     * @memberof RecentConfig
     */
    'folder'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof RecentConfig
     */
    'title'?: string | null;
    /**
     * Url
     * @type {string}
     * @memberof RecentConfig
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface RoomDataLifetimeDto
 */
export interface RoomDataLifetimeDto {
    /**
     * Specifies action
     * @type {boolean}
     * @memberof RoomDataLifetimeDto
     */
    'deletePermanently'?: boolean;
    /**
     * 
     * @type {RoomDataLifetimePeriod}
     * @memberof RoomDataLifetimeDto
     */
    'period'?: RoomDataLifetimePeriod;
    /**
     * Specifies time period value
     * @type {number}
     * @memberof RoomDataLifetimeDto
     */
    'value'?: number | null;
    /**
     * Enabled
     * @type {boolean}
     * @memberof RoomDataLifetimeDto
     */
    'enabled'?: boolean | null;
}


/**
 * [0 - Day, 1 - Month, 2 - Year]
 * @export
 * @enum {number}
 */

export const RoomDataLifetimePeriod = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type RoomDataLifetimePeriod = typeof RoomDataLifetimePeriod[keyof typeof RoomDataLifetimePeriod];


/**
 * 
 * @export
 * @interface RoomFromTemplateStatusDto
 */
export interface RoomFromTemplateStatusDto {
    /**
     * Room id
     * @type {number}
     * @memberof RoomFromTemplateStatusDto
     */
    'roomId'?: number;
    /**
     * Progress
     * @type {number}
     * @memberof RoomFromTemplateStatusDto
     */
    'progress'?: number;
    /**
     * Error
     * @type {string}
     * @memberof RoomFromTemplateStatusDto
     */
    'error'?: string | null;
    /**
     * IsCompleted
     * @type {boolean}
     * @memberof RoomFromTemplateStatusDto
     */
    'isCompleted'?: boolean;
}
/**
 * 
 * @export
 * @interface RoomFromTemplateStatusWrapper
 */
export interface RoomFromTemplateStatusWrapper {
    /**
     * 
     * @type {RoomFromTemplateStatusDto}
     * @memberof RoomFromTemplateStatusWrapper
     */
    'response'?: RoomFromTemplateStatusDto;
    /**
     * 
     * @type {number}
     * @memberof RoomFromTemplateStatusWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof RoomFromTemplateStatusWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof RoomFromTemplateStatusWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof RoomFromTemplateStatusWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface RoomInvitation
 */
export interface RoomInvitation {
    /**
     * Email address
     * @type {string}
     * @memberof RoomInvitation
     */
    'email'?: string | null;
    /**
     * ID of the user with whom we want to share a room
     * @type {string}
     * @memberof RoomInvitation
     */
    'id'?: string;
    /**
     * 
     * @type {FileShare}
     * @memberof RoomInvitation
     */
    'access'?: FileShare;
}


/**
 * Request parameters for inviting users to a room
 * @export
 * @interface RoomInvitationRequest
 */
export interface RoomInvitationRequest {
    /**
     * Collection of invitation parameters
     * @type {Array<RoomInvitation>}
     * @memberof RoomInvitationRequest
     */
    'invitations'?: Array<RoomInvitation> | null;
    /**
     * Notifies users about the shared room or not
     * @type {boolean}
     * @memberof RoomInvitationRequest
     */
    'notify'?: boolean;
    /**
     * Message to send when notifying about the shared room
     * @type {string}
     * @memberof RoomInvitationRequest
     */
    'message'?: string | null;
    /**
     * Culture
     * @type {string}
     * @memberof RoomInvitationRequest
     */
    'culture'?: string | null;
}
/**
 * Link parameters
 * @export
 * @interface RoomLinkRequest
 */
export interface RoomLinkRequest {
    /**
     * Link ID
     * @type {string}
     * @memberof RoomLinkRequest
     */
    'linkId'?: string;
    /**
     * 
     * @type {FileShare}
     * @memberof RoomLinkRequest
     */
    'access'?: FileShare;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof RoomLinkRequest
     */
    'expirationDate'?: ApiDateTime;
    /**
     * Link name
     * @type {string}
     * @memberof RoomLinkRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {LinkType}
     * @memberof RoomLinkRequest
     */
    'linkType'?: LinkType;
    /**
     * Link password
     * @type {string}
     * @memberof RoomLinkRequest
     */
    'password'?: string | null;
    /**
     * Specifies whether downloading a file from a link is disabled or not
     * @type {boolean}
     * @memberof RoomLinkRequest
     */
    'denyDownload'?: boolean;
}


/**
 * 
 * @export
 * @interface RoomNewItemsDto
 */
export interface RoomNewItemsDto {
    /**
     * 
     * @type {FileEntryDto}
     * @memberof RoomNewItemsDto
     */
    'room'?: FileEntryDto;
    /**
     * Items
     * @type {Array<FileEntryDto>}
     * @memberof RoomNewItemsDto
     */
    'items'?: Array<FileEntryDto> | null;
}
/**
 * 
 * @export
 * @interface RoomSecurityDto
 */
export interface RoomSecurityDto {
    /**
     * List of room members
     * @type {Array<FileShareDto>}
     * @memberof RoomSecurityDto
     */
    'members'?: Array<FileShareDto> | null;
    /**
     * Warning
     * @type {string}
     * @memberof RoomSecurityDto
     */
    'warning'?: string | null;
}
/**
 * 
 * @export
 * @interface RoomSecurityWrapper
 */
export interface RoomSecurityWrapper {
    /**
     * 
     * @type {RoomSecurityDto}
     * @memberof RoomSecurityWrapper
     */
    'response'?: RoomSecurityDto;
    /**
     * 
     * @type {number}
     * @memberof RoomSecurityWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof RoomSecurityWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof RoomSecurityWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof RoomSecurityWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface RoomTemplateDto
 */
export interface RoomTemplateDto {
    /**
     * Room id
     * @type {number}
     * @memberof RoomTemplateDto
     */
    'roomId'?: number;
    /**
     * Title
     * @type {string}
     * @memberof RoomTemplateDto
     */
    'title'?: string | null;
    /**
     * 
     * @type {LogoRequest}
     * @memberof RoomTemplateDto
     */
    'logo'?: LogoRequest;
    /**
     * Copy room logo
     * @type {boolean}
     * @memberof RoomTemplateDto
     */
    'copyLogo'?: boolean;
    /**
     * Collection of share user emails
     * @type {Array<string>}
     * @memberof RoomTemplateDto
     */
    'share'?: Array<string> | null;
    /**
     * Collection of share groups
     * @type {Array<string>}
     * @memberof RoomTemplateDto
     */
    'groups'?: Array<string> | null;
    /**
     * Public
     * @type {boolean}
     * @memberof RoomTemplateDto
     */
    'public'?: boolean;
    /**
     * Collection of tags
     * @type {Array<string>}
     * @memberof RoomTemplateDto
     */
    'tags'?: Array<string> | null;
    /**
     * Color
     * @type {string}
     * @memberof RoomTemplateDto
     */
    'color'?: string | null;
    /**
     * Cover
     * @type {string}
     * @memberof RoomTemplateDto
     */
    'cover'?: string | null;
}
/**
 * 
 * @export
 * @interface RoomTemplateStatusDto
 */
export interface RoomTemplateStatusDto {
    /**
     * Template id
     * @type {number}
     * @memberof RoomTemplateStatusDto
     */
    'templateId'?: number;
    /**
     * Progress
     * @type {number}
     * @memberof RoomTemplateStatusDto
     */
    'progress'?: number;
    /**
     * Error
     * @type {string}
     * @memberof RoomTemplateStatusDto
     */
    'error'?: string | null;
    /**
     * IsCompleted
     * @type {boolean}
     * @memberof RoomTemplateStatusDto
     */
    'isCompleted'?: boolean;
}
/**
 * 
 * @export
 * @interface RoomTemplateStatusWrapper
 */
export interface RoomTemplateStatusWrapper {
    /**
     * 
     * @type {RoomTemplateStatusDto}
     * @memberof RoomTemplateStatusWrapper
     */
    'response'?: RoomTemplateStatusDto;
    /**
     * 
     * @type {number}
     * @memberof RoomTemplateStatusWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof RoomTemplateStatusWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof RoomTemplateStatusWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof RoomTemplateStatusWrapper
     */
    'statusCode'?: number;
}
/**
 * [1 - Form filling room, 2 - Collaboration room, 5 - Custom room, 6 - Public room, 8 - Virtual data room]
 * @export
 * @enum {number}
 */

export const RoomType = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_8: 8
} as const;

export type RoomType = typeof RoomType[keyof typeof RoomType];


/**
 * 
 * @export
 * @interface RoomsNotificationSettingsDto
 */
export interface RoomsNotificationSettingsDto {
    /**
     * List of rooms with the disabled notifications
     * @type {Array<object>}
     * @memberof RoomsNotificationSettingsDto
     */
    'disabledRooms'?: Array<object> | null;
}
/**
 * 
 * @export
 * @interface RoomsNotificationSettingsWrapper
 */
export interface RoomsNotificationSettingsWrapper {
    /**
     * 
     * @type {RoomsNotificationSettingsDto}
     * @memberof RoomsNotificationSettingsWrapper
     */
    'response'?: RoomsNotificationSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof RoomsNotificationSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof RoomsNotificationSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof RoomsNotificationSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof RoomsNotificationSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * Request parameters for the room notification settings
 * @export
 * @interface RoomsNotificationsSettingsRequestDto
 */
export interface RoomsNotificationsSettingsRequestDto {
    /**
     * Room ID
     * @type {any}
     * @memberof RoomsNotificationsSettingsRequestDto
     */
    'roomsId'?: any | null;
    /**
     * Specifies if the room notifications are disabled or not
     * @type {boolean}
     * @memberof RoomsNotificationsSettingsRequestDto
     */
    'mute'?: boolean;
}
/**
 * 
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * 
     * @type {Array<number>}
     * @memberof Run
     */
    'fill'?: Array<number> | null;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    'font-size'?: string | null;
}
/**
 * 
 * @export
 * @interface STRINGArrayWrapper
 */
export interface STRINGArrayWrapper {
    /**
     * 
     * @type {Array<string>}
     * @memberof STRINGArrayWrapper
     */
    'response'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof STRINGArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof STRINGArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof STRINGArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof STRINGArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * Parameters for saving file as pdf
 * @export
 * @interface SaveAsPdfInteger
 */
export interface SaveAsPdfInteger {
    /**
     * Folder ID
     * @type {number}
     * @memberof SaveAsPdfInteger
     */
    'folderId'?: number;
    /**
     * File title
     * @type {string}
     * @memberof SaveAsPdfInteger
     */
    'title'?: string | null;
}
/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * 
     * @type {BackupStorageType}
     * @memberof Schedule
     */
    'storageType'?: BackupStorageType;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * @memberof Schedule
     */
    'storageParams'?: { [key: string]: string | null; } | null;
    /**
     * 
     * @type {CronParams}
     * @memberof Schedule
     */
    'cronParams'?: CronParams;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'backupsStored'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'lastBackupTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Schedule
     */
    'dump'?: boolean;
}


/**
 * 
 * @export
 * @interface ScheduleWrapper
 */
export interface ScheduleWrapper {
    /**
     * 
     * @type {Schedule}
     * @memberof ScheduleWrapper
     */
    'response'?: Schedule;
    /**
     * 
     * @type {number}
     * @memberof ScheduleWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ScheduleWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ScheduleWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScheduleWrapper
     */
    'statusCode'?: number;
}
/**
 * Team template parameters
 * @export
 * @interface SchemaBaseRequestsDto
 */
export interface SchemaBaseRequestsDto {
    /**
     * Team template ID
     * @type {string}
     * @memberof SchemaBaseRequestsDto
     */
    'id'?: string | null;
}
/**
 * 
 * @export
 * @interface SchemaRequestsArrayWrapper
 */
export interface SchemaRequestsArrayWrapper {
    /**
     * 
     * @type {Array<SchemaRequestsDto>}
     * @memberof SchemaRequestsArrayWrapper
     */
    'response'?: Array<SchemaRequestsDto>;
    /**
     * 
     * @type {number}
     * @memberof SchemaRequestsArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof SchemaRequestsArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof SchemaRequestsArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof SchemaRequestsArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * Team template parameters
 * @export
 * @interface SchemaRequestsDto
 */
export interface SchemaRequestsDto {
    /**
     * Team template ID
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'id'?: string | null;
    /**
     * Team template name
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'name'?: string | null;
    /**
     * User caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'userCaption'?: string | null;
    /**
     * Users caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'usersCaption'?: string | null;
    /**
     * Group caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'groupCaption'?: string | null;
    /**
     * Groups caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'groupsCaption'?: string | null;
    /**
     * User status caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'userPostCaption'?: string | null;
    /**
     * Registration date caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'regDateCaption'?: string | null;
    /**
     * Group lead caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'groupHeadCaption'?: string | null;
    /**
     * Guest caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'guestCaption'?: string | null;
    /**
     * Guests caption
     * @type {string}
     * @memberof SchemaRequestsDto
     */
    'guestsCaption'?: string | null;
}
/**
 * 
 * @export
 * @interface SchemaRequestsWrapper
 */
export interface SchemaRequestsWrapper {
    /**
     * 
     * @type {SchemaRequestsDto}
     * @memberof SchemaRequestsWrapper
     */
    'response'?: SchemaRequestsDto;
    /**
     * 
     * @type {number}
     * @memberof SchemaRequestsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof SchemaRequestsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof SchemaRequestsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof SchemaRequestsWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Active, 1 - Archive, 2 - Any, 3 - Recent by links, 4 - Template]
 * @export
 * @enum {number}
 */

export const SearchArea = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type SearchArea = typeof SearchArea[keyof typeof SearchArea];


/**
 * 
 * @export
 * @interface SecurityArrayWrapper
 */
export interface SecurityArrayWrapper {
    /**
     * 
     * @type {Array<SecurityDto>}
     * @memberof SecurityArrayWrapper
     */
    'response'?: Array<SecurityDto>;
    /**
     * 
     * @type {number}
     * @memberof SecurityArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof SecurityArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof SecurityArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecurityArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface SecurityDto
 */
export interface SecurityDto {
    /**
     * Module ID
     * @type {string}
     * @memberof SecurityDto
     */
    'webItemId'?: string | null;
    /**
     * List of users with the access to the module
     * @type {Array<EmployeeDto>}
     * @memberof SecurityDto
     */
    'users'?: Array<EmployeeDto> | null;
    /**
     * List of groups with the access to the module
     * @type {Array<GroupSummaryDto>}
     * @memberof SecurityDto
     */
    'groups'?: Array<GroupSummaryDto> | null;
    /**
     * Specifies if the security settings are enabled or not
     * @type {boolean}
     * @memberof SecurityDto
     */
    'enabled'?: boolean;
    /**
     * Specifies if this module is a subitem or not
     * @type {boolean}
     * @memberof SecurityDto
     */
    'isSubItem'?: boolean;
}
/**
 * Security request parameters
 * @export
 * @interface SecurityRequestsDto
 */
export interface SecurityRequestsDto {
    /**
     * Product ID
     * @type {string}
     * @memberof SecurityRequestsDto
     */
    'productId'?: string;
    /**
     * User ID
     * @type {string}
     * @memberof SecurityRequestsDto
     */
    'userId'?: string;
    /**
     * Administrator or not
     * @type {boolean}
     * @memberof SecurityRequestsDto
     */
    'administrator'?: boolean;
}
/**
 * Session parameters
 * @export
 * @interface SessionRequest
 */
export interface SessionRequest {
    /**
     * File name
     * @type {string}
     * @memberof SessionRequest
     */
    'fileName'?: string | null;
    /**
     * File length in bytes
     * @type {number}
     * @memberof SessionRequest
     */
    'fileSize'?: number;
    /**
     * Relative path to the folder
     * @type {string}
     * @memberof SessionRequest
     */
    'relativePath'?: string | null;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof SessionRequest
     */
    'createOn'?: ApiDateTime;
    /**
     * Specifies whether to encrypt a file or not
     * @type {boolean}
     * @memberof SessionRequest
     */
    'encrypted'?: boolean;
    /**
     * Create new if exists
     * @type {boolean}
     * @memberof SessionRequest
     */
    'createNewIfExist'?: boolean;
}
/**
 * Request parameters for setting a group manager
 * @export
 * @interface SetManagerRequest
 */
export interface SetManagerRequest {
    /**
     * User ID
     * @type {string}
     * @memberof SetManagerRequest
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface SetPublicDto
 */
export interface SetPublicDto {
    /**
     * Template id
     * @type {number}
     * @memberof SetPublicDto
     */
    'id'?: number;
    /**
     * Public settings
     * @type {boolean}
     * @memberof SetPublicDto
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface SettingsDto
 */
export interface SettingsDto {
    /**
     * Time zone
     * @type {string}
     * @memberof SettingsDto
     */
    'timezone'?: string | null;
    /**
     * List of trusted domains
     * @type {Array<string>}
     * @memberof SettingsDto
     */
    'trustedDomains'?: Array<string> | null;
    /**
     * 
     * @type {TenantTrustedDomainsType}
     * @memberof SettingsDto
     */
    'trustedDomainsType'?: TenantTrustedDomainsType;
    /**
     * Language
     * @type {string}
     * @memberof SettingsDto
     */
    'culture'?: string | null;
    /**
     * UTC offset
     * @type {string}
     * @memberof SettingsDto
     */
    'utcOffset'?: string;
    /**
     * UTC hours offset
     * @type {number}
     * @memberof SettingsDto
     */
    'utcHoursOffset'?: number;
    /**
     * Greeting settings
     * @type {string}
     * @memberof SettingsDto
     */
    'greetingSettings'?: string | null;
    /**
     * Owner ID
     * @type {string}
     * @memberof SettingsDto
     */
    'ownerId'?: string;
    /**
     * Team template ID
     * @type {string}
     * @memberof SettingsDto
     */
    'nameSchemaId'?: string | null;
    /**
     * Specifies if a user can join to the portal or not
     * @type {boolean}
     * @memberof SettingsDto
     */
    'enabledJoin'?: boolean | null;
    /**
     * Specifies if a user can send a message to the administrator or not
     * @type {boolean}
     * @memberof SettingsDto
     */
    'enableAdmMess'?: boolean | null;
    /**
     * Specifies if a user can connect third-party providers or not
     * @type {boolean}
     * @memberof SettingsDto
     */
    'thirdpartyEnable'?: boolean | null;
    /**
     * Specifies if this is a DocSpace portal or not
     * @type {boolean}
     * @memberof SettingsDto
     */
    'docSpace'?: boolean;
    /**
     * Specifies if this is a standalone portal or not
     * @type {boolean}
     * @memberof SettingsDto
     */
    'standalone'?: boolean;
    /**
     * Specifies if this is a AMI instance or not
     * @type {boolean}
     * @memberof SettingsDto
     */
    'isAmi'?: boolean;
    /**
     * Base domain
     * @type {string}
     * @memberof SettingsDto
     */
    'baseDomain'?: string | null;
    /**
     * Wizard token
     * @type {string}
     * @memberof SettingsDto
     */
    'wizardToken'?: string | null;
    /**
     * 
     * @type {PasswordHasher}
     * @memberof SettingsDto
     */
    'passwordHash'?: PasswordHasher;
    /**
     * 
     * @type {FirebaseDto}
     * @memberof SettingsDto
     */
    'firebase'?: FirebaseDto;
    /**
     * Version
     * @type {string}
     * @memberof SettingsDto
     */
    'version'?: string | null;
    /**
     * 
     * @type {RecaptchaType}
     * @memberof SettingsDto
     */
    'recaptchaType'?: RecaptchaType;
    /**
     * ReCAPTCHA public key
     * @type {string}
     * @memberof SettingsDto
     */
    'recaptchaPublicKey'?: string | null;
    /**
     * Specifies if the debug information will be sent or not
     * @type {boolean}
     * @memberof SettingsDto
     */
    'debugInfo'?: boolean;
    /**
     * Socket URL
     * @type {string}
     * @memberof SettingsDto
     */
    'socketUrl'?: string | null;
    /**
     * 
     * @type {TenantStatus}
     * @memberof SettingsDto
     */
    'tenantStatus'?: TenantStatus;
    /**
     * Tenant alias
     * @type {string}
     * @memberof SettingsDto
     */
    'tenantAlias'?: string | null;
    /**
     * Specifies whether to display the About section
     * @type {boolean}
     * @memberof SettingsDto
     */
    'displayAbout'?: boolean;
    /**
     * 
     * @type {TenantDomainValidator}
     * @memberof SettingsDto
     */
    'domainValidator'?: TenantDomainValidator;
    /**
     * Zendesk key
     * @type {string}
     * @memberof SettingsDto
     */
    'zendeskKey'?: string | null;
    /**
     * Tag manager ID
     * @type {string}
     * @memberof SettingsDto
     */
    'tagManagerId'?: string | null;
    /**
     * Specifies whether the cookie settings are enabled
     * @type {boolean}
     * @memberof SettingsDto
     */
    'cookieSettingsEnabled'?: boolean;
    /**
     * Limited access space
     * @type {boolean}
     * @memberof SettingsDto
     */
    'limitedAccessSpace'?: boolean;
    /**
     * User name validation regex
     * @type {string}
     * @memberof SettingsDto
     */
    'userNameRegex'?: string | null;
    /**
     * Invitation limit
     * @type {number}
     * @memberof SettingsDto
     */
    'invitationLimit'?: number | null;
    /**
     * 
     * @type {PluginsDto}
     * @memberof SettingsDto
     */
    'plugins'?: PluginsDto;
    /**
     * 
     * @type {DeepLinkDto}
     * @memberof SettingsDto
     */
    'deepLink'?: DeepLinkDto;
    /**
     * 
     * @type {FormGalleryDto}
     * @memberof SettingsDto
     */
    'formGallery'?: FormGalleryDto;
    /**
     * Max image upload size
     * @type {number}
     * @memberof SettingsDto
     */
    'maxImageUploadSize'?: number;
    /**
     * White label logo text
     * @type {string}
     * @memberof SettingsDto
     */
    'logoText'?: string | null;
    /**
     * 
     * @type {CultureSpecificExternalResources}
     * @memberof SettingsDto
     */
    'externalResources'?: CultureSpecificExternalResources;
}


/**
 * Settings request parameters
 * @export
 * @interface SettingsRequestDto
 */
export interface SettingsRequestDto {
    /**
     * Specifies whether to set the specified settings or not
     * @type {boolean}
     * @memberof SettingsRequestDto
     */
    'set'?: boolean;
}
/**
 * 
 * @export
 * @interface SettingsWrapper
 */
export interface SettingsWrapper {
    /**
     * 
     * @type {SettingsDto}
     * @memberof SettingsWrapper
     */
    'response'?: SettingsDto;
    /**
     * 
     * @type {number}
     * @memberof SettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof SettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof SettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof SettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface SetupCode
 */
export interface SetupCode {
    /**
     * 
     * @type {string}
     * @memberof SetupCode
     */
    'account'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetupCode
     */
    'manualEntryKey'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetupCode
     */
    'qrCodeSetupImageUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface SetupCodeWrapper
 */
export interface SetupCodeWrapper {
    /**
     * 
     * @type {SetupCode}
     * @memberof SetupCodeWrapper
     */
    'response'?: SetupCode;
    /**
     * 
     * @type {number}
     * @memberof SetupCodeWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof SetupCodeWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof SetupCodeWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof SetupCodeWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Female, 1 - Male]
 * @export
 * @enum {number}
 */

export const SexEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SexEnum = typeof SexEnum[keyof typeof SexEnum];


/**
 * [0 - User or group, 1 - Invitation link, 2 - External link, 4 - Additional external link, 8 - Primary external link, 16 - User, 32 - Group]
 * @export
 * @enum {number}
 */

export const ShareFilterType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4,
    NUMBER_8: 8,
    NUMBER_16: 16,
    NUMBER_32: 32
} as const;

export type ShareFilterType = typeof ShareFilterType[keyof typeof ShareFilterType];


/**
 * Request parameters for creating a third-party account
 * @export
 * @interface SignupAccountRequestDto
 */
export interface SignupAccountRequestDto {
    /**
     * 
     * @type {EmployeeType}
     * @memberof SignupAccountRequestDto
     */
    'employeeType'?: EmployeeType;
    /**
     * First name
     * @type {string}
     * @memberof SignupAccountRequestDto
     */
    'firstName'?: string | null;
    /**
     * Last name
     * @type {string}
     * @memberof SignupAccountRequestDto
     */
    'lastName'?: string | null;
    /**
     * Email address
     * @type {string}
     * @memberof SignupAccountRequestDto
     */
    'email'?: string | null;
    /**
     * Password hash
     * @type {string}
     * @memberof SignupAccountRequestDto
     */
    'passwordHash'?: string | null;
    /**
     * Link key
     * @type {string}
     * @memberof SignupAccountRequestDto
     */
    'key'?: string | null;
    /**
     * Culture
     * @type {string}
     * @memberof SignupAccountRequestDto
     */
    'culture'?: string | null;
    /**
     * Third-party profile in the serialized format
     * @type {string}
     * @memberof SignupAccountRequestDto
     */
    'serializedProfile'?: string | null;
}


/**
 * 
 * @export
 * @interface SmtpOperationStatusRequestsDto
 */
export interface SmtpOperationStatusRequestsDto {
    /**
     * Specifies if the SMTP operation is completed or not
     * @type {boolean}
     * @memberof SmtpOperationStatusRequestsDto
     */
    'completed'?: boolean;
    /**
     * SMTP operation ID
     * @type {string}
     * @memberof SmtpOperationStatusRequestsDto
     */
    'id'?: string | null;
    /**
     * SMTP operation error
     * @type {string}
     * @memberof SmtpOperationStatusRequestsDto
     */
    'error'?: string | null;
    /**
     * SMTP operation status
     * @type {string}
     * @memberof SmtpOperationStatusRequestsDto
     */
    'status'?: string | null;
    /**
     * Percentage of SMTP operation completion
     * @type {number}
     * @memberof SmtpOperationStatusRequestsDto
     */
    'percents'?: number;
}
/**
 * 
 * @export
 * @interface SmtpOperationStatusRequestsWrapper
 */
export interface SmtpOperationStatusRequestsWrapper {
    /**
     * 
     * @type {SmtpOperationStatusRequestsDto}
     * @memberof SmtpOperationStatusRequestsWrapper
     */
    'response'?: SmtpOperationStatusRequestsDto;
    /**
     * 
     * @type {number}
     * @memberof SmtpOperationStatusRequestsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof SmtpOperationStatusRequestsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof SmtpOperationStatusRequestsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof SmtpOperationStatusRequestsWrapper
     */
    'statusCode'?: number;
}
/**
 * SMTP settings
 * @export
 * @interface SmtpSettingsDto
 */
export interface SmtpSettingsDto {
    /**
     * Host
     * @type {string}
     * @memberof SmtpSettingsDto
     */
    'host'?: string | null;
    /**
     * Port
     * @type {number}
     * @memberof SmtpSettingsDto
     */
    'port'?: number | null;
    /**
     * Sender address
     * @type {string}
     * @memberof SmtpSettingsDto
     */
    'senderAddress'?: string | null;
    /**
     * Sender display name
     * @type {string}
     * @memberof SmtpSettingsDto
     */
    'senderDisplayName'?: string | null;
    /**
     * Credentials username
     * @type {string}
     * @memberof SmtpSettingsDto
     */
    'credentialsUserName'?: string | null;
    /**
     * Credentials user password
     * @type {string}
     * @memberof SmtpSettingsDto
     */
    'credentialsUserPassword'?: string | null;
    /**
     * Enables SSL or not
     * @type {boolean}
     * @memberof SmtpSettingsDto
     */
    'enableSSL'?: boolean;
    /**
     * Enables authentication or not
     * @type {boolean}
     * @memberof SmtpSettingsDto
     */
    'enableAuth'?: boolean;
    /**
     * Specifies whether to use NTLM or not
     * @type {boolean}
     * @memberof SmtpSettingsDto
     */
    'useNtlm'?: boolean;
    /**
     * Specifies if the current settings are default or not
     * @type {boolean}
     * @memberof SmtpSettingsDto
     */
    'isDefaultSettings'?: boolean;
}
/**
 * 
 * @export
 * @interface SmtpSettingsWrapper
 */
export interface SmtpSettingsWrapper {
    /**
     * 
     * @type {SmtpSettingsDto}
     * @memberof SmtpSettingsWrapper
     */
    'response'?: SmtpSettingsDto;
    /**
     * 
     * @type {number}
     * @memberof SmtpSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof SmtpSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof SmtpSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof SmtpSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Date and time, 1 - AZ, 2 - Size, 3 - Author, 4 - Type, 5 - New, 6 - Date and time creation, 7 - Room type, 8 - Tags, 9 - Room, 10 - Custom order, 11 - Last opened, 12 - Used space]
 * @export
 * @enum {number}
 */

export const SortedByType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12
} as const;

export type SortedByType = typeof SortedByType[keyof typeof SortedByType];


/**
 * 
 * @export
 * @interface SsoCertificate
 */
export interface SsoCertificate {
    /**
     * Specifies if a certificate is self-signed or not
     * @type {boolean}
     * @memberof SsoCertificate
     */
    'selfSigned'?: boolean;
    /**
     * Certificate
     * @type {string}
     * @memberof SsoCertificate
     */
    'crt'?: string | null;
    /**
     * Key
     * @type {string}
     * @memberof SsoCertificate
     */
    'key'?: string | null;
    /**
     * Action
     * @type {string}
     * @memberof SsoCertificate
     */
    'action'?: string | null;
    /**
     * Domain name
     * @type {string}
     * @memberof SsoCertificate
     */
    'domainName'?: string | null;
    /**
     * Start date
     * @type {string}
     * @memberof SsoCertificate
     */
    'startDate'?: string;
    /**
     * Expiration date
     * @type {string}
     * @memberof SsoCertificate
     */
    'expiredDate'?: string;
}
/**
 * 
 * @export
 * @interface SsoFieldMapping
 */
export interface SsoFieldMapping {
    /**
     * First name
     * @type {string}
     * @memberof SsoFieldMapping
     */
    'firstName'?: string | null;
    /**
     * Last name
     * @type {string}
     * @memberof SsoFieldMapping
     */
    'lastName'?: string | null;
    /**
     * Email
     * @type {string}
     * @memberof SsoFieldMapping
     */
    'email'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof SsoFieldMapping
     */
    'title'?: string | null;
    /**
     * Location
     * @type {string}
     * @memberof SsoFieldMapping
     */
    'location'?: string | null;
    /**
     * Phone
     * @type {string}
     * @memberof SsoFieldMapping
     */
    'phone'?: string | null;
}
/**
 * 
 * @export
 * @interface SsoIdpCertificateAdvanced
 */
export interface SsoIdpCertificateAdvanced {
    /**
     * Verification algorithm
     * @type {string}
     * @memberof SsoIdpCertificateAdvanced
     */
    'verifyAlgorithm'?: string | null;
    /**
     * Specifies if the signatures of the SAML authentication responses sent to SP will be verified or not
     * @type {boolean}
     * @memberof SsoIdpCertificateAdvanced
     */
    'verifyAuthResponsesSign'?: boolean;
    /**
     * Specifies if the signatures of the SAML logout requests sent to SP will be verified or not
     * @type {boolean}
     * @memberof SsoIdpCertificateAdvanced
     */
    'verifyLogoutRequestsSign'?: boolean;
    /**
     * Specifies if the signatures of the SAML logout responses sent to SP will be verified or not
     * @type {boolean}
     * @memberof SsoIdpCertificateAdvanced
     */
    'verifyLogoutResponsesSign'?: boolean;
    /**
     * Decryption algorithm
     * @type {string}
     * @memberof SsoIdpCertificateAdvanced
     */
    'decryptAlgorithm'?: string | null;
    /**
     * Specifies if the assertions will be decrypted or not
     * @type {boolean}
     * @memberof SsoIdpCertificateAdvanced
     */
    'decryptAssertions'?: boolean;
}
/**
 * 
 * @export
 * @interface SsoIdpSettings
 */
export interface SsoIdpSettings {
    /**
     * Entity ID
     * @type {string}
     * @memberof SsoIdpSettings
     */
    'entityId'?: string | null;
    /**
     * SSO URL
     * @type {string}
     * @memberof SsoIdpSettings
     */
    'ssoUrl'?: string | null;
    /**
     * SSO binding
     * @type {string}
     * @memberof SsoIdpSettings
     */
    'ssoBinding'?: string | null;
    /**
     * SLO URL
     * @type {string}
     * @memberof SsoIdpSettings
     */
    'sloUrl'?: string | null;
    /**
     * SLO binding
     * @type {string}
     * @memberof SsoIdpSettings
     */
    'sloBinding'?: string | null;
    /**
     * Name ID format
     * @type {string}
     * @memberof SsoIdpSettings
     */
    'nameIdFormat'?: string | null;
}
/**
 * SSO settings request parameters
 * @export
 * @interface SsoSettingsRequestsDto
 */
export interface SsoSettingsRequestsDto {
    /**
     * Serialized SSO settings
     * @type {string}
     * @memberof SsoSettingsRequestsDto
     */
    'serializeSettings'?: string | null;
}
/**
 * 
 * @export
 * @interface SsoSettingsV2
 */
export interface SsoSettingsV2 {
    /**
     * Specifies if SSO is enabled or not
     * @type {boolean}
     * @memberof SsoSettingsV2
     */
    'enableSso'?: boolean | null;
    /**
     * 
     * @type {SsoIdpSettings}
     * @memberof SsoSettingsV2
     */
    'idpSettings'?: SsoIdpSettings;
    /**
     * List of IDP certificates
     * @type {Array<SsoCertificate>}
     * @memberof SsoSettingsV2
     */
    'idpCertificates'?: Array<SsoCertificate> | null;
    /**
     * 
     * @type {SsoIdpCertificateAdvanced}
     * @memberof SsoSettingsV2
     */
    'idpCertificateAdvanced'?: SsoIdpCertificateAdvanced;
    /**
     * SP login label
     * @type {string}
     * @memberof SsoSettingsV2
     */
    'spLoginLabel'?: string | null;
    /**
     * List of SP certificates
     * @type {Array<SsoCertificate>}
     * @memberof SsoSettingsV2
     */
    'spCertificates'?: Array<SsoCertificate> | null;
    /**
     * 
     * @type {SsoSpCertificateAdvanced}
     * @memberof SsoSettingsV2
     */
    'spCertificateAdvanced'?: SsoSpCertificateAdvanced;
    /**
     * 
     * @type {SsoFieldMapping}
     * @memberof SsoSettingsV2
     */
    'fieldMapping'?: SsoFieldMapping;
    /**
     * Specifies if the authentication page will be hidden or not
     * @type {boolean}
     * @memberof SsoSettingsV2
     */
    'hideAuthPage'?: boolean;
    /**
     * Users type
     * @type {number}
     * @memberof SsoSettingsV2
     */
    'usersType'?: number;
    /**
     * Specifies if the email verification is disabled or not
     * @type {boolean}
     * @memberof SsoSettingsV2
     */
    'disableEmailVerification'?: boolean;
}
/**
 * 
 * @export
 * @interface SsoSettingsV2Wrapper
 */
export interface SsoSettingsV2Wrapper {
    /**
     * 
     * @type {SsoSettingsV2}
     * @memberof SsoSettingsV2Wrapper
     */
    'response'?: SsoSettingsV2;
    /**
     * 
     * @type {number}
     * @memberof SsoSettingsV2Wrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof SsoSettingsV2Wrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof SsoSettingsV2Wrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof SsoSettingsV2Wrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface SsoSpCertificateAdvanced
 */
export interface SsoSpCertificateAdvanced {
    /**
     * Signing algorithm
     * @type {string}
     * @memberof SsoSpCertificateAdvanced
     */
    'signingAlgorithm'?: string | null;
    /**
     * Specifies if SP will sign the SAML authentication requests sent to IdP or not
     * @type {boolean}
     * @memberof SsoSpCertificateAdvanced
     */
    'signAuthRequests'?: boolean;
    /**
     * Specifies if SP will sign the SAML logout requests sent to IdP or not
     * @type {boolean}
     * @memberof SsoSpCertificateAdvanced
     */
    'signLogoutRequests'?: boolean;
    /**
     * Specifies if sign the SAML logout responses sent to IdP or not
     * @type {boolean}
     * @memberof SsoSpCertificateAdvanced
     */
    'signLogoutResponses'?: boolean;
    /**
     * Encryption algorithm
     * @type {string}
     * @memberof SsoSpCertificateAdvanced
     */
    'encryptAlgorithm'?: string | null;
    /**
     * Decryption algorithm
     * @type {string}
     * @memberof SsoSpCertificateAdvanced
     */
    'decryptAlgorithm'?: string | null;
    /**
     * Specifies if the assertions will be encrypted or not
     * @type {boolean}
     * @memberof SsoSpCertificateAdvanced
     */
    'encryptAssertions'?: boolean;
}
/**
 * Parameters for starting file editing
 * @export
 * @interface StartEdit
 */
export interface StartEdit {
    /**
     * Specifies whether to share a file with other users for editing or not
     * @type {boolean}
     * @memberof StartEdit
     */
    'editingAlone'?: boolean;
}
/**
 * Request parameters for starting the reassignment process
 * @export
 * @interface StartReassignRequestDto
 */
export interface StartReassignRequestDto {
    /**
     * User ID whose data will be reassigned to another user
     * @type {string}
     * @memberof StartReassignRequestDto
     */
    'fromUserId'?: string;
    /**
     * User ID to whom all the data will be reassigned
     * @type {string}
     * @memberof StartReassignRequestDto
     */
    'toUserId'?: string;
    /**
     * Specifies whether to delete a profile when the data reassignment will be finished or not
     * @type {boolean}
     * @memberof StartReassignRequestDto
     */
    'deleteProfile'?: boolean;
}
/**
 * 
 * @export
 * @interface StorageArrayWrapper
 */
export interface StorageArrayWrapper {
    /**
     * 
     * @type {Array<StorageDto>}
     * @memberof StorageArrayWrapper
     */
    'response'?: Array<StorageDto>;
    /**
     * 
     * @type {number}
     * @memberof StorageArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof StorageArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof StorageArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface StorageDto
 */
export interface StorageDto {
    /**
     * ID
     * @type {string}
     * @memberof StorageDto
     */
    'id'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof StorageDto
     */
    'title'?: string | null;
    /**
     * List of authentication keys
     * @type {Array<AuthKey>}
     * @memberof StorageDto
     */
    'properties'?: Array<AuthKey> | null;
    /**
     * Specifies if this is the current storage or not
     * @type {boolean}
     * @memberof StorageDto
     */
    'current'?: boolean;
    /**
     * Specifies if this storage can be set or not
     * @type {boolean}
     * @memberof StorageDto
     */
    'isSet'?: boolean;
}
/**
 * Storage encryption request parameters
 * @export
 * @interface StorageEncryptionRequestsDto
 */
export interface StorageEncryptionRequestsDto {
    /**
     * Specifies if the users will be notified about the encryption process or note
     * @type {boolean}
     * @memberof StorageEncryptionRequestsDto
     */
    'notifyUsers'?: boolean;
}
/**
 * [0 - None, 1 - Internal, 2 - ThirdParty]
 * @export
 * @enum {number}
 */

export const StorageFilter = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type StorageFilter = typeof StorageFilter[keyof typeof StorageFilter];


/**
 * Storage settings request parameters
 * @export
 * @interface StorageRequestsDto
 */
export interface StorageRequestsDto {
    /**
     * Storage name
     * @type {string}
     * @memberof StorageRequestsDto
     */
    'module'?: string | null;
    /**
     * Storage properties
     * @type {Array<ItemKeyValuePairStringString>}
     * @memberof StorageRequestsDto
     */
    'props'?: Array<ItemKeyValuePairStringString> | null;
}
/**
 * 
 * @export
 * @interface StorageSettings
 */
export interface StorageSettings {
    /**
     * 
     * @type {string}
     * @memberof StorageSettings
     */
    'module'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * @memberof StorageSettings
     */
    'props'?: { [key: string]: string | null; } | null;
}
/**
 * 
 * @export
 * @interface StorageSettingsWrapper
 */
export interface StorageSettingsWrapper {
    /**
     * 
     * @type {StorageSettings}
     * @memberof StorageSettingsWrapper
     */
    'response'?: StorageSettings;
    /**
     * 
     * @type {number}
     * @memberof StorageSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof StorageSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof StorageSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface StringWrapper
 */
export interface StringWrapper {
    /**
     * 
     * @type {string}
     * @memberof StringWrapper
     */
    'response'?: string;
    /**
     * 
     * @type {number}
     * @memberof StringWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof StringWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof StringWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof StringWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Owner, 1 - Member]
 * @export
 * @enum {number}
 */

export const SubjectFilter = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SubjectFilter = typeof SubjectFilter[keyof typeof SubjectFilter];


/**
 * [0 - User, 1 - External link, 2 - Group, 3 - Invitation link, 4 - Primary external link]
 * @export
 * @enum {number}
 */

export const SubjectType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type SubjectType = typeof SubjectType[keyof typeof SubjectType];


/**
 * 
 * @export
 * @interface Tariff
 */
export interface Tariff {
    /**
     * ID
     * @type {number}
     * @memberof Tariff
     */
    'id'?: number;
    /**
     * 
     * @type {TariffState}
     * @memberof Tariff
     */
    'state'?: TariffState;
    /**
     * Due date
     * @type {string}
     * @memberof Tariff
     */
    'dueDate'?: string;
    /**
     * Delay due date
     * @type {string}
     * @memberof Tariff
     */
    'delayDueDate'?: string;
    /**
     * License date
     * @type {string}
     * @memberof Tariff
     */
    'licenseDate'?: string;
    /**
     * Customer ID
     * @type {string}
     * @memberof Tariff
     */
    'customerId'?: string | null;
    /**
     * List of quotas
     * @type {Array<Quota>}
     * @memberof Tariff
     */
    'quotas'?: Array<Quota> | null;
}


/**
 * [0 - Trial, 1 - Paid, 2 - Delay, 3 - Not paid]
 * @export
 * @enum {number}
 */

export const TariffState = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type TariffState = typeof TariffState[keyof typeof TariffState];


/**
 * 
 * @export
 * @interface TariffWrapper
 */
export interface TariffWrapper {
    /**
     * 
     * @type {Tariff}
     * @memberof TariffWrapper
     */
    'response'?: Tariff;
    /**
     * 
     * @type {number}
     * @memberof TariffWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TariffWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TariffWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TariffWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface TaskProgressResponseDto
 */
export interface TaskProgressResponseDto {
    /**
     * ID
     * @type {string}
     * @memberof TaskProgressResponseDto
     */
    'id'?: string | null;
    /**
     * Error
     * @type {string}
     * @memberof TaskProgressResponseDto
     */
    'error'?: string | null;
    /**
     * Percentage
     * @type {number}
     * @memberof TaskProgressResponseDto
     */
    'percentage'?: number;
    /**
     * IsCompleted
     * @type {boolean}
     * @memberof TaskProgressResponseDto
     */
    'isCompleted'?: boolean;
    /**
     * 
     * @type {DistributedTaskStatus}
     * @memberof TaskProgressResponseDto
     */
    'status'?: DistributedTaskStatus;
}


/**
 * 
 * @export
 * @interface TaskProgressResponseWrapper
 */
export interface TaskProgressResponseWrapper {
    /**
     * 
     * @type {TaskProgressResponseDto}
     * @memberof TaskProgressResponseWrapper
     */
    'response'?: TaskProgressResponseDto;
    /**
     * 
     * @type {number}
     * @memberof TaskProgressResponseWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TaskProgressResponseWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TaskProgressResponseWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskProgressResponseWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface TemplatesConfig
 */
export interface TemplatesConfig {
    /**
     * Image
     * @type {string}
     * @memberof TemplatesConfig
     */
    'image'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof TemplatesConfig
     */
    'title'?: string | null;
    /**
     * Url
     * @type {string}
     * @memberof TemplatesConfig
     */
    'url'?: string | null;
}
/**
 * Request parameters for adding files to the template list
 * @export
 * @interface TemplatesRequestDto
 */
export interface TemplatesRequestDto {
    /**
     * List of file IDs
     * @type {Array<number>}
     * @memberof TemplatesRequestDto
     */
    'fileIds'?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface TenantAuditSettings
 */
export interface TenantAuditSettings {
    /**
     * Login history lifetime
     * @type {number}
     * @memberof TenantAuditSettings
     */
    'loginHistoryLifeTime'?: number;
    /**
     * Audit trail lifetime
     * @type {number}
     * @memberof TenantAuditSettings
     */
    'auditTrailLifeTime'?: number;
}
/**
 * Audit trail settings
 * @export
 * @interface TenantAuditSettingsWrapper
 */
export interface TenantAuditSettingsWrapper {
    /**
     * 
     * @type {TenantAuditSettings}
     * @memberof TenantAuditSettingsWrapper
     */
    'settings'?: TenantAuditSettings;
}
/**
 * 
 * @export
 * @interface TenantDeepLinkSettings
 */
export interface TenantDeepLinkSettings {
    /**
     * 
     * @type {DeepLinkHandlingMode}
     * @memberof TenantDeepLinkSettings
     */
    'handlingMode'?: DeepLinkHandlingMode;
}


/**
 * 
 * @export
 * @interface TenantDeepLinkSettingsWrapper
 */
export interface TenantDeepLinkSettingsWrapper {
    /**
     * 
     * @type {TenantDeepLinkSettings}
     * @memberof TenantDeepLinkSettingsWrapper
     */
    'response'?: TenantDeepLinkSettings;
    /**
     * 
     * @type {number}
     * @memberof TenantDeepLinkSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TenantDeepLinkSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TenantDeepLinkSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantDeepLinkSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface TenantDomainValidator
 */
export interface TenantDomainValidator {
    /**
     * Regex
     * @type {string}
     * @memberof TenantDomainValidator
     */
    'regex'?: string | null;
    /**
     * Min length
     * @type {number}
     * @memberof TenantDomainValidator
     */
    'minLength'?: number;
    /**
     * Max length
     * @type {number}
     * @memberof TenantDomainValidator
     */
    'maxLength'?: number;
}
/**
 * 
 * @export
 * @interface TenantDto
 */
export interface TenantDto {
    /**
     * Affiliate ID
     * @type {string}
     * @memberof TenantDto
     */
    'affiliateId'?: string | null;
    /**
     * Tenant alias
     * @type {string}
     * @memberof TenantDto
     */
    'tenantAlias'?: string | null;
    /**
     * Specifies if the calls are available for this tenant or not
     * @type {boolean}
     * @memberof TenantDto
     */
    'calls'?: boolean;
    /**
     * Campaign
     * @type {string}
     * @memberof TenantDto
     */
    'campaign'?: string | null;
    /**
     * Creation date and time
     * @type {string}
     * @memberof TenantDto
     */
    'creationDateTime'?: string;
    /**
     * Hosted region
     * @type {string}
     * @memberof TenantDto
     */
    'hostedRegion'?: string | null;
    /**
     * Tenant ID
     * @type {number}
     * @memberof TenantDto
     */
    'tenantId'?: number;
    /**
     * 
     * @type {TenantIndustry}
     * @memberof TenantDto
     */
    'industry'?: TenantIndustry;
    /**
     * Language
     * @type {string}
     * @memberof TenantDto
     */
    'language'?: string | null;
    /**
     * Last modified date
     * @type {string}
     * @memberof TenantDto
     */
    'lastModified'?: string;
    /**
     * Mapped domain
     * @type {string}
     * @memberof TenantDto
     */
    'mappedDomain'?: string | null;
    /**
     * Name
     * @type {string}
     * @memberof TenantDto
     */
    'name'?: string | null;
    /**
     * Owner ID
     * @type {string}
     * @memberof TenantDto
     */
    'ownerId'?: string;
    /**
     * Payment ID
     * @type {string}
     * @memberof TenantDto
     */
    'paymentId'?: string | null;
    /**
     * Specifies if the ONLYOFFICE newsletter is allowed or not
     * @type {boolean}
     * @memberof TenantDto
     */
    'spam'?: boolean;
    /**
     * 
     * @type {TenantStatus}
     * @memberof TenantDto
     */
    'status'?: TenantStatus;
    /**
     * The date and time when the tenant status was changed
     * @type {string}
     * @memberof TenantDto
     */
    'statusChangeDate'?: string;
    /**
     * Time zone
     * @type {string}
     * @memberof TenantDto
     */
    'timeZone'?: string | null;
    /**
     * List of trusted domains
     * @type {Array<string>}
     * @memberof TenantDto
     */
    'trustedDomains'?: Array<string> | null;
    /**
     * Trusted domains in the string format
     * @type {string}
     * @memberof TenantDto
     */
    'trustedDomainsRaw'?: string | null;
    /**
     * 
     * @type {TenantTrustedDomainsType}
     * @memberof TenantDto
     */
    'trustedDomainsType'?: TenantTrustedDomainsType;
    /**
     * Version
     * @type {number}
     * @memberof TenantDto
     */
    'version'?: number;
    /**
     * The date and time when the tenant version was changed
     * @type {string}
     * @memberof TenantDto
     */
    'versionChanged'?: string;
    /**
     * AWS region
     * @type {string}
     * @memberof TenantDto
     */
    'region'?: string | null;
}


/**
 * [0 - Other, 1 - Accounting, 2 - Advertising marketing PR, 3 - Banking, 4 - Consulting, 5 - Design, 6 - Education, 7 - Environment, 8 - Financial services, 9 - Health care, 10 - IT, 11 - Legal, 12 - Manufacturing, 13 - Public sector, 14 - Publishing, 15 - Retail sales, 16 - Telecommunications]
 * @export
 * @enum {number}
 */

export const TenantIndustry = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15,
    NUMBER_16: 16
} as const;

export type TenantIndustry = typeof TenantIndustry[keyof typeof TenantIndustry];


/**
 * 
 * @export
 * @interface TenantQuota
 */
export interface TenantQuota {
    /**
     * Tenant ID
     * @type {number}
     * @memberof TenantQuota
     */
    'tenantId'?: number;
    /**
     * Name
     * @type {string}
     * @memberof TenantQuota
     */
    'name'?: string | null;
    /**
     * Price
     * @type {number}
     * @memberof TenantQuota
     */
    'price'?: number;
    /**
     * Price currency symbol
     * @type {string}
     * @memberof TenantQuota
     */
    'priceCurrencySymbol'?: string | null;
    /**
     * Product ID
     * @type {string}
     * @memberof TenantQuota
     */
    'productId'?: string | null;
    /**
     * Specifies if the tenant quota is visible or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'visible'?: boolean;
    /**
     * Tenant quota features
     * @type {string}
     * @memberof TenantQuota
     */
    'features'?: string | null;
    /**
     * Maximum file size
     * @type {number}
     * @memberof TenantQuota
     */
    'maxFileSize'?: number;
    /**
     * Maximum total size
     * @type {number}
     * @memberof TenantQuota
     */
    'maxTotalSize'?: number;
    /**
     * Number of portal users
     * @type {number}
     * @memberof TenantQuota
     */
    'countUser'?: number;
    /**
     * Number of portal room administrators
     * @type {number}
     * @memberof TenantQuota
     */
    'countRoomAdmin'?: number;
    /**
     * Number of room users
     * @type {number}
     * @memberof TenantQuota
     */
    'usersInRoom'?: number;
    /**
     * Number of rooms
     * @type {number}
     * @memberof TenantQuota
     */
    'countRoom'?: number;
    /**
     * Specifies if the tenant quota is nonprofit or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'nonProfit'?: boolean;
    /**
     * Specifies if the tenant quota is trial or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'trial'?: boolean;
    /**
     * Specifies if the tenant quota is free or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'free'?: boolean;
    /**
     * Specifies if the tenant quota is updated or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'update'?: boolean;
    /**
     * Specifies if the audit trail is available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'audit'?: boolean;
    /**
     * Specifies if this tenant quota is Docs edition or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'docsEdition'?: boolean;
    /**
     * Specifies if the LDAP settings are available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'ldap'?: boolean;
    /**
     * Specifies if the SSO settings are available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'sso'?: boolean;
    /**
     * Specifies if the statistic settings are available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'statistic'?: boolean;
    /**
     * Specifies if the branding settings are available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'branding'?: boolean;
    /**
     * Specifies if the customization settings are available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'customization'?: boolean;
    /**
     * Specifies if the license is lifetime or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'lifetime'?: boolean;
    /**
     * Specifies if the custom domain URL is available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'custom'?: boolean;
    /**
     * Specifies if the automatic Backup&Restore feature is available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'autoBackupRestore'?: boolean;
    /**
     * Specifies if Oauth is available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'oauth'?: boolean;
    /**
     * Specifies if the content search is available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'contentSearch'?: boolean;
    /**
     * Specifies if the third-party accounts linking is available or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'thirdParty'?: boolean;
    /**
     * Specifies if the tenant quota is yearly subscription or not
     * @type {boolean}
     * @memberof TenantQuota
     */
    'year'?: boolean;
}
/**
 * 
 * @export
 * @interface TenantQuotaSettings
 */
export interface TenantQuotaSettings {
    /**
     * Specifies if the quota is enabled or not
     * @type {boolean}
     * @memberof TenantQuotaSettings
     */
    'enableQuota'?: boolean;
    /**
     * Quota
     * @type {number}
     * @memberof TenantQuotaSettings
     */
    'quota'?: number;
    /**
     * Date of the last quota recalculation
     * @type {string}
     * @memberof TenantQuotaSettings
     */
    'lastRecalculateDate'?: string | null;
}
/**
 * Request parameters for the tenant quota settings
 * @export
 * @interface TenantQuotaSettingsRequestsDto
 */
export interface TenantQuotaSettingsRequestsDto {
    /**
     * Tenant ID
     * @type {number}
     * @memberof TenantQuotaSettingsRequestsDto
     */
    'tenantId'?: number;
    /**
     * Quota
     * @type {number}
     * @memberof TenantQuotaSettingsRequestsDto
     */
    'quota'?: number;
}
/**
 * 
 * @export
 * @interface TenantQuotaSettingsWrapper
 */
export interface TenantQuotaSettingsWrapper {
    /**
     * 
     * @type {TenantQuotaSettings}
     * @memberof TenantQuotaSettingsWrapper
     */
    'response'?: TenantQuotaSettings;
    /**
     * 
     * @type {number}
     * @memberof TenantQuotaSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TenantQuotaSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TenantQuotaSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantQuotaSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface TenantQuotaWrapper
 */
export interface TenantQuotaWrapper {
    /**
     * 
     * @type {TenantQuota}
     * @memberof TenantQuotaWrapper
     */
    'response'?: TenantQuota;
    /**
     * 
     * @type {number}
     * @memberof TenantQuotaWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TenantQuotaWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TenantQuotaWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantQuotaWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface TenantRoomQuotaSettings
 */
export interface TenantRoomQuotaSettings {
    /**
     * Specifies if the quota is enabled or not
     * @type {boolean}
     * @memberof TenantRoomQuotaSettings
     */
    'enableQuota'?: boolean;
    /**
     * Default quota
     * @type {number}
     * @memberof TenantRoomQuotaSettings
     */
    'defaultQuota'?: number;
    /**
     * Date of the last quota recalculation
     * @type {string}
     * @memberof TenantRoomQuotaSettings
     */
    'lastRecalculateDate'?: string | null;
}
/**
 * 
 * @export
 * @interface TenantRoomQuotaSettingsWrapper
 */
export interface TenantRoomQuotaSettingsWrapper {
    /**
     * 
     * @type {TenantRoomQuotaSettings}
     * @memberof TenantRoomQuotaSettingsWrapper
     */
    'response'?: TenantRoomQuotaSettings;
    /**
     * 
     * @type {number}
     * @memberof TenantRoomQuotaSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TenantRoomQuotaSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TenantRoomQuotaSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantRoomQuotaSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - Active, 1 - Suspended, 2 - Remove pending, 3 - Transfering, 4 - Restoring, 5 - Migrating, 6 - Encryption]
 * @export
 * @enum {number}
 */

export const TenantStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type TenantStatus = typeof TenantStatus[keyof typeof TenantStatus];


/**
 * [0 - None, 1 - Custom, 2 - All]
 * @export
 * @enum {number}
 */

export const TenantTrustedDomainsType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type TenantTrustedDomainsType = typeof TenantTrustedDomainsType[keyof typeof TenantTrustedDomainsType];


/**
 * 
 * @export
 * @interface TenantUserQuotaSettings
 */
export interface TenantUserQuotaSettings {
    /**
     * Specifies if the quota is enabled or not
     * @type {boolean}
     * @memberof TenantUserQuotaSettings
     */
    'enableQuota'?: boolean;
    /**
     * Default quota
     * @type {number}
     * @memberof TenantUserQuotaSettings
     */
    'defaultQuota'?: number;
    /**
     * Date of the last quota recalculation
     * @type {string}
     * @memberof TenantUserQuotaSettings
     */
    'lastRecalculateDate'?: string | null;
}
/**
 * 
 * @export
 * @interface TenantUserQuotaSettingsWrapper
 */
export interface TenantUserQuotaSettingsWrapper {
    /**
     * 
     * @type {TenantUserQuotaSettings}
     * @memberof TenantUserQuotaSettingsWrapper
     */
    'response'?: TenantUserQuotaSettings;
    /**
     * 
     * @type {number}
     * @memberof TenantUserQuotaSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TenantUserQuotaSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TenantUserQuotaSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantUserQuotaSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface TenantWrapper
 */
export interface TenantWrapper {
    /**
     * 
     * @type {TenantDto}
     * @memberof TenantWrapper
     */
    'response'?: TenantDto;
    /**
     * 
     * @type {number}
     * @memberof TenantWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TenantWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TenantWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantWrapper
     */
    'statusCode'?: number;
}
/**
 * Request parameters for terminating the reassignment process
 * @export
 * @interface TerminateRequestDto
 */
export interface TerminateRequestDto {
    /**
     * User ID whose data is reassigned/removed
     * @type {string}
     * @memberof TerminateRequestDto
     */
    'userId'?: string;
}
/**
 * TFA settings request parameters
 * @export
 * @interface TfaRequestsDto
 */
export interface TfaRequestsDto {
    /**
     * 
     * @type {TfaRequestsDtoType}
     * @memberof TfaRequestsDto
     */
    'type'?: TfaRequestsDtoType;
    /**
     * User ID
     * @type {string}
     * @memberof TfaRequestsDto
     */
    'id'?: string | null;
    /**
     * List of trusted IP addresses
     * @type {Array<string>}
     * @memberof TfaRequestsDto
     */
    'trustedIps'?: Array<string> | null;
    /**
     * List of users who must use the TFA verification
     * @type {Array<string>}
     * @memberof TfaRequestsDto
     */
    'mandatoryUsers'?: Array<string> | null;
    /**
     * List of groups who must use the TFA verification
     * @type {Array<string>}
     * @memberof TfaRequestsDto
     */
    'mandatoryGroups'?: Array<string> | null;
}


/**
 * [0 - None, 1 - Sms, 2 - App]
 * @export
 * @enum {number}
 */

export const TfaRequestsDtoType = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type TfaRequestsDtoType = typeof TfaRequestsDtoType[keyof typeof TfaRequestsDtoType];


/**
 * 
 * @export
 * @interface TfaSettingsArrayWrapper
 */
export interface TfaSettingsArrayWrapper {
    /**
     * 
     * @type {Array<TfaSettingsDto>}
     * @memberof TfaSettingsArrayWrapper
     */
    'response'?: Array<TfaSettingsDto>;
    /**
     * 
     * @type {number}
     * @memberof TfaSettingsArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TfaSettingsArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TfaSettingsArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TfaSettingsArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface TfaSettingsDto
 */
export interface TfaSettingsDto {
    /**
     * ID
     * @type {string}
     * @memberof TfaSettingsDto
     */
    'id'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof TfaSettingsDto
     */
    'title'?: string | null;
    /**
     * Specifies if the TFA settings are enabled or not
     * @type {boolean}
     * @memberof TfaSettingsDto
     */
    'enabled'?: boolean;
    /**
     * Specifies if the TFA settings are available or not
     * @type {boolean}
     * @memberof TfaSettingsDto
     */
    'avaliable'?: boolean;
    /**
     * List of trusted IP addresses
     * @type {Array<string>}
     * @memberof TfaSettingsDto
     */
    'trustedIps'?: Array<string> | null;
    /**
     * List of users who must use the TFA verification
     * @type {Array<string>}
     * @memberof TfaSettingsDto
     */
    'mandatoryUsers'?: Array<string> | null;
    /**
     * List of groups who must use the TFA verification
     * @type {Array<string>}
     * @memberof TfaSettingsDto
     */
    'mandatoryGroups'?: Array<string> | null;
}
/**
 * TFA validation request parameters
 * @export
 * @interface TfaValidateRequestsDto
 */
export interface TfaValidateRequestsDto {
    /**
     * TFA code
     * @type {string}
     * @memberof TfaValidateRequestsDto
     */
    'code'?: string | null;
}
/**
 * Third-party backup request parameters
 * @export
 * @interface ThirdPartyBackupRequestDto
 */
export interface ThirdPartyBackupRequestDto {
    /**
     * Connection URL for the sharepoint
     * @type {string}
     * @memberof ThirdPartyBackupRequestDto
     */
    'url'?: string | null;
    /**
     * Login
     * @type {string}
     * @memberof ThirdPartyBackupRequestDto
     */
    'login'?: string | null;
    /**
     * Password
     * @type {string}
     * @memberof ThirdPartyBackupRequestDto
     */
    'password'?: string | null;
    /**
     * Authentication token
     * @type {string}
     * @memberof ThirdPartyBackupRequestDto
     */
    'token'?: string | null;
    /**
     * Customer title
     * @type {string}
     * @memberof ThirdPartyBackupRequestDto
     */
    'customerTitle'?: string | null;
    /**
     * Provider key
     * @type {string}
     * @memberof ThirdPartyBackupRequestDto
     */
    'providerKey'?: string | null;
}
/**
 * 
 * @export
 * @interface ThirdPartyParams
 */
export interface ThirdPartyParams {
    /**
     * 
     * @type {AuthData}
     * @memberof ThirdPartyParams
     */
    'auth_data'?: AuthData;
    /**
     * Specifies if this is a corporate account or not
     * @type {boolean}
     * @memberof ThirdPartyParams
     */
    'corporate'?: boolean;
    /**
     * Specifies if this is a room storage or not
     * @type {boolean}
     * @memberof ThirdPartyParams
     */
    'roomsStorage'?: boolean;
    /**
     * Customer title
     * @type {string}
     * @memberof ThirdPartyParams
     */
    'customer_title'?: string | null;
    /**
     * Provider ID
     * @type {number}
     * @memberof ThirdPartyParams
     */
    'provider_id'?: number | null;
    /**
     * Provider key
     * @type {string}
     * @memberof ThirdPartyParams
     */
    'provider_key'?: string | null;
}
/**
 * 
 * @export
 * @interface ThirdPartyParamsArrayWrapper
 */
export interface ThirdPartyParamsArrayWrapper {
    /**
     * 
     * @type {Array<ThirdPartyParams>}
     * @memberof ThirdPartyParamsArrayWrapper
     */
    'response'?: Array<ThirdPartyParams>;
    /**
     * 
     * @type {number}
     * @memberof ThirdPartyParamsArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ThirdPartyParamsArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ThirdPartyParamsArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ThirdPartyParamsArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * Third-party request parameters
 * @export
 * @interface ThirdPartyRequestDto
 */
export interface ThirdPartyRequestDto {
    /**
     * Connection URL for the sharepoint
     * @type {string}
     * @memberof ThirdPartyRequestDto
     */
    'url'?: string | null;
    /**
     * Login
     * @type {string}
     * @memberof ThirdPartyRequestDto
     */
    'login'?: string | null;
    /**
     * Password
     * @type {string}
     * @memberof ThirdPartyRequestDto
     */
    'password'?: string | null;
    /**
     * Authentication token
     * @type {string}
     * @memberof ThirdPartyRequestDto
     */
    'token'?: string | null;
    /**
     * Customer title
     * @type {string}
     * @memberof ThirdPartyRequestDto
     */
    'customerTitle'?: string | null;
    /**
     * Provider key
     * @type {string}
     * @memberof ThirdPartyRequestDto
     */
    'providerKey'?: string | null;
    /**
     * Provider ID
     * @type {number}
     * @memberof ThirdPartyRequestDto
     */
    'providerId'?: number | null;
}
/**
 * [0 - Waiting, 1 - Created, 2 - Error, 3 - Not required, 4 - Creating]
 * @export
 * @enum {number}
 */

export const Thumbnail = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type Thumbnail = typeof Thumbnail[keyof typeof Thumbnail];


/**
 * 
 * @export
 * @interface ThumbnailsDataDto
 */
export interface ThumbnailsDataDto {
    /**
     * Original photo
     * @type {string}
     * @memberof ThumbnailsDataDto
     */
    'original'?: string | null;
    /**
     * Retina
     * @type {string}
     * @memberof ThumbnailsDataDto
     */
    'retina'?: string | null;
    /**
     * Maximum size
     * @type {string}
     * @memberof ThumbnailsDataDto
     */
    'max'?: string | null;
    /**
     * Big
     * @type {string}
     * @memberof ThumbnailsDataDto
     */
    'big'?: string | null;
    /**
     * Medium
     * @type {string}
     * @memberof ThumbnailsDataDto
     */
    'medium'?: string | null;
    /**
     * Small
     * @type {string}
     * @memberof ThumbnailsDataDto
     */
    'small'?: string | null;
}
/**
 * 
 * @export
 * @interface ThumbnailsDataWrapper
 */
export interface ThumbnailsDataWrapper {
    /**
     * 
     * @type {ThumbnailsDataDto}
     * @memberof ThumbnailsDataWrapper
     */
    'response'?: ThumbnailsDataDto;
    /**
     * 
     * @type {number}
     * @memberof ThumbnailsDataWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof ThumbnailsDataWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof ThumbnailsDataWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof ThumbnailsDataWrapper
     */
    'statusCode'?: number;
}
/**
 * Thumbnail request parameters
 * @export
 * @interface ThumbnailsRequest
 */
export interface ThumbnailsRequest {
    /**
     * Path to the temporary file
     * @type {string}
     * @memberof ThumbnailsRequest
     */
    'tmpFile'?: string | null;
    /**
     * Horizontal coordinate
     * @type {number}
     * @memberof ThumbnailsRequest
     */
    'x'?: number;
    /**
     * Vertical coordinate
     * @type {number}
     * @memberof ThumbnailsRequest
     */
    'y'?: number;
    /**
     * Thumbnail width
     * @type {number}
     * @memberof ThumbnailsRequest
     */
    'width'?: number;
    /**
     * Thumbnail height
     * @type {number}
     * @memberof ThumbnailsRequest
     */
    'height'?: number;
}
/**
 * 
 * @export
 * @interface TimezonesRequestsArrayWrapper
 */
export interface TimezonesRequestsArrayWrapper {
    /**
     * 
     * @type {Array<TimezonesRequestsDto>}
     * @memberof TimezonesRequestsArrayWrapper
     */
    'response'?: Array<TimezonesRequestsDto>;
    /**
     * 
     * @type {number}
     * @memberof TimezonesRequestsArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TimezonesRequestsArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TimezonesRequestsArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimezonesRequestsArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface TimezonesRequestsDto
 */
export interface TimezonesRequestsDto {
    /**
     * Time zone ID
     * @type {string}
     * @memberof TimezonesRequestsDto
     */
    'id'?: string | null;
    /**
     * Time zone display name
     * @type {string}
     * @memberof TimezonesRequestsDto
     */
    'displayName'?: string | null;
}
/**
 * Settings request parameters
 * @export
 * @interface TipsRequestDto
 */
export interface TipsRequestDto {
    /**
     * Specifies whether to show tips for the user or not
     * @type {boolean}
     * @memberof TipsRequestDto
     */
    'show'?: boolean;
}
/**
 * 
 * @export
 * @interface TipsSettings
 */
export interface TipsSettings {
    /**
     * Specifies if the tips will be shown or not
     * @type {boolean}
     * @memberof TipsSettings
     */
    'show'?: boolean;
}
/**
 * 
 * @export
 * @interface TipsSettingsWrapper
 */
export interface TipsSettingsWrapper {
    /**
     * 
     * @type {TipsSettings}
     * @memberof TipsSettingsWrapper
     */
    'response'?: TipsSettings;
    /**
     * 
     * @type {number}
     * @memberof TipsSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof TipsSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof TipsSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TipsSettingsWrapper
     */
    'statusCode'?: number;
}
/**
 * Request parameters for administrator message settings
 * @export
 * @interface TurnOnAdminMessageSettingsRequestDto
 */
export interface TurnOnAdminMessageSettingsRequestDto {
    /**
     * Specifies if the administrator messages are enabled or not
     * @type {boolean}
     * @memberof TurnOnAdminMessageSettingsRequestDto
     */
    'turnOn'?: boolean;
}
/**
 * Parameters for updating a comment
 * @export
 * @interface UpdateComment
 */
export interface UpdateComment {
    /**
     * File version
     * @type {number}
     * @memberof UpdateComment
     */
    'version'?: number;
    /**
     * Comment text
     * @type {string}
     * @memberof UpdateComment
     */
    'comment'?: string | null;
}
/**
 * Parameters for updating a file
 * @export
 * @interface UpdateFile
 */
export interface UpdateFile {
    /**
     * File title
     * @type {string}
     * @memberof UpdateFile
     */
    'title'?: string | null;
    /**
     * Number of the latest file version
     * @type {number}
     * @memberof UpdateFile
     */
    'lastVersion'?: number;
}
/**
 * Group request parameters
 * @export
 * @interface UpdateGroupRequest
 */
export interface UpdateGroupRequest {
    /**
     * List of user IDs to add to the group
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'membersToAdd'?: Array<string> | null;
    /**
     * List of user IDs to remove from the group
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'membersToRemove'?: Array<string> | null;
    /**
     * Group manager ID
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'groupManager'?: string;
    /**
     * Group name
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'groupName'?: string | null;
}
/**
 * Request parameters for updating user information
 * @export
 * @interface UpdateMemberRequestDto
 */
export interface UpdateMemberRequestDto {
    /**
     * User ID
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'userId'?: string | null;
    /**
     * Specifies whether to disable a user or not
     * @type {boolean}
     * @memberof UpdateMemberRequestDto
     */
    'disable'?: boolean | null;
    /**
     * Email
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'email'?: string | null;
    /**
     * Specifies if this is a guest or a user
     * @type {boolean}
     * @memberof UpdateMemberRequestDto
     */
    'isUser'?: boolean | null;
    /**
     * First name
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'firstName'?: string | null;
    /**
     * Last name
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'lastName'?: string | null;
    /**
     * List of user departments
     * @type {Array<string>}
     * @memberof UpdateMemberRequestDto
     */
    'department'?: Array<string> | null;
    /**
     * Title
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'title'?: string | null;
    /**
     * Location
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'location'?: string | null;
    /**
     * 
     * @type {SexEnum}
     * @memberof UpdateMemberRequestDto
     */
    'sex'?: SexEnum;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof UpdateMemberRequestDto
     */
    'birthday'?: ApiDateTime;
    /**
     * 
     * @type {ApiDateTime}
     * @memberof UpdateMemberRequestDto
     */
    'worksfrom'?: ApiDateTime;
    /**
     * Comment
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'comment'?: string | null;
    /**
     * List of user contacts
     * @type {Array<Contact>}
     * @memberof UpdateMemberRequestDto
     */
    'contacts'?: Array<Contact> | null;
    /**
     * Avatar photo URL
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'files'?: string | null;
    /**
     * Language
     * @type {string}
     * @memberof UpdateMemberRequestDto
     */
    'cultureName'?: string | null;
    /**
     * Spam
     * @type {boolean}
     * @memberof UpdateMemberRequestDto
     */
    'spam'?: boolean | null;
}


/**
 * Request parameters for updating user information
 * @export
 * @interface UpdateMembersQuotaRequestDto
 */
export interface UpdateMembersQuotaRequestDto {
    /**
     * List of user IDs
     * @type {Array<string>}
     * @memberof UpdateMembersQuotaRequestDto
     */
    'userIds'?: Array<string> | null;
    /**
     * 
     * @type {UpdateMembersQuotaRequestDtoQuota}
     * @memberof UpdateMembersQuotaRequestDto
     */
    'quota'?: UpdateMembersQuotaRequestDtoQuota;
}
/**
 * @type UpdateMembersQuotaRequestDtoQuota
 * Quota
 * @export
 */
export type UpdateMembersQuotaRequestDtoQuota = number | string;

/**
 * Request parameters for updating user information
 * @export
 * @interface UpdateMembersRequestDto
 */
export interface UpdateMembersRequestDto {
    /**
     * List of user IDs
     * @type {Array<string>}
     * @memberof UpdateMembersRequestDto
     */
    'userIds'?: Array<string> | null;
    /**
     * Specifies whether to resend invitation letters to all the users or not
     * @type {boolean}
     * @memberof UpdateMembersRequestDto
     */
    'resendAll'?: boolean;
}
/**
 * Request parameters for updating user photo
 * @export
 * @interface UpdatePhotoMemberRequest
 */
export interface UpdatePhotoMemberRequest {
    /**
     * Avatar photo URL
     * @type {string}
     * @memberof UpdatePhotoMemberRequest
     */
    'files'?: string | null;
}
/**
 * Parameters for updating a room
 * @export
 * @interface UpdateRoomRequest
 */
export interface UpdateRoomRequest {
    /**
     * Room name
     * @type {string}
     * @memberof UpdateRoomRequest
     */
    'title'?: string | null;
    /**
     * Room quota
     * @type {number}
     * @memberof UpdateRoomRequest
     */
    'quota'?: number | null;
    /**
     * Indexing
     * @type {boolean}
     * @memberof UpdateRoomRequest
     */
    'indexing'?: boolean | null;
    /**
     * Room quota
     * @type {boolean}
     * @memberof UpdateRoomRequest
     */
    'denyDownload'?: boolean | null;
    /**
     * 
     * @type {RoomDataLifetimeDto}
     * @memberof UpdateRoomRequest
     */
    'lifetime'?: RoomDataLifetimeDto;
    /**
     * 
     * @type {WatermarkRequestDto}
     * @memberof UpdateRoomRequest
     */
    'watermark'?: WatermarkRequestDto;
    /**
     * 
     * @type {LogoRequest}
     * @memberof UpdateRoomRequest
     */
    'logo'?: LogoRequest;
    /**
     * List of tags
     * @type {Array<string>}
     * @memberof UpdateRoomRequest
     */
    'tags'?: Array<string> | null;
    /**
     * Color
     * @type {string}
     * @memberof UpdateRoomRequest
     */
    'color'?: string | null;
    /**
     * Cover
     * @type {string}
     * @memberof UpdateRoomRequest
     */
    'cover'?: string | null;
}
/**
 * Request parameters for updating room
 * @export
 * @interface UpdateRoomsQuotaRequestDtoInteger
 */
export interface UpdateRoomsQuotaRequestDtoInteger {
    /**
     * List of room IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof UpdateRoomsQuotaRequestDtoInteger
     */
    'roomIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
    /**
     * Room quota
     * @type {number}
     * @memberof UpdateRoomsQuotaRequestDtoInteger
     */
    'quota'?: number;
}
/**
 * Request parameters for updating room
 * @export
 * @interface UpdateRoomsRoomIdsRequestDtoInteger
 */
export interface UpdateRoomsRoomIdsRequestDtoInteger {
    /**
     * List of room IDs
     * @type {Array<BaseBatchRequestDtoFolderIdsInner>}
     * @memberof UpdateRoomsRoomIdsRequestDtoInteger
     */
    'roomIds'?: Array<BaseBatchRequestDtoFolderIdsInner> | null;
}
/**
 * Request parameters for uploading a file
 * @export
 * @interface UploadRequestDto
 */
export interface UploadRequestDto {
    /**
     * File
     * @type {File}
     * @memberof UploadRequestDto
     */
    'file'?: File | null;
    /**
     * 
     * @type {ContentType}
     * @memberof UploadRequestDto
     */
    'contentType'?: ContentType;
    /**
     * 
     * @type {ContentDisposition}
     * @memberof UploadRequestDto
     */
    'contentDisposition'?: ContentDisposition;
    /**
     * List of files when specified as multipart/form-data
     * @type {Array<File>}
     * @memberof UploadRequestDto
     */
    'files'?: Array<File> | null;
    /**
     * Specifies whether to create a new file if it already exists or not
     * @type {boolean}
     * @memberof UploadRequestDto
     */
    'createNewIfExist'?: boolean;
    /**
     * Specifies whether to upload documents in the original formats as well or not
     * @type {boolean}
     * @memberof UploadRequestDto
     */
    'storeOriginalFileFlag'?: boolean | null;
    /**
     * Specifies whether to keep the file converting status or not
     * @type {boolean}
     * @memberof UploadRequestDto
     */
    'keepConvertStatus'?: boolean;
    /**
     * Request input stream
     * @type {File}
     * @memberof UploadRequestDto
     */
    'stream'?: File | null;
}
/**
 * 
 * @export
 * @interface UploadResultDto
 */
export interface UploadResultDto {
    /**
     * Specifies if the operation is successful or not
     * @type {boolean}
     * @memberof UploadResultDto
     */
    'success'?: boolean;
    /**
     * Data
     * @type {any}
     * @memberof UploadResultDto
     */
    'data'?: any | null;
    /**
     * Message
     * @type {string}
     * @memberof UploadResultDto
     */
    'message'?: string | null;
}
/**
 * 
 * @export
 * @interface UploadResultWrapper
 */
export interface UploadResultWrapper {
    /**
     * 
     * @type {UploadResultDto}
     * @memberof UploadResultWrapper
     */
    'response'?: UploadResultDto;
    /**
     * 
     * @type {number}
     * @memberof UploadResultWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof UploadResultWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof UploadResultWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof UploadResultWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface UsageSpaceStatItemArrayWrapper
 */
export interface UsageSpaceStatItemArrayWrapper {
    /**
     * 
     * @type {Array<UsageSpaceStatItemDto>}
     * @memberof UsageSpaceStatItemArrayWrapper
     */
    'response'?: Array<UsageSpaceStatItemDto>;
    /**
     * 
     * @type {number}
     * @memberof UsageSpaceStatItemArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof UsageSpaceStatItemArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof UsageSpaceStatItemArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsageSpaceStatItemArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface UsageSpaceStatItemDto
 */
export interface UsageSpaceStatItemDto {
    /**
     * Name
     * @type {string}
     * @memberof UsageSpaceStatItemDto
     */
    'name'?: string | null;
    /**
     * Icon
     * @type {string}
     * @memberof UsageSpaceStatItemDto
     */
    'icon'?: string | null;
    /**
     * Specifies if the module space is disabled or not
     * @type {boolean}
     * @memberof UsageSpaceStatItemDto
     */
    'disabled'?: boolean;
    /**
     * Size
     * @type {string}
     * @memberof UsageSpaceStatItemDto
     */
    'size'?: string | null;
    /**
     * URL
     * @type {string}
     * @memberof UsageSpaceStatItemDto
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface UserConfig
 */
export interface UserConfig {
    /**
     * Id
     * @type {string}
     * @memberof UserConfig
     */
    'id'?: string | null;
    /**
     * Name
     * @type {string}
     * @memberof UserConfig
     */
    'name'?: string | null;
    /**
     * Image
     * @type {string}
     * @memberof UserConfig
     */
    'image'?: string | null;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * ID
     * @type {string}
     * @memberof UserInfo
     */
    'id'?: string;
    /**
     * First name
     * @type {string}
     * @memberof UserInfo
     */
    'firstName'?: string | null;
    /**
     * Last name
     * @type {string}
     * @memberof UserInfo
     */
    'lastName'?: string | null;
    /**
     * Username
     * @type {string}
     * @memberof UserInfo
     */
    'userName'?: string | null;
    /**
     * Birthday
     * @type {string}
     * @memberof UserInfo
     */
    'birthDate'?: string | null;
    /**
     * Sex (male or female)
     * @type {boolean}
     * @memberof UserInfo
     */
    'sex'?: boolean | null;
    /**
     * 
     * @type {EmployeeStatus}
     * @memberof UserInfo
     */
    'status'?: EmployeeStatus;
    /**
     * 
     * @type {EmployeeActivationStatus}
     * @memberof UserInfo
     */
    'activationStatus'?: EmployeeActivationStatus;
    /**
     * The date and time when the user account was terminated
     * @type {string}
     * @memberof UserInfo
     */
    'terminatedDate'?: string | null;
    /**
     * Title
     * @type {string}
     * @memberof UserInfo
     */
    'title'?: string | null;
    /**
     * Registration date
     * @type {string}
     * @memberof UserInfo
     */
    'workFromDate'?: string | null;
    /**
     * Email
     * @type {string}
     * @memberof UserInfo
     */
    'email'?: string | null;
    /**
     * List of contacts in the string format
     * @type {string}
     * @memberof UserInfo
     */
    'contacts'?: string | null;
    /**
     * List of contacts
     * @type {Array<string>}
     * @memberof UserInfo
     */
    'contactsList'?: Array<string> | null;
    /**
     * Location
     * @type {string}
     * @memberof UserInfo
     */
    'location'?: string | null;
    /**
     * Notes
     * @type {string}
     * @memberof UserInfo
     */
    'notes'?: string | null;
    /**
     * Specifies if the user account was removed or not
     * @type {boolean}
     * @memberof UserInfo
     */
    'removed'?: boolean;
    /**
     * Last modified date
     * @type {string}
     * @memberof UserInfo
     */
    'lastModified'?: string;
    /**
     * Tenant ID
     * @type {number}
     * @memberof UserInfo
     */
    'tenantId'?: number;
    /**
     * Spceifies if the user is active or not
     * @type {boolean}
     * @memberof UserInfo
     */
    'isActive'?: boolean;
    /**
     * Language
     * @type {string}
     * @memberof UserInfo
     */
    'cultureName'?: string | null;
    /**
     * Mobile phone
     * @type {string}
     * @memberof UserInfo
     */
    'mobilePhone'?: string | null;
    /**
     * 
     * @type {MobilePhoneActivationStatus}
     * @memberof UserInfo
     */
    'mobilePhoneActivationStatus'?: MobilePhoneActivationStatus;
    /**
     * LDAP user identificator
     * @type {string}
     * @memberof UserInfo
     */
    'sid'?: string | null;
    /**
     * LDAP user quota attribute
     * @type {number}
     * @memberof UserInfo
     */
    'ldapQouta'?: number;
    /**
     * SSO SAML user identificator
     * @type {string}
     * @memberof UserInfo
     */
    'ssoNameId'?: string | null;
    /**
     * SSO SAML user session identificator
     * @type {string}
     * @memberof UserInfo
     */
    'ssoSessionId'?: string | null;
    /**
     * Creation date
     * @type {string}
     * @memberof UserInfo
     */
    'createDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'createdBy'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'spam'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'checkActivation'?: boolean;
}


/**
 * 
 * @export
 * @interface UserInfoWrapper
 */
export interface UserInfoWrapper {
    /**
     * 
     * @type {UserInfo}
     * @memberof UserInfoWrapper
     */
    'response'?: UserInfo;
    /**
     * 
     * @type {number}
     * @memberof UserInfoWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof UserInfoWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof UserInfoWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserInfoWrapper
     */
    'statusCode'?: number;
}
/**
 * User invitation parameters
 * @export
 * @interface UserInvitation
 */
export interface UserInvitation {
    /**
     * List of user IDs
     * @type {Array<string>}
     * @memberof UserInvitation
     */
    'usersIds'?: Array<string> | null;
    /**
     * Resend all
     * @type {boolean}
     * @memberof UserInvitation
     */
    'resendAll'?: boolean;
}
/**
 * 
 * @export
 * @interface UserInvitationRequestDto
 */
export interface UserInvitationRequestDto {
    /**
     * 
     * @type {EmployeeType}
     * @memberof UserInvitationRequestDto
     */
    'type'?: EmployeeType;
    /**
     * Email address
     * @type {string}
     * @memberof UserInvitationRequestDto
     */
    'email'?: string | null;
}


/**
 * [0 - Ok, 1 - Invalid, 2 - Expired, 3 - Tariff limit, 4 - User existed, 5 - User excluded, 6 - Quota failed]
 * @export
 * @enum {number}
 */

export const ValidationResult = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type ValidationResult = typeof ValidationResult[keyof typeof ValidationResult];


/**
 * [1 - User name, 2 - User email, 4 - User ip adress, 8 - Current date, 16 - Room name]
 * @export
 * @enum {number}
 */

export const WatermarkAdditions = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4,
    NUMBER_8: 8,
    NUMBER_16: 16
} as const;

export type WatermarkAdditions = typeof WatermarkAdditions[keyof typeof WatermarkAdditions];


/**
 * 
 * @export
 * @interface WatermarkDto
 */
export interface WatermarkDto {
    /**
     * 
     * @type {WatermarkAdditions}
     * @memberof WatermarkDto
     */
    'additions'?: WatermarkAdditions;
    /**
     * Watermark Text
     * @type {string}
     * @memberof WatermarkDto
     */
    'text'?: string | null;
    /**
     * Watermark text and image rotate
     * @type {number}
     * @memberof WatermarkDto
     */
    'rotate'?: number;
    /**
     * Watermark image scale
     * @type {number}
     * @memberof WatermarkDto
     */
    'imageScale'?: number;
    /**
     * Watermark image url
     * @type {string}
     * @memberof WatermarkDto
     */
    'imageUrl'?: string | null;
    /**
     * Watermark image height
     * @type {number}
     * @memberof WatermarkDto
     */
    'imageHeight'?: number;
    /**
     * Watermark image width
     * @type {number}
     * @memberof WatermarkDto
     */
    'imageWidth'?: number;
}


/**
 * 
 * @export
 * @interface WatermarkOnDraw
 */
export interface WatermarkOnDraw {
    /**
     * Defines the watermark width measured in millimeters.
     * @type {number}
     * @memberof WatermarkOnDraw
     */
    'width'?: number;
    /**
     * Defines the watermark height measured in millimeters.
     * @type {number}
     * @memberof WatermarkOnDraw
     */
    'height'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof WatermarkOnDraw
     */
    'margins'?: Array<number> | null;
    /**
     * 
     * @type {string}
     * @memberof WatermarkOnDraw
     */
    'fill'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WatermarkOnDraw
     */
    'rotate'?: number;
    /**
     * 
     * @type {number}
     * @memberof WatermarkOnDraw
     */
    'transparent'?: number;
    /**
     * 
     * @type {Array<Paragraph>}
     * @memberof WatermarkOnDraw
     */
    'paragraphs'?: Array<Paragraph> | null;
}
/**
 * Request parameters for adding watermarks
 * @export
 * @interface WatermarkRequestDto
 */
export interface WatermarkRequestDto {
    /**
     * Specifies whether watermarks are on or off
     * @type {boolean}
     * @memberof WatermarkRequestDto
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {WatermarkAdditions}
     * @memberof WatermarkRequestDto
     */
    'additions'?: WatermarkAdditions;
    /**
     * Watermark Text
     * @type {string}
     * @memberof WatermarkRequestDto
     */
    'text'?: string | null;
    /**
     * Watermark text and image rotate
     * @type {number}
     * @memberof WatermarkRequestDto
     */
    'rotate'?: number;
    /**
     * Watermark image scale
     * @type {number}
     * @memberof WatermarkRequestDto
     */
    'imageScale'?: number;
    /**
     * The path to the temporary image file
     * @type {string}
     * @memberof WatermarkRequestDto
     */
    'imageUrl'?: string | null;
    /**
     * Watermark image height
     * @type {number}
     * @memberof WatermarkRequestDto
     */
    'imageHeight'?: number;
    /**
     * Watermark image width
     * @type {number}
     * @memberof WatermarkRequestDto
     */
    'imageWidth'?: number;
}


/**
 * Module request parameters
 * @export
 * @interface WebItemSecurityRequestsDto
 */
export interface WebItemSecurityRequestsDto {
    /**
     * Module ID
     * @type {string}
     * @memberof WebItemSecurityRequestsDto
     */
    'id'?: string | null;
    /**
     * Specifies if the module security settings are enabled or not
     * @type {boolean}
     * @memberof WebItemSecurityRequestsDto
     */
    'enabled'?: boolean;
    /**
     * List of user/group IDs with the access to the module
     * @type {Array<string>}
     * @memberof WebItemSecurityRequestsDto
     */
    'subjects'?: Array<string> | null;
}
/**
 * Module request parameters
 * @export
 * @interface WebItemsSecurityRequestsDto
 */
export interface WebItemsSecurityRequestsDto {
    /**
     * Products with security information
     * @type {Array<ItemKeyValuePairStringBoolean>}
     * @memberof WebItemsSecurityRequestsDto
     */
    'items'?: Array<ItemKeyValuePairStringBoolean> | null;
}
/**
 * 
 * @export
 * @interface WebPluginArrayWrapper
 */
export interface WebPluginArrayWrapper {
    /**
     * 
     * @type {Array<WebPluginDto>}
     * @memberof WebPluginArrayWrapper
     */
    'response'?: Array<WebPluginDto>;
    /**
     * 
     * @type {number}
     * @memberof WebPluginArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WebPluginArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WebPluginArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebPluginArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface WebPluginDto
 */
export interface WebPluginDto {
    /**
     * Name
     * @type {string}
     * @memberof WebPluginDto
     */
    'name'?: string | null;
    /**
     * Version
     * @type {string}
     * @memberof WebPluginDto
     */
    'version'?: string | null;
    /**
     * Description
     * @type {string}
     * @memberof WebPluginDto
     */
    'description'?: string | null;
    /**
     * License
     * @type {string}
     * @memberof WebPluginDto
     */
    'license'?: string | null;
    /**
     * Author
     * @type {string}
     * @memberof WebPluginDto
     */
    'author'?: string | null;
    /**
     * Home page
     * @type {string}
     * @memberof WebPluginDto
     */
    'homePage'?: string | null;
    /**
     * PluginName
     * @type {string}
     * @memberof WebPluginDto
     */
    'pluginName'?: string | null;
    /**
     * Scopes
     * @type {string}
     * @memberof WebPluginDto
     */
    'scopes'?: string | null;
    /**
     * Image
     * @type {string}
     * @memberof WebPluginDto
     */
    'image'?: string | null;
    /**
     * 
     * @type {EmployeeDto}
     * @memberof WebPluginDto
     */
    'createBy'?: EmployeeDto;
    /**
     * Create on
     * @type {string}
     * @memberof WebPluginDto
     */
    'createOn'?: string;
    /**
     * Enabled
     * @type {boolean}
     * @memberof WebPluginDto
     */
    'enabled'?: boolean;
    /**
     * System
     * @type {boolean}
     * @memberof WebPluginDto
     */
    'system'?: boolean;
    /**
     * Url
     * @type {string}
     * @memberof WebPluginDto
     */
    'url'?: string | null;
    /**
     * Settings
     * @type {string}
     * @memberof WebPluginDto
     */
    'settings'?: string | null;
}
/**
 * 
 * @export
 * @interface WebPluginRequests
 */
export interface WebPluginRequests {
    /**
     * Enabled
     * @type {boolean}
     * @memberof WebPluginRequests
     */
    'enabled'?: boolean;
    /**
     * Settings
     * @type {string}
     * @memberof WebPluginRequests
     */
    'settings'?: string | null;
}
/**
 * 
 * @export
 * @interface WebPluginWrapper
 */
export interface WebPluginWrapper {
    /**
     * 
     * @type {WebPluginDto}
     * @memberof WebPluginWrapper
     */
    'response'?: WebPluginDto;
    /**
     * 
     * @type {number}
     * @memberof WebPluginWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WebPluginWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WebPluginWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebPluginWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * ID
     * @type {number}
     * @memberof Webhook
     */
    'id'?: number;
    /**
     * Route
     * @type {string}
     * @memberof Webhook
     */
    'route'?: string | null;
    /**
     * Method
     * @type {string}
     * @memberof Webhook
     */
    'method'?: string | null;
    /**
     * Specifies if a webhook is disabled or not
     * @type {boolean}
     * @memberof Webhook
     */
    'disable'?: boolean;
    /**
     * Name
     * @type {string}
     * @memberof Webhook
     */
    'name'?: string | null;
    /**
     * Description
     * @type {string}
     * @memberof Webhook
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface WebhookArrayWrapper
 */
export interface WebhookArrayWrapper {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookArrayWrapper
     */
    'response'?: Array<Webhook>;
    /**
     * 
     * @type {number}
     * @memberof WebhookArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WebhookArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WebhookArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * [0 - None, 1 - Not sent, 2 - Status2xx, 4 - Status3xx, 8 - Status4xx, 16 - Status5xx]
 * @export
 * @enum {number}
 */

export const WebhookGroupStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4,
    NUMBER_8: 8,
    NUMBER_16: 16
} as const;

export type WebhookGroupStatus = typeof WebhookGroupStatus[keyof typeof WebhookGroupStatus];


/**
 * Request parameters to retry webhooks
 * @export
 * @interface WebhookRetryRequestsDto
 */
export interface WebhookRetryRequestsDto {
    /**
     * List of webhook IDs
     * @type {Array<number>}
     * @memberof WebhookRetryRequestsDto
     */
    'ids'?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface WebhookWrapper
 */
export interface WebhookWrapper {
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookWrapper
     */
    'response'?: Webhook;
    /**
     * 
     * @type {number}
     * @memberof WebhookWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WebhookWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WebhookWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface WebhooksConfigDto
 */
export interface WebhooksConfigDto {
    /**
     * ID
     * @type {number}
     * @memberof WebhooksConfigDto
     */
    'id'?: number;
    /**
     * Name
     * @type {string}
     * @memberof WebhooksConfigDto
     */
    'name'?: string | null;
    /**
     * URI
     * @type {string}
     * @memberof WebhooksConfigDto
     */
    'uri'?: string | null;
    /**
     * Secret key
     * @type {string}
     * @memberof WebhooksConfigDto
     */
    'secretKey'?: string | null;
    /**
     * Specifies if the webhooks are enabled or not
     * @type {boolean}
     * @memberof WebhooksConfigDto
     */
    'enabled'?: boolean;
    /**
     * SSL
     * @type {boolean}
     * @memberof WebhooksConfigDto
     */
    'ssl'?: boolean;
}
/**
 * Webhook request parameters
 * @export
 * @interface WebhooksConfigRequestsDto
 */
export interface WebhooksConfigRequestsDto {
    /**
     * ID
     * @type {number}
     * @memberof WebhooksConfigRequestsDto
     */
    'id'?: number;
    /**
     * Name
     * @type {string}
     * @memberof WebhooksConfigRequestsDto
     */
    'name': string;
    /**
     * URI
     * @type {string}
     * @memberof WebhooksConfigRequestsDto
     */
    'uri': string;
    /**
     * Secret key
     * @type {string}
     * @memberof WebhooksConfigRequestsDto
     */
    'secretKey'?: string | null;
    /**
     * Enabled or not
     * @type {boolean}
     * @memberof WebhooksConfigRequestsDto
     */
    'enabled'?: boolean | null;
    /**
     * SSL
     * @type {boolean}
     * @memberof WebhooksConfigRequestsDto
     */
    'ssl'?: boolean | null;
}
/**
 * 
 * @export
 * @interface WebhooksConfigWithStatusArrayWrapper
 */
export interface WebhooksConfigWithStatusArrayWrapper {
    /**
     * 
     * @type {Array<WebhooksConfigWithStatusDto>}
     * @memberof WebhooksConfigWithStatusArrayWrapper
     */
    'response'?: Array<WebhooksConfigWithStatusDto>;
    /**
     * 
     * @type {number}
     * @memberof WebhooksConfigWithStatusArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WebhooksConfigWithStatusArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WebhooksConfigWithStatusArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhooksConfigWithStatusArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface WebhooksConfigWithStatusDto
 */
export interface WebhooksConfigWithStatusDto {
    /**
     * 
     * @type {WebhooksConfigDto}
     * @memberof WebhooksConfigWithStatusDto
     */
    'configs'?: WebhooksConfigDto;
    /**
     * Status
     * @type {number}
     * @memberof WebhooksConfigWithStatusDto
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface WebhooksConfigWrapper
 */
export interface WebhooksConfigWrapper {
    /**
     * 
     * @type {WebhooksConfigDto}
     * @memberof WebhooksConfigWrapper
     */
    'response'?: WebhooksConfigDto;
    /**
     * 
     * @type {number}
     * @memberof WebhooksConfigWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WebhooksConfigWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WebhooksConfigWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhooksConfigWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface WebhooksLogArrayWrapper
 */
export interface WebhooksLogArrayWrapper {
    /**
     * 
     * @type {Array<WebhooksLogDto>}
     * @memberof WebhooksLogArrayWrapper
     */
    'response'?: Array<WebhooksLogDto>;
    /**
     * 
     * @type {number}
     * @memberof WebhooksLogArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WebhooksLogArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WebhooksLogArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhooksLogArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface WebhooksLogDto
 */
export interface WebhooksLogDto {
    /**
     * ID
     * @type {number}
     * @memberof WebhooksLogDto
     */
    'id'?: number;
    /**
     * Config name
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'configName'?: string | null;
    /**
     * Creation time
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'creationTime'?: string;
    /**
     * Method
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'method'?: string | null;
    /**
     * Route
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'route'?: string | null;
    /**
     * Request headers
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'requestHeaders'?: string | null;
    /**
     * Request payload
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'requestPayload'?: string | null;
    /**
     * Response headers
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'responseHeaders'?: string | null;
    /**
     * Response payload
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'responsePayload'?: string | null;
    /**
     * Status
     * @type {number}
     * @memberof WebhooksLogDto
     */
    'status'?: number;
    /**
     * Delivery time
     * @type {string}
     * @memberof WebhooksLogDto
     */
    'delivery'?: string | null;
}
/**
 * 
 * @export
 * @interface WebhooksLogWrapper
 */
export interface WebhooksLogWrapper {
    /**
     * 
     * @type {WebhooksLogDto}
     * @memberof WebhooksLogWrapper
     */
    'response'?: WebhooksLogDto;
    /**
     * 
     * @type {number}
     * @memberof WebhooksLogWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WebhooksLogWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WebhooksLogWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhooksLogWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface WhiteLabelItemArrayWrapper
 */
export interface WhiteLabelItemArrayWrapper {
    /**
     * 
     * @type {Array<WhiteLabelItemDto>}
     * @memberof WhiteLabelItemArrayWrapper
     */
    'response'?: Array<WhiteLabelItemDto>;
    /**
     * 
     * @type {number}
     * @memberof WhiteLabelItemArrayWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WhiteLabelItemArrayWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WhiteLabelItemArrayWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WhiteLabelItemArrayWrapper
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface WhiteLabelItemDto
 */
export interface WhiteLabelItemDto {
    /**
     * File name
     * @type {string}
     * @memberof WhiteLabelItemDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {IMagickGeometry}
     * @memberof WhiteLabelItemDto
     */
    'size'?: IMagickGeometry;
    /**
     * 
     * @type {WhiteLabelItemPathDto}
     * @memberof WhiteLabelItemDto
     */
    'path'?: WhiteLabelItemPathDto;
}
/**
 * 
 * @export
 * @interface WhiteLabelItemPathDto
 */
export interface WhiteLabelItemPathDto {
    /**
     * Path to the light theme logo
     * @type {string}
     * @memberof WhiteLabelItemPathDto
     */
    'light'?: string | null;
    /**
     * Path to the dark theme logo
     * @type {string}
     * @memberof WhiteLabelItemPathDto
     */
    'dark'?: string | null;
}
/**
 * Request parameters for white label settings
 * @export
 * @interface WhiteLabelRequestsDto
 */
export interface WhiteLabelRequestsDto {
    /**
     * Logo text
     * @type {string}
     * @memberof WhiteLabelRequestsDto
     */
    'logoText'?: string | null;
    /**
     * Tenant IDs with their logos (light or dark)
     * @type {Array<ItemKeyValuePairStringLogoRequestsDto>}
     * @memberof WhiteLabelRequestsDto
     */
    'logo'?: Array<ItemKeyValuePairStringLogoRequestsDto> | null;
}
/**
 * Wizard settings request parameters
 * @export
 * @interface WizardRequestsDto
 */
export interface WizardRequestsDto {
    /**
     * Email
     * @type {string}
     * @memberof WizardRequestsDto
     */
    'email'?: string | null;
    /**
     * Password hash
     * @type {string}
     * @memberof WizardRequestsDto
     */
    'passwordHash'?: string | null;
    /**
     * Language
     * @type {string}
     * @memberof WizardRequestsDto
     */
    'lng'?: string | null;
    /**
     * Time zone
     * @type {string}
     * @memberof WizardRequestsDto
     */
    'timeZone'?: string | null;
    /**
     * AMI ID
     * @type {string}
     * @memberof WizardRequestsDto
     */
    'amiId'?: string | null;
    /**
     * Subscribed from the site or not
     * @type {boolean}
     * @memberof WizardRequestsDto
     */
    'subscribeFromSite'?: boolean;
}
/**
 * 
 * @export
 * @interface WizardSettings
 */
export interface WizardSettings {
    /**
     * Specifies if the Wizard settings are completed or not
     * @type {boolean}
     * @memberof WizardSettings
     */
    'completed'?: boolean;
}
/**
 * 
 * @export
 * @interface WizardSettingsWrapper
 */
export interface WizardSettingsWrapper {
    /**
     * 
     * @type {WizardSettings}
     * @memberof WizardSettingsWrapper
     */
    'response'?: WizardSettings;
    /**
     * 
     * @type {number}
     * @memberof WizardSettingsWrapper
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ActiveConnectionsWrapperLinksInner>}
     * @memberof WizardSettingsWrapper
     */
    'links'?: Array<ActiveConnectionsWrapperLinksInner>;
    /**
     * 
     * @type {number}
     * @memberof WizardSettingsWrapper
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof WizardSettingsWrapper
     */
    'statusCode'?: number;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticates the current user by SMS, authenticator app, or without two-factor authentication.
         * @summary Authenticate a user
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateMe: async (authRequestsDto?: AuthRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticates the current user by SMS or two-factor authentication code.
         * @summary Authenticate a user by code
         * @param {string} code 
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateMeFromBodyWithCode: async (code: string, authRequestsDto?: AuthRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('authenticateMeFromBodyWithCode', 'code', code)
            const localVarPath = `/api/2.0/authentication/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Opens a confirmation email URL to validate a certain action (employee invitation, portal removal, phone activation, etc.).
         * @summary Open confirmation email URL
         * @param {EmailValidationKeyModel} [emailValidationKeyModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConfirm: async (emailValidationKeyModel?: EmailValidationKeyModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/authentication/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailValidationKeyModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the current user is authenticated or not.
         * @summary Check authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsAuthentificated: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out of the current user account.
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/authentication/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a mobile phone for the current user.
         * @summary Set a mobile phone
         * @param {MobileRequestsDto} [mobileRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveMobilePhone: async (mobileRequestsDto?: MobileRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/authentication/setphone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mobileRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends SMS with an authentication code.
         * @summary Send SMS code
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSmsCode: async (authRequestsDto?: AuthRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/authentication/sendsms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticates the current user by SMS, authenticator app, or without two-factor authentication.
         * @summary Authenticate a user
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateMe(authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateMe(authRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authenticateMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticates the current user by SMS or two-factor authentication code.
         * @summary Authenticate a user by code
         * @param {string} code 
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateMeFromBodyWithCode(code: string, authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateMeFromBodyWithCode(code, authRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authenticateMeFromBodyWithCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Opens a confirmation email URL to validate a certain action (employee invitation, portal removal, phone activation, etc.).
         * @summary Open confirmation email URL
         * @param {EmailValidationKeyModel} [emailValidationKeyModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkConfirm(emailValidationKeyModel?: EmailValidationKeyModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkConfirm(emailValidationKeyModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.checkConfirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the current user is authenticated or not.
         * @summary Check authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIsAuthentificated(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIsAuthentificated(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getIsAuthentificated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs out of the current user account.
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets a mobile phone for the current user.
         * @summary Set a mobile phone
         * @param {MobileRequestsDto} [mobileRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveMobilePhone(mobileRequestsDto?: MobileRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveMobilePhone(mobileRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.saveMobilePhone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends SMS with an authentication code.
         * @summary Send SMS code
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSmsCode(authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendSmsCode(authRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.sendSmsCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Authenticates the current user by SMS, authenticator app, or without two-factor authentication.
         * @summary Authenticate a user
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateMe(authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenWrapper> {
            return localVarFp.authenticateMe(authRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticates the current user by SMS or two-factor authentication code.
         * @summary Authenticate a user by code
         * @param {string} code 
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateMeFromBodyWithCode(code: string, authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenWrapper> {
            return localVarFp.authenticateMeFromBodyWithCode(code, authRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Opens a confirmation email URL to validate a certain action (employee invitation, portal removal, phone activation, etc.).
         * @summary Open confirmation email URL
         * @param {EmailValidationKeyModel} [emailValidationKeyModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConfirm(emailValidationKeyModel?: EmailValidationKeyModel, options?: RawAxiosRequestConfig): AxiosPromise<ConfirmWrapper> {
            return localVarFp.checkConfirm(emailValidationKeyModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the current user is authenticated or not.
         * @summary Check authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsAuthentificated(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.getIsAuthentificated(options).then((request) => request(axios, basePath));
        },
        /**
         * Logs out of the current user account.
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a mobile phone for the current user.
         * @summary Set a mobile phone
         * @param {MobileRequestsDto} [mobileRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveMobilePhone(mobileRequestsDto?: MobileRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenWrapper> {
            return localVarFp.saveMobilePhone(mobileRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends SMS with an authentication code.
         * @summary Send SMS code
         * @param {AuthRequestsDto} [authRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSmsCode(authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenWrapper> {
            return localVarFp.sendSmsCode(authRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Authenticates the current user by SMS, authenticator app, or without two-factor authentication.
     * @summary Authenticate a user
     * @param {AuthRequestsDto} [authRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticateMe(authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticateMe(authRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticates the current user by SMS or two-factor authentication code.
     * @summary Authenticate a user by code
     * @param {string} code 
     * @param {AuthRequestsDto} [authRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticateMeFromBodyWithCode(code: string, authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticateMeFromBodyWithCode(code, authRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Opens a confirmation email URL to validate a certain action (employee invitation, portal removal, phone activation, etc.).
     * @summary Open confirmation email URL
     * @param {EmailValidationKeyModel} [emailValidationKeyModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public checkConfirm(emailValidationKeyModel?: EmailValidationKeyModel, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).checkConfirm(emailValidationKeyModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the current user is authenticated or not.
     * @summary Check authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getIsAuthentificated(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getIsAuthentificated(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs out of the current user account.
     * @summary Log out
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a mobile phone for the current user.
     * @summary Set a mobile phone
     * @param {MobileRequestsDto} [mobileRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public saveMobilePhone(mobileRequestsDto?: MobileRequestsDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).saveMobilePhone(mobileRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends SMS with an authentication code.
     * @summary Send SMS code
     * @param {AuthRequestsDto} [authRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public sendSmsCode(authRequestsDto?: AuthRequestsDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).sendSmsCode(authRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BackupApi - axios parameter creator
 * @export
 */
export const BackupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates the backup schedule of the current portal with the parameters specified in the request.
         * @summary Create the backup schedule
         * @param {BackupScheduleDto} [backupScheduleDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackupSchedule: async (backupScheduleDto?: BackupScheduleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/createbackupschedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupScheduleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the backup with the ID specified in the request.
         * @summary Delete the backup
         * @param {string} id Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBackup', 'id', id)
            const localVarPath = `/api/2.0/backup/deletebackup/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the backup history of the current portal.
         * @summary Delete the backup history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/deletebackuphistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the backup schedule of the current portal.
         * @summary Delete the backup schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupSchedule: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/deletebackupschedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the history of the started backup.
         * @summary Get the backup history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/getbackuphistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the progress of the started backup.
         * @summary Get the backup progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupProgress: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/getbackupprogress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the backup schedule of the current portal.
         * @summary Get the backup schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupSchedule: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/getbackupschedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the progress of the started restoring process.
         * @summary Get the restoring progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestoreProgress: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/getrestoreprogress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the backup of the current portal with the parameters specified in the request.
         * @summary Start the backup
         * @param {BackupDto} [backupDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBackup: async (backupDto?: BackupDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/startbackup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the data restoring process of the current portal with the parameters specified in the request.
         * @summary Start the restoring process
         * @param {BackupRestoreDto} [backupRestoreDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBackupRestore: async (backupRestoreDto?: BackupRestoreDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/backup/startrestore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupRestoreDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupApi - functional programming interface
 * @export
 */
export const BackupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates the backup schedule of the current portal with the parameters specified in the request.
         * @summary Create the backup schedule
         * @param {BackupScheduleDto} [backupScheduleDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBackupSchedule(backupScheduleDto?: BackupScheduleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBackupSchedule(backupScheduleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.createBackupSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the backup with the ID specified in the request.
         * @summary Delete the backup
         * @param {string} id Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.deleteBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the backup history of the current portal.
         * @summary Delete the backup history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackupHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackupHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.deleteBackupHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the backup schedule of the current portal.
         * @summary Delete the backup schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackupSchedule(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackupSchedule(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.deleteBackupSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the history of the started backup.
         * @summary Get the backup history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupHistoryRecordArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.getBackupHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the progress of the started backup.
         * @summary Get the backup progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupProgress(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupProgressWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupProgress(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.getBackupProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the backup schedule of the current portal.
         * @summary Get the backup schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupSchedule(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupSchedule(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.getBackupSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the progress of the started restoring process.
         * @summary Get the restoring progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestoreProgress(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupProgressWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRestoreProgress(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.getRestoreProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the backup of the current portal with the parameters specified in the request.
         * @summary Start the backup
         * @param {BackupDto} [backupDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startBackup(backupDto?: BackupDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupProgressWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startBackup(backupDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.startBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the data restoring process of the current portal with the parameters specified in the request.
         * @summary Start the restoring process
         * @param {BackupRestoreDto} [backupRestoreDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startBackupRestore(backupRestoreDto?: BackupRestoreDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupProgressWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startBackupRestore(backupRestoreDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupApi.startBackupRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BackupApi - factory interface
 * @export
 */
export const BackupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupApiFp(configuration)
    return {
        /**
         * Creates the backup schedule of the current portal with the parameters specified in the request.
         * @summary Create the backup schedule
         * @param {BackupScheduleDto} [backupScheduleDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackupSchedule(backupScheduleDto?: BackupScheduleDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.createBackupSchedule(backupScheduleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the backup with the ID specified in the request.
         * @summary Delete the backup
         * @param {string} id Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.deleteBackup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the backup history of the current portal.
         * @summary Delete the backup history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupHistory(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.deleteBackupHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the backup schedule of the current portal.
         * @summary Delete the backup schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupSchedule(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.deleteBackupSchedule(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the history of the started backup.
         * @summary Get the backup history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupHistory(options?: RawAxiosRequestConfig): AxiosPromise<BackupHistoryRecordArrayWrapper> {
            return localVarFp.getBackupHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the progress of the started backup.
         * @summary Get the backup progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupProgress(options?: RawAxiosRequestConfig): AxiosPromise<BackupProgressWrapper> {
            return localVarFp.getBackupProgress(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the backup schedule of the current portal.
         * @summary Get the backup schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupSchedule(options?: RawAxiosRequestConfig): AxiosPromise<ScheduleWrapper> {
            return localVarFp.getBackupSchedule(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the progress of the started restoring process.
         * @summary Get the restoring progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestoreProgress(options?: RawAxiosRequestConfig): AxiosPromise<BackupProgressWrapper> {
            return localVarFp.getRestoreProgress(options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the backup of the current portal with the parameters specified in the request.
         * @summary Start the backup
         * @param {BackupDto} [backupDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBackup(backupDto?: BackupDto, options?: RawAxiosRequestConfig): AxiosPromise<BackupProgressWrapper> {
            return localVarFp.startBackup(backupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the data restoring process of the current portal with the parameters specified in the request.
         * @summary Start the restoring process
         * @param {BackupRestoreDto} [backupRestoreDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBackupRestore(backupRestoreDto?: BackupRestoreDto, options?: RawAxiosRequestConfig): AxiosPromise<BackupProgressWrapper> {
            return localVarFp.startBackupRestore(backupRestoreDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackupApi - object-oriented interface
 * @export
 * @class BackupApi
 * @extends {BaseAPI}
 */
export class BackupApi extends BaseAPI {
    /**
     * Creates the backup schedule of the current portal with the parameters specified in the request.
     * @summary Create the backup schedule
     * @param {BackupScheduleDto} [backupScheduleDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public createBackupSchedule(backupScheduleDto?: BackupScheduleDto, options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).createBackupSchedule(backupScheduleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the backup with the ID specified in the request.
     * @summary Delete the backup
     * @param {string} id Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public deleteBackup(id: string, options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).deleteBackup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the backup history of the current portal.
     * @summary Delete the backup history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public deleteBackupHistory(options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).deleteBackupHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the backup schedule of the current portal.
     * @summary Delete the backup schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public deleteBackupSchedule(options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).deleteBackupSchedule(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the history of the started backup.
     * @summary Get the backup history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public getBackupHistory(options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).getBackupHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the progress of the started backup.
     * @summary Get the backup progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public getBackupProgress(options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).getBackupProgress(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the backup schedule of the current portal.
     * @summary Get the backup schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public getBackupSchedule(options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).getBackupSchedule(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the progress of the started restoring process.
     * @summary Get the restoring progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public getRestoreProgress(options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).getRestoreProgress(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the backup of the current portal with the parameters specified in the request.
     * @summary Start the backup
     * @param {BackupDto} [backupDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public startBackup(backupDto?: BackupDto, options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).startBackup(backupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the data restoring process of the current portal with the parameters specified in the request.
     * @summary Start the restoring process
     * @param {BackupRestoreDto} [backupRestoreDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public startBackupRestore(backupRestoreDto?: BackupRestoreDto, options?: RawAxiosRequestConfig) {
        return BackupApiFp(this.configuration).startBackupRestore(backupRestoreDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CapabilitiesApi - axios parameter creator
 * @export
 */
export const CapabilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the information about portal capabilities.
         * @summary Get portal capabilities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCapabilities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CapabilitiesApi - functional programming interface
 * @export
 */
export const CapabilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CapabilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the information about portal capabilities.
         * @summary Get portal capabilities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortalCapabilities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CapabilitiesWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortalCapabilities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapabilitiesApi.getPortalCapabilities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CapabilitiesApi - factory interface
 * @export
 */
export const CapabilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CapabilitiesApiFp(configuration)
    return {
        /**
         * Returns the information about portal capabilities.
         * @summary Get portal capabilities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortalCapabilities(options?: RawAxiosRequestConfig): AxiosPromise<CapabilitiesWrapper> {
            return localVarFp.getPortalCapabilities(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CapabilitiesApi - object-oriented interface
 * @export
 * @class CapabilitiesApi
 * @extends {BaseAPI}
 */
export class CapabilitiesApi extends BaseAPI {
    /**
     * Returns the information about portal capabilities.
     * @summary Get portal capabilities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApi
     */
    public getPortalCapabilities(options?: RawAxiosRequestConfig) {
        return CapabilitiesApiFp(this.configuration).getPortalCapabilities(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesFilesApi - axios parameter creator
 * @export
 */
export const FilesFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds files with the IDs specified in the request to the template list.
         * @summary Add template files
         * @param {TemplatesRequestDto} [templatesRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplates: async (templatesRequestDto?: TemplatesRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the version history of a file with the ID specified in the request.
         * @summary Change version history
         * @param {number} fileId File Id
         * @param {ChangeHistory} [changeHistory] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeHistory: async (fileId: number, changeHistory?: ChangeHistory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('changeHistory', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/history`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeHistory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the current file is a form draft which can be filled out.
         * @summary Check the form draft
         * @param {number} fileId File ID
         * @param {CheckFillFormDraft} [checkFillFormDraft] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFillFormDraft: async (fileId: number, checkFillFormDraft?: CheckFillFormDraft, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('checkFillFormDraft', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/masterform/{fileId}/checkfillformdraft`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkFillFormDraft, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copies (and converts if possible) an existing file to the specified folder.
         * @summary Copy a file
         * @param {number} fileId File id
         * @param {CopyAsJsonElement} [copyAsJsonElement] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFileAs: async (fileId: number, copyAsJsonElement?: CopyAsJsonElement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('copyFileAs', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/copyas`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(copyAsJsonElement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session to edit the existing file with multiple chunks (needed for WebDAV).
         * @summary Create the editing session
         * @param {number} fileId File ID
         * @param {number} [fileSize] File size in bytes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEditSession: async (fileId: number, fileSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('createEditSession', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/edit_session`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (fileSize !== undefined) {
                localVarQueryParameter['fileSize'] = fileSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new file in the specified folder with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file
         * @param {number} folderId Folder ID
         * @param {CreateFileJsonElement} [createFileJsonElement] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (folderId: number, createFileJsonElement?: CreateFileJsonElement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/file`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileJsonElement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new file in the \"My documents\" section with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file in the \"My documents\" section
         * @param {CreateFileJsonElement} [createFileJsonElement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileMyDocuments: async (createFileJsonElement?: CreateFileJsonElement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileJsonElement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an HTML (.html) file in the selected folder with the title and contents specified in the request.
         * @summary Create an HTML file
         * @param {number} folderId Folder ID
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHtmlFile: async (folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createHtmlFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/html`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextOrHtmlFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an HTML (.html) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create an HTML file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHtmlFileInMy: async (createTextOrHtmlFile?: CreateTextOrHtmlFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextOrHtmlFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a primary external link by the identifier specified in the request.
         * @summary Create primary external link
         * @param {number} id File ID
         * @param {FileLinkRequest} [fileLinkRequest] External link parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrimaryExternalLink: async (id: number, fileLinkRequest?: FileLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPrimaryExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a text (.txt) file in the selected folder with the title and contents specified in the request.
         * @summary Create a txt file
         * @param {number} folderId Folder ID
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextFile: async (folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createTextFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/text`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextOrHtmlFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a text (.txt) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create a text file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextFileInMy: async (createTextOrHtmlFile?: CreateTextOrHtmlFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextOrHtmlFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates thumbnails for the files with the IDs specified in the request.
         * @summary Create thumbnails
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThumbnails: async (baseBatchRequestDto?: BaseBatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thumbnails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseBatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a file with the ID specified in the request.
         * @summary Delete a file
         * @param {number} fileId File ID
         * @param {Delete} [_delete] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (fileId: number, _delete?: Delete, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_delete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes files with the IDs specified in the request from the \"Recent\" section.
         * @summary Delete recent files
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecent: async (baseBatchRequestDto?: BaseBatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseBatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes files with the IDs specified in the request from the template list.
         * @summary Delete template files
         * @param {Array<number>} [requestBody] File IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplates: async (requestBody?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a URL to the changes of a file version specified in the request.
         * @summary Get changes URL
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditDiffUrl: async (fileId: number, version?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getEditDiffUrl', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/edit/diff`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the version history of a file with the ID specified in the request.
         * @summary Get version history
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditHistory: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getEditHistory', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/edit/history`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of actions performed on the file with the specified identifier
         * @summary Get file history
         * @param {number} fileId File ID
         * @param {ApiDateTime} [fromDate] Start date
         * @param {ApiDateTime} [toDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileHistory: async (fileId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileHistory', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/log`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (fromDate !== undefined) {
                for (const [key, value] of Object.entries(fromDate)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (toDate !== undefined) {
                for (const [key, value] of Object.entries(toDate)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about a file with the ID specified in the request.
         * @summary Get file information
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileInfo: async (fileId: number, version?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileInfo', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilePrimaryExternalLink: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFilePrimaryExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about all the available file versions with the ID specified in the request.
         * @summary Get file versions
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileVersionInfo: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileVersionInfo', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/history`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets fill result
         * @summary Gets fill result
         * @param {string} [fillingSessionId] Filling session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFillResult: async (fillingSessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/file/fillresult`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fillingSessionId !== undefined) {
                localVarQueryParameter['fillingSessionId'] = fillingSessionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the external links of a file with the ID specified in the request.
         * @summary Get file external links
         * @param {number} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinks: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLinks', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a link to download a file with the ID specified in the request asynchronously.
         * @summary Get file download link asynchronously
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedFileUri: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getPresignedFileUri', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/presigned`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a link to download a file with the ID specified in the request.
         * @summary Get file download link
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUri: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getPresignedUri', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/presigneduri`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the reference data to uniquely identify a file in its system and check the availability of insering data into the destination spreadsheet by the external link.
         * @summary Get reference data
         * @param {GetReferenceDataDtoInteger} [getReferenceDataDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceData: async (getReferenceDataDtoInteger?: GetReferenceDataDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/file/referencedata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getReferenceDataDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the PDF file is form or not.
         * @summary Check the PDF file
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isFormPDF: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('isFormPDF', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/isformpdf`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Locks a file with the ID specified in the request.
         * @summary Lock a file
         * @param {number} fileId File ID
         * @param {LockFileParameters} [lockFileParameters] Parameters for locking a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockFile: async (fileId: number, lockFileParameters?: LockFileParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('lockFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/lock`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lockFileParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the initialization configuration of a file to open it in the editor.
         * @summary Open a file
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {boolean} [view] Specifies if a document will be opened for viewing only or not
         * @param {EditorType} [editorType] Editor type
         * @param {boolean} [edit] Edit
         * @param {boolean} [fill] Fill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openEdit: async (fileId: number, version?: number, view?: boolean, editorType?: EditorType, edit?: boolean, fill?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('openEdit', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/openedit`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (editorType !== undefined) {
                localVarQueryParameter['editorType'] = editorType;
            }

            if (edit !== undefined) {
                localVarQueryParameter['edit'] = edit;
            }

            if (fill !== undefined) {
                localVarQueryParameter['fill'] = fill;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users with their access rights to the protected file with the ID specified in the request.
         * @summary Get users with the access to the protected file
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protectUsers: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('protectUsers', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/protectusers`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores a file version specified in the request.
         * @summary Restore a file version
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {string} [url] File version URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreVersion: async (fileId: number, version?: number, url?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('restoreVersion', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/restoreversion`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves a file with the identifier specified in the request as a PDF document
         * @summary Save as pdf
         * @param {number} id File ID
         * @param {SaveAsPdfInteger} [saveAsPdfInteger] Parameters for saving file as pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAsPdf: async (id: number, saveAsPdfInteger?: SaveAsPdfInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('saveAsPdf', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/saveaspdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveAsPdfInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves edits to a file with the ID specified in the request.
         * @summary Save file edits
         * @param {number} fileId File ID
         * @param {string} [fileExtension] File extension
         * @param {string} [downloadUri] URI to download a file
         * @param {File} [file] Request file stream
         * @param {boolean} [forcesave] Specifies whether to force save a file or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEditingFromForm: async (fileId: number, fileExtension?: string, downloadUri?: string, file?: File, forcesave?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('saveEditingFromForm', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/saveediting`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication asc_auth_key required


            if (fileExtension !== undefined) { 
                localVarFormParams.append('FileExtension', fileExtension as any);
            }
    
            if (downloadUri !== undefined) { 
                localVarFormParams.append('DownloadUri', downloadUri as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
            if (forcesave !== undefined) { 
                localVarFormParams.append('Forcesave', String(forcesave) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets an external link to a file with the ID specified in the request.
         * @summary Set an external link
         * @param {number} id File ID
         * @param {FileLinkRequest} [fileLinkRequest] External link parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalLink: async (id: number, fileLinkRequest?: FileLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/file/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets order
         * @summary Sets order
         * @param {OrdersRequestDtoInteger} [ordersRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFilesOrder: async (ordersRequestDtoInteger?: OrdersRequestDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ordersRequestDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets order of a file with ID specified in the request
         * @summary Sets order of a file with ID specified in the request
         * @param {number} fileId The unique identifier of the file
         * @param {OrderRequestDto} [orderRequestDto] Order information for the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrderFile: async (fileId: number, orderRequestDto?: OrderRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('setOrderFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/{fileId}/order`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Informs about opening a file with the ID specified in the request for editing, locking it from being deleted or moved (this method is called by the mobile editors).
         * @summary Start file editing
         * @param {number} fileId File ID
         * @param {StartEdit} [startEdit] Parameters for starting file editing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEdit: async (fileId: number, startEdit?: StartEdit, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('startEdit', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/startedit`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startEdit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts filling a file with the ID specified in the request.
         * @summary Starts filling
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFilling: async (fileId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('startFilling', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/startfilling`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tracks file changes when editing.
         * @summary Track file editing
         * @param {number} fileId File ID
         * @param {string} [tabId] Tab ID
         * @param {string} [docKeyForTrack] Document key for tracking
         * @param {boolean} [isFinish] Specifies whether to finish file tracking or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEditFile: async (fileId: number, tabId?: string, docKeyForTrack?: string, isFinish?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('trackEditFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/trackeditfile`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tabId !== undefined) {
                localVarQueryParameter['tabId'] = tabId;
            }

            if (docKeyForTrack !== undefined) {
                localVarQueryParameter['docKeyForTrack'] = docKeyForTrack;
            }

            if (isFinish !== undefined) {
                localVarQueryParameter['isFinish'] = isFinish;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the information of the selected file with the parameters specified in the request.
         * @summary Update a file
         * @param {number} fileId File ID
         * @param {UpdateFile} [updateFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (fileId: number, updateFile?: UpdateFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('updateFile', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesFilesApi - functional programming interface
 * @export
 */
export const FilesFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds files with the IDs specified in the request to the template list.
         * @summary Add template files
         * @param {TemplatesRequestDto} [templatesRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTemplates(templatesRequestDto?: TemplatesRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTemplates(templatesRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.addTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the version history of a file with the ID specified in the request.
         * @summary Change version history
         * @param {number} fileId File Id
         * @param {ChangeHistory} [changeHistory] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeHistory(fileId: number, changeHistory?: ChangeHistory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeHistory(fileId, changeHistory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.changeHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the current file is a form draft which can be filled out.
         * @summary Check the form draft
         * @param {number} fileId File ID
         * @param {CheckFillFormDraft} [checkFillFormDraft] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkFillFormDraft(fileId: number, checkFillFormDraft?: CheckFillFormDraft, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkFillFormDraft(fileId, checkFillFormDraft, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.checkFillFormDraft']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Copies (and converts if possible) an existing file to the specified folder.
         * @summary Copy a file
         * @param {number} fileId File id
         * @param {CopyAsJsonElement} [copyAsJsonElement] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyFileAs(fileId: number, copyAsJsonElement?: CopyAsJsonElement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyFileAs(fileId, copyAsJsonElement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.copyFileAs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a session to edit the existing file with multiple chunks (needed for WebDAV).
         * @summary Create the editing session
         * @param {number} fileId File ID
         * @param {number} [fileSize] File size in bytes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEditSession(fileId: number, fileSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEditSession(fileId, fileSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createEditSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new file in the specified folder with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file
         * @param {number} folderId Folder ID
         * @param {CreateFileJsonElement} [createFileJsonElement] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(folderId: number, createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(folderId, createFileJsonElement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new file in the \"My documents\" section with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file in the \"My documents\" section
         * @param {CreateFileJsonElement} [createFileJsonElement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFileMyDocuments(createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFileMyDocuments(createFileJsonElement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createFileMyDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an HTML (.html) file in the selected folder with the title and contents specified in the request.
         * @summary Create an HTML file
         * @param {number} folderId Folder ID
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHtmlFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHtmlFile(folderId, createTextOrHtmlFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createHtmlFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an HTML (.html) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create an HTML file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHtmlFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHtmlFileInMy(createTextOrHtmlFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createHtmlFileInMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a primary external link by the identifier specified in the request.
         * @summary Create primary external link
         * @param {number} id File ID
         * @param {FileLinkRequest} [fileLinkRequest] External link parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrimaryExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrimaryExternalLink(id, fileLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createPrimaryExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a text (.txt) file in the selected folder with the title and contents specified in the request.
         * @summary Create a txt file
         * @param {number} folderId Folder ID
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTextFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTextFile(folderId, createTextOrHtmlFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createTextFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a text (.txt) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create a text file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTextFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTextFileInMy(createTextOrHtmlFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createTextFileInMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates thumbnails for the files with the IDs specified in the request.
         * @summary Create thumbnails
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThumbnails(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThumbnails(baseBatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.createThumbnails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a file with the ID specified in the request.
         * @summary Delete a file
         * @param {number} fileId File ID
         * @param {Delete} [_delete] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(fileId: number, _delete?: Delete, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(fileId, _delete, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.deleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes files with the IDs specified in the request from the \"Recent\" section.
         * @summary Delete recent files
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecent(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoContentResultWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecent(baseBatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.deleteRecent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes files with the IDs specified in the request from the template list.
         * @summary Delete template files
         * @param {Array<number>} [requestBody] File IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplates(requestBody?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplates(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.deleteTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a URL to the changes of a file version specified in the request.
         * @summary Get changes URL
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEditDiffUrl(fileId: number, version?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditHistoryDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEditDiffUrl(fileId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getEditDiffUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the version history of a file with the ID specified in the request.
         * @summary Get version history
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEditHistory(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditHistoryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEditHistory(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getEditHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of actions performed on the file with the specified identifier
         * @summary Get file history
         * @param {number} fileId File ID
         * @param {ApiDateTime} [fromDate] Start date
         * @param {ApiDateTime} [toDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileHistory(fileId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileHistory(fileId, fromDate, toDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFileHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about a file with the ID specified in the request.
         * @summary Get file information
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileInfo(fileId: number, version?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileInfo(fileId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFileInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilePrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilePrimaryExternalLink(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFilePrimaryExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about all the available file versions with the ID specified in the request.
         * @summary Get file versions
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileVersionInfo(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileVersionInfo(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFileVersionInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets fill result
         * @summary Gets fill result
         * @param {string} [fillingSessionId] Filling session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFillResult(fillingSessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FillingFormResultIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFillResult(fillingSessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getFillResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the external links of a file with the ID specified in the request.
         * @summary Get file external links
         * @param {number} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinks(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinks(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a link to download a file with the ID specified in the request asynchronously.
         * @summary Get file download link asynchronously
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedFileUri(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileLinkWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedFileUri(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getPresignedFileUri']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a link to download a file with the ID specified in the request.
         * @summary Get file download link
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUri(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUri(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getPresignedUri']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the reference data to uniquely identify a file in its system and check the availability of insering data into the destination spreadsheet by the external link.
         * @summary Get reference data
         * @param {GetReferenceDataDtoInteger} [getReferenceDataDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferenceData(getReferenceDataDtoInteger?: GetReferenceDataDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileReferenceWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferenceData(getReferenceDataDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.getReferenceData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the PDF file is form or not.
         * @summary Check the PDF file
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isFormPDF(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isFormPDF(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.isFormPDF']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Locks a file with the ID specified in the request.
         * @summary Lock a file
         * @param {number} fileId File ID
         * @param {LockFileParameters} [lockFileParameters] Parameters for locking a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockFile(fileId: number, lockFileParameters?: LockFileParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockFile(fileId, lockFileParameters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.lockFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the initialization configuration of a file to open it in the editor.
         * @summary Open a file
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {boolean} [view] Specifies if a document will be opened for viewing only or not
         * @param {EditorType} [editorType] Editor type
         * @param {boolean} [edit] Edit
         * @param {boolean} [fill] Fill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openEdit(fileId: number, version?: number, view?: boolean, editorType?: EditorType, edit?: boolean, fill?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openEdit(fileId, version, view, editorType, edit, fill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.openEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of users with their access rights to the protected file with the ID specified in the request.
         * @summary Get users with the access to the protected file
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async protectUsers(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MentionWrapperArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.protectUsers(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.protectUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restores a file version specified in the request.
         * @summary Restore a file version
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {string} [url] File version URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreVersion(fileId: number, version?: number, url?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditHistoryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreVersion(fileId, version, url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.restoreVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves a file with the identifier specified in the request as a PDF document
         * @summary Save as pdf
         * @param {number} id File ID
         * @param {SaveAsPdfInteger} [saveAsPdfInteger] Parameters for saving file as pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAsPdf(id: number, saveAsPdfInteger?: SaveAsPdfInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAsPdf(id, saveAsPdfInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.saveAsPdf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves edits to a file with the ID specified in the request.
         * @summary Save file edits
         * @param {number} fileId File ID
         * @param {string} [fileExtension] File extension
         * @param {string} [downloadUri] URI to download a file
         * @param {File} [file] Request file stream
         * @param {boolean} [forcesave] Specifies whether to force save a file or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveEditingFromForm(fileId: number, fileExtension?: string, downloadUri?: string, file?: File, forcesave?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveEditingFromForm(fileId, fileExtension, downloadUri, file, forcesave, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.saveEditingFromForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets an external link to a file with the ID specified in the request.
         * @summary Set an external link
         * @param {number} id File ID
         * @param {FileLinkRequest} [fileLinkRequest] External link parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalLink(id, fileLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.setExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets order
         * @summary Sets order
         * @param {OrdersRequestDtoInteger} [ordersRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFilesOrder(ordersRequestDtoInteger?: OrdersRequestDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFilesOrder(ordersRequestDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.setFilesOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets order of a file with ID specified in the request
         * @summary Sets order of a file with ID specified in the request
         * @param {number} fileId The unique identifier of the file
         * @param {OrderRequestDto} [orderRequestDto] Order information for the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrderFile(fileId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrderFile(fileId, orderRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.setOrderFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Informs about opening a file with the ID specified in the request for editing, locking it from being deleted or moved (this method is called by the mobile editors).
         * @summary Start file editing
         * @param {number} fileId File ID
         * @param {StartEdit} [startEdit] Parameters for starting file editing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startEdit(fileId: number, startEdit?: StartEdit, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startEdit(fileId, startEdit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.startEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts filling a file with the ID specified in the request.
         * @summary Starts filling
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startFilling(fileId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startFilling(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.startFilling']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Tracks file changes when editing.
         * @summary Track file editing
         * @param {number} fileId File ID
         * @param {string} [tabId] Tab ID
         * @param {string} [docKeyForTrack] Document key for tracking
         * @param {boolean} [isFinish] Specifies whether to finish file tracking or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackEditFile(fileId: number, tabId?: string, docKeyForTrack?: string, isFinish?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyValuePairBooleanStringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackEditFile(fileId, tabId, docKeyForTrack, isFinish, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.trackEditFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the information of the selected file with the parameters specified in the request.
         * @summary Update a file
         * @param {number} fileId File ID
         * @param {UpdateFile} [updateFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(fileId: number, updateFile?: UpdateFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(fileId, updateFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFilesApi.updateFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesFilesApi - factory interface
 * @export
 */
export const FilesFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesFilesApiFp(configuration)
    return {
        /**
         * Adds files with the IDs specified in the request to the template list.
         * @summary Add template files
         * @param {TemplatesRequestDto} [templatesRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplates(templatesRequestDto?: TemplatesRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.addTemplates(templatesRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the version history of a file with the ID specified in the request.
         * @summary Change version history
         * @param {number} fileId File Id
         * @param {ChangeHistory} [changeHistory] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeHistory(fileId: number, changeHistory?: ChangeHistory, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerArrayWrapper> {
            return localVarFp.changeHistory(fileId, changeHistory, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the current file is a form draft which can be filled out.
         * @summary Check the form draft
         * @param {number} fileId File ID
         * @param {CheckFillFormDraft} [checkFillFormDraft] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFillFormDraft(fileId: number, checkFillFormDraft?: CheckFillFormDraft, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.checkFillFormDraft(fileId, checkFillFormDraft, options).then((request) => request(axios, basePath));
        },
        /**
         * Copies (and converts if possible) an existing file to the specified folder.
         * @summary Copy a file
         * @param {number} fileId File id
         * @param {CopyAsJsonElement} [copyAsJsonElement] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFileAs(fileId: number, copyAsJsonElement?: CopyAsJsonElement, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryWrapper> {
            return localVarFp.copyFileAs(fileId, copyAsJsonElement, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a session to edit the existing file with multiple chunks (needed for WebDAV).
         * @summary Create the editing session
         * @param {number} fileId File ID
         * @param {number} [fileSize] File size in bytes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEditSession(fileId: number, fileSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.createEditSession(fileId, fileSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new file in the specified folder with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file
         * @param {number} folderId Folder ID
         * @param {CreateFileJsonElement} [createFileJsonElement] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(folderId: number, createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createFile(folderId, createFileJsonElement, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new file in the \"My documents\" section with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
         * @summary Create a file in the \"My documents\" section
         * @param {CreateFileJsonElement} [createFileJsonElement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileMyDocuments(createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createFileMyDocuments(createFileJsonElement, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an HTML (.html) file in the selected folder with the title and contents specified in the request.
         * @summary Create an HTML file
         * @param {number} folderId Folder ID
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHtmlFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createHtmlFile(folderId, createTextOrHtmlFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an HTML (.html) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create an HTML file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHtmlFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createHtmlFileInMy(createTextOrHtmlFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a primary external link by the identifier specified in the request.
         * @summary Create primary external link
         * @param {number} id File ID
         * @param {FileLinkRequest} [fileLinkRequest] External link parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrimaryExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.createPrimaryExternalLink(id, fileLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a text (.txt) file in the selected folder with the title and contents specified in the request.
         * @summary Create a txt file
         * @param {number} folderId Folder ID
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createTextFile(folderId, createTextOrHtmlFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a text (.txt) file in the \"My documents\" section with the title and contents specified in the request.
         * @summary Create a text file in the \"My documents\" section
         * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTextFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.createTextFileInMy(createTextOrHtmlFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates thumbnails for the files with the IDs specified in the request.
         * @summary Create thumbnails
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThumbnails(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ObjectArrayWrapper> {
            return localVarFp.createThumbnails(baseBatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a file with the ID specified in the request.
         * @summary Delete a file
         * @param {number} fileId File ID
         * @param {Delete} [_delete] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId: number, _delete?: Delete, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.deleteFile(fileId, _delete, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes files with the IDs specified in the request from the \"Recent\" section.
         * @summary Delete recent files
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecent(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<NoContentResultWrapper> {
            return localVarFp.deleteRecent(baseBatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes files with the IDs specified in the request from the template list.
         * @summary Delete template files
         * @param {Array<number>} [requestBody] File IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplates(requestBody?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.deleteTemplates(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a URL to the changes of a file version specified in the request.
         * @summary Get changes URL
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditDiffUrl(fileId: number, version?: number, options?: RawAxiosRequestConfig): AxiosPromise<EditHistoryDataWrapper> {
            return localVarFp.getEditDiffUrl(fileId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the version history of a file with the ID specified in the request.
         * @summary Get version history
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditHistory(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<EditHistoryArrayWrapper> {
            return localVarFp.getEditHistory(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of actions performed on the file with the specified identifier
         * @summary Get file history
         * @param {number} fileId File ID
         * @param {ApiDateTime} [fromDate] Start date
         * @param {ApiDateTime} [toDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileHistory(fileId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig): AxiosPromise<HistoryArrayWrapper> {
            return localVarFp.getFileHistory(fileId, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about a file with the ID specified in the request.
         * @summary Get file information
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileInfo(fileId: number, version?: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.getFileInfo(fileId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilePrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.getFilePrimaryExternalLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about all the available file versions with the ID specified in the request.
         * @summary Get file versions
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileVersionInfo(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerArrayWrapper> {
            return localVarFp.getFileVersionInfo(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets fill result
         * @summary Gets fill result
         * @param {string} [fillingSessionId] Filling session id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFillResult(fillingSessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FillingFormResultIntegerWrapper> {
            return localVarFp.getFillResult(fillingSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the external links of a file with the ID specified in the request.
         * @summary Get file external links
         * @param {number} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinks(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FileShareArrayWrapper> {
            return localVarFp.getLinks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a link to download a file with the ID specified in the request asynchronously.
         * @summary Get file download link asynchronously
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedFileUri(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileLinkWrapper> {
            return localVarFp.getPresignedFileUri(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a link to download a file with the ID specified in the request.
         * @summary Get file download link
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUri(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.getPresignedUri(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the reference data to uniquely identify a file in its system and check the availability of insering data into the destination spreadsheet by the external link.
         * @summary Get reference data
         * @param {GetReferenceDataDtoInteger} [getReferenceDataDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceData(getReferenceDataDtoInteger?: GetReferenceDataDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<FileReferenceWrapper> {
            return localVarFp.getReferenceData(getReferenceDataDtoInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the PDF file is form or not.
         * @summary Check the PDF file
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isFormPDF(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.isFormPDF(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Locks a file with the ID specified in the request.
         * @summary Lock a file
         * @param {number} fileId File ID
         * @param {LockFileParameters} [lockFileParameters] Parameters for locking a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockFile(fileId: number, lockFileParameters?: LockFileParameters, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.lockFile(fileId, lockFileParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the initialization configuration of a file to open it in the editor.
         * @summary Open a file
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {boolean} [view] Specifies if a document will be opened for viewing only or not
         * @param {EditorType} [editorType] Editor type
         * @param {boolean} [edit] Edit
         * @param {boolean} [fill] Fill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openEdit(fileId: number, version?: number, view?: boolean, editorType?: EditorType, edit?: boolean, fill?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ConfigurationIntegerWrapper> {
            return localVarFp.openEdit(fileId, version, view, editorType, edit, fill, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users with their access rights to the protected file with the ID specified in the request.
         * @summary Get users with the access to the protected file
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protectUsers(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<MentionWrapperArrayWrapper> {
            return localVarFp.protectUsers(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores a file version specified in the request.
         * @summary Restore a file version
         * @param {number} fileId File ID
         * @param {number} [version] File version
         * @param {string} [url] File version URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreVersion(fileId: number, version?: number, url?: string, options?: RawAxiosRequestConfig): AxiosPromise<EditHistoryArrayWrapper> {
            return localVarFp.restoreVersion(fileId, version, url, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves a file with the identifier specified in the request as a PDF document
         * @summary Save as pdf
         * @param {number} id File ID
         * @param {SaveAsPdfInteger} [saveAsPdfInteger] Parameters for saving file as pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAsPdf(id: number, saveAsPdfInteger?: SaveAsPdfInteger, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.saveAsPdf(id, saveAsPdfInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves edits to a file with the ID specified in the request.
         * @summary Save file edits
         * @param {number} fileId File ID
         * @param {string} [fileExtension] File extension
         * @param {string} [downloadUri] URI to download a file
         * @param {File} [file] Request file stream
         * @param {boolean} [forcesave] Specifies whether to force save a file or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEditingFromForm(fileId: number, fileExtension?: string, downloadUri?: string, file?: File, forcesave?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.saveEditingFromForm(fileId, fileExtension, downloadUri, file, forcesave, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets an external link to a file with the ID specified in the request.
         * @summary Set an external link
         * @param {number} id File ID
         * @param {FileLinkRequest} [fileLinkRequest] External link parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.setExternalLink(id, fileLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets order
         * @summary Sets order
         * @param {OrdersRequestDtoInteger} [ordersRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFilesOrder(ordersRequestDtoInteger?: OrdersRequestDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setFilesOrder(ordersRequestDtoInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets order of a file with ID specified in the request
         * @summary Sets order of a file with ID specified in the request
         * @param {number} fileId The unique identifier of the file
         * @param {OrderRequestDto} [orderRequestDto] Order information for the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrderFile(fileId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setOrderFile(fileId, orderRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Informs about opening a file with the ID specified in the request for editing, locking it from being deleted or moved (this method is called by the mobile editors).
         * @summary Start file editing
         * @param {number} fileId File ID
         * @param {StartEdit} [startEdit] Parameters for starting file editing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEdit(fileId: number, startEdit?: StartEdit, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.startEdit(fileId, startEdit, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts filling a file with the ID specified in the request.
         * @summary Starts filling
         * @param {number} fileId File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFilling(fileId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.startFilling(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Tracks file changes when editing.
         * @summary Track file editing
         * @param {number} fileId File ID
         * @param {string} [tabId] Tab ID
         * @param {string} [docKeyForTrack] Document key for tracking
         * @param {boolean} [isFinish] Specifies whether to finish file tracking or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEditFile(fileId: number, tabId?: string, docKeyForTrack?: string, isFinish?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<KeyValuePairBooleanStringWrapper> {
            return localVarFp.trackEditFile(fileId, tabId, docKeyForTrack, isFinish, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the information of the selected file with the parameters specified in the request.
         * @summary Update a file
         * @param {number} fileId File ID
         * @param {UpdateFile} [updateFile] File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(fileId: number, updateFile?: UpdateFile, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.updateFile(fileId, updateFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesFilesApi - object-oriented interface
 * @export
 * @class FilesFilesApi
 * @extends {BaseAPI}
 */
export class FilesFilesApi extends BaseAPI {
    /**
     * Adds files with the IDs specified in the request to the template list.
     * @summary Add template files
     * @param {TemplatesRequestDto} [templatesRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public addTemplates(templatesRequestDto?: TemplatesRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).addTemplates(templatesRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the version history of a file with the ID specified in the request.
     * @summary Change version history
     * @param {number} fileId File Id
     * @param {ChangeHistory} [changeHistory] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public changeHistory(fileId: number, changeHistory?: ChangeHistory, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).changeHistory(fileId, changeHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the current file is a form draft which can be filled out.
     * @summary Check the form draft
     * @param {number} fileId File ID
     * @param {CheckFillFormDraft} [checkFillFormDraft] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public checkFillFormDraft(fileId: number, checkFillFormDraft?: CheckFillFormDraft, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).checkFillFormDraft(fileId, checkFillFormDraft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copies (and converts if possible) an existing file to the specified folder.
     * @summary Copy a file
     * @param {number} fileId File id
     * @param {CopyAsJsonElement} [copyAsJsonElement] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public copyFileAs(fileId: number, copyAsJsonElement?: CopyAsJsonElement, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).copyFileAs(fileId, copyAsJsonElement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a session to edit the existing file with multiple chunks (needed for WebDAV).
     * @summary Create the editing session
     * @param {number} fileId File ID
     * @param {number} [fileSize] File size in bytes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createEditSession(fileId: number, fileSize?: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createEditSession(fileId, fileSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new file in the specified folder with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
     * @summary Create a file
     * @param {number} folderId Folder ID
     * @param {CreateFileJsonElement} [createFileJsonElement] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createFile(folderId: number, createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createFile(folderId, createFileJsonElement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new file in the \"My documents\" section with the title specified in the request.   **Note**: If a file extension is different from DOCX/XLSX/PPTX and refers to one of the known text, spreadsheet, or presentation formats, it will be changed to DOCX/XLSX/PPTX accordingly. If the file extension is not specified or is unknown, the DOCX extension will be added to the file title.
     * @summary Create a file in the \"My documents\" section
     * @param {CreateFileJsonElement} [createFileJsonElement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createFileMyDocuments(createFileJsonElement?: CreateFileJsonElement, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createFileMyDocuments(createFileJsonElement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an HTML (.html) file in the selected folder with the title and contents specified in the request.
     * @summary Create an HTML file
     * @param {number} folderId Folder ID
     * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createHtmlFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createHtmlFile(folderId, createTextOrHtmlFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an HTML (.html) file in the \"My documents\" section with the title and contents specified in the request.
     * @summary Create an HTML file in the \"My documents\" section
     * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createHtmlFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createHtmlFileInMy(createTextOrHtmlFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a primary external link by the identifier specified in the request.
     * @summary Create primary external link
     * @param {number} id File ID
     * @param {FileLinkRequest} [fileLinkRequest] External link parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createPrimaryExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createPrimaryExternalLink(id, fileLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a text (.txt) file in the selected folder with the title and contents specified in the request.
     * @summary Create a txt file
     * @param {number} folderId Folder ID
     * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createTextFile(folderId: number, createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createTextFile(folderId, createTextOrHtmlFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a text (.txt) file in the \"My documents\" section with the title and contents specified in the request.
     * @summary Create a text file in the \"My documents\" section
     * @param {CreateTextOrHtmlFile} [createTextOrHtmlFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createTextFileInMy(createTextOrHtmlFile?: CreateTextOrHtmlFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createTextFileInMy(createTextOrHtmlFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates thumbnails for the files with the IDs specified in the request.
     * @summary Create thumbnails
     * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public createThumbnails(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).createThumbnails(baseBatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a file with the ID specified in the request.
     * @summary Delete a file
     * @param {number} fileId File ID
     * @param {Delete} [_delete] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public deleteFile(fileId: number, _delete?: Delete, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).deleteFile(fileId, _delete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes files with the IDs specified in the request from the \"Recent\" section.
     * @summary Delete recent files
     * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public deleteRecent(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).deleteRecent(baseBatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes files with the IDs specified in the request from the template list.
     * @summary Delete template files
     * @param {Array<number>} [requestBody] File IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public deleteTemplates(requestBody?: Array<number>, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).deleteTemplates(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a URL to the changes of a file version specified in the request.
     * @summary Get changes URL
     * @param {number} fileId File ID
     * @param {number} [version] File version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getEditDiffUrl(fileId: number, version?: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getEditDiffUrl(fileId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the version history of a file with the ID specified in the request.
     * @summary Get version history
     * @param {number} fileId File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getEditHistory(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getEditHistory(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of actions performed on the file with the specified identifier
     * @summary Get file history
     * @param {number} fileId File ID
     * @param {ApiDateTime} [fromDate] Start date
     * @param {ApiDateTime} [toDate] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFileHistory(fileId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFileHistory(fileId, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about a file with the ID specified in the request.
     * @summary Get file information
     * @param {number} fileId File ID
     * @param {number} [version] File version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFileInfo(fileId: number, version?: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFileInfo(fileId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary external link by the identifier specified in the request.
     * @summary Get primary external link
     * @param {number} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFilePrimaryExternalLink(id: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFilePrimaryExternalLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about all the available file versions with the ID specified in the request.
     * @summary Get file versions
     * @param {number} fileId File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFileVersionInfo(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFileVersionInfo(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets fill result
     * @summary Gets fill result
     * @param {string} [fillingSessionId] Filling session id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getFillResult(fillingSessionId?: string, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getFillResult(fillingSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the external links of a file with the ID specified in the request.
     * @summary Get file external links
     * @param {number} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getLinks(id: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getLinks(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a link to download a file with the ID specified in the request asynchronously.
     * @summary Get file download link asynchronously
     * @param {number} fileId File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getPresignedFileUri(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getPresignedFileUri(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a link to download a file with the ID specified in the request.
     * @summary Get file download link
     * @param {number} fileId File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getPresignedUri(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getPresignedUri(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the reference data to uniquely identify a file in its system and check the availability of insering data into the destination spreadsheet by the external link.
     * @summary Get reference data
     * @param {GetReferenceDataDtoInteger} [getReferenceDataDtoInteger] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public getReferenceData(getReferenceDataDtoInteger?: GetReferenceDataDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).getReferenceData(getReferenceDataDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the PDF file is form or not.
     * @summary Check the PDF file
     * @param {number} fileId File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public isFormPDF(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).isFormPDF(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Locks a file with the ID specified in the request.
     * @summary Lock a file
     * @param {number} fileId File ID
     * @param {LockFileParameters} [lockFileParameters] Parameters for locking a file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public lockFile(fileId: number, lockFileParameters?: LockFileParameters, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).lockFile(fileId, lockFileParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the initialization configuration of a file to open it in the editor.
     * @summary Open a file
     * @param {number} fileId File ID
     * @param {number} [version] File version
     * @param {boolean} [view] Specifies if a document will be opened for viewing only or not
     * @param {EditorType} [editorType] Editor type
     * @param {boolean} [edit] Edit
     * @param {boolean} [fill] Fill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public openEdit(fileId: number, version?: number, view?: boolean, editorType?: EditorType, edit?: boolean, fill?: boolean, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).openEdit(fileId, version, view, editorType, edit, fill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users with their access rights to the protected file with the ID specified in the request.
     * @summary Get users with the access to the protected file
     * @param {number} fileId File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public protectUsers(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).protectUsers(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores a file version specified in the request.
     * @summary Restore a file version
     * @param {number} fileId File ID
     * @param {number} [version] File version
     * @param {string} [url] File version URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public restoreVersion(fileId: number, version?: number, url?: string, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).restoreVersion(fileId, version, url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves a file with the identifier specified in the request as a PDF document
     * @summary Save as pdf
     * @param {number} id File ID
     * @param {SaveAsPdfInteger} [saveAsPdfInteger] Parameters for saving file as pdf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public saveAsPdf(id: number, saveAsPdfInteger?: SaveAsPdfInteger, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).saveAsPdf(id, saveAsPdfInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves edits to a file with the ID specified in the request.
     * @summary Save file edits
     * @param {number} fileId File ID
     * @param {string} [fileExtension] File extension
     * @param {string} [downloadUri] URI to download a file
     * @param {File} [file] Request file stream
     * @param {boolean} [forcesave] Specifies whether to force save a file or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public saveEditingFromForm(fileId: number, fileExtension?: string, downloadUri?: string, file?: File, forcesave?: boolean, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).saveEditingFromForm(fileId, fileExtension, downloadUri, file, forcesave, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets an external link to a file with the ID specified in the request.
     * @summary Set an external link
     * @param {number} id File ID
     * @param {FileLinkRequest} [fileLinkRequest] External link parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public setExternalLink(id: number, fileLinkRequest?: FileLinkRequest, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).setExternalLink(id, fileLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets order
     * @summary Sets order
     * @param {OrdersRequestDtoInteger} [ordersRequestDtoInteger] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public setFilesOrder(ordersRequestDtoInteger?: OrdersRequestDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).setFilesOrder(ordersRequestDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets order of a file with ID specified in the request
     * @summary Sets order of a file with ID specified in the request
     * @param {number} fileId The unique identifier of the file
     * @param {OrderRequestDto} [orderRequestDto] Order information for the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public setOrderFile(fileId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).setOrderFile(fileId, orderRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Informs about opening a file with the ID specified in the request for editing, locking it from being deleted or moved (this method is called by the mobile editors).
     * @summary Start file editing
     * @param {number} fileId File ID
     * @param {StartEdit} [startEdit] Parameters for starting file editing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public startEdit(fileId: number, startEdit?: StartEdit, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).startEdit(fileId, startEdit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts filling a file with the ID specified in the request.
     * @summary Starts filling
     * @param {number} fileId File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public startFilling(fileId: number, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).startFilling(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tracks file changes when editing.
     * @summary Track file editing
     * @param {number} fileId File ID
     * @param {string} [tabId] Tab ID
     * @param {string} [docKeyForTrack] Document key for tracking
     * @param {boolean} [isFinish] Specifies whether to finish file tracking or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public trackEditFile(fileId: number, tabId?: string, docKeyForTrack?: string, isFinish?: boolean, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).trackEditFile(fileId, tabId, docKeyForTrack, isFinish, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the information of the selected file with the parameters specified in the request.
     * @summary Update a file
     * @param {number} fileId File ID
     * @param {UpdateFile} [updateFile] File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFilesApi
     */
    public updateFile(fileId: number, updateFile?: UpdateFile, options?: RawAxiosRequestConfig) {
        return FilesFilesApiFp(this.configuration).updateFile(fileId, updateFile, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesFoldersApi - axios parameter creator
 * @export
 */
export const FilesFoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks upload
         * @summary Checks upload
         * @param {number} folderId Folder ID
         * @param {CheckUploadRequest} [checkUploadRequest] Parameters for checking files uploading
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUpload: async (folderId: number, checkUploadRequest?: CheckUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('checkUpload', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/upload/check`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new folder with the title specified in the request. The parent folder ID can be also specified.
         * @summary Create a folder
         * @param {number} folderId Folder ID
         * @param {CreateFolder} [createFolder] Folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (folderId: number, createFolder?: CreateFolder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createFolder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFolder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a folder with the ID specified in the request.
         * @summary Delete a folder
         * @param {number} folderId Folder ID
         * @param {DeleteFolder} [deleteFolder] Parameters for deleting a folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId: number, deleteFolder?: DeleteFolder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteFolder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the used space of files in the root folders.
         * @summary Get used space of files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesUsedSpace: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/filesusedspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get form filter of a folder with id specified in request
         * @summary Get folder form filter
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/formfilter`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed list of files and folders located in the folder with the ID specified in the request.
         * @summary Get a folder by ID
         * @param {number} folderId Folder ID
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {number} [roomId] Room ID
         * @param {boolean} [excludeSubject] Specifies whether to exclude a subject or not
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {string} [extension] Specifies whether to search for a specific file extension
         * @param {SearchArea} [searchArea] Search area
         * @param {string} [formsItemKey] 
         * @param {string} [formsItemType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderByFolderId: async (folderId: number, userIdOrGroupId?: string, filterType?: FilterType, roomId?: number, excludeSubject?: boolean, applyFilterOption?: ApplyFilterOption, extension?: string, searchArea?: SearchArea, formsItemKey?: string, formsItemType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderByFolderId', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (roomId !== undefined) {
                localVarQueryParameter['roomId'] = roomId;
            }

            if (excludeSubject !== undefined) {
                localVarQueryParameter['excludeSubject'] = excludeSubject;
            }

            if (applyFilterOption !== undefined) {
                localVarQueryParameter['applyFilterOption'] = applyFilterOption;
            }

            if (extension !== undefined) {
                localVarQueryParameter['extension'] = extension;
            }

            if (searchArea !== undefined) {
                localVarQueryParameter['searchArea'] = searchArea;
            }

            if (formsItemKey !== undefined) {
                localVarQueryParameter['formsItemKey'] = formsItemKey;
            }

            if (formsItemType !== undefined) {
                localVarQueryParameter['formsItemType'] = formsItemType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the activity history of a folder with a specified identifier
         * @summary Get folder history
         * @param {number} folderId File ID
         * @param {ApiDateTime} [fromDate] Start date
         * @param {ApiDateTime} [toDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory: async (folderId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderHistory', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}/log`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (fromDate !== undefined) {
                for (const [key, value] of Object.entries(fromDate)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (toDate !== undefined) {
                for (const [key, value] of Object.entries(toDate)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about a folder with the ID specified in the request.
         * @summary Get folder information
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderInfo: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderInfo', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a path to the folder with the ID specified in the request.
         * @summary Get the folder path
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPath: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderPath', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}/path`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id Folder Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPrimaryExternalLink: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFolderPrimaryExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/folder/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the subfolders from a folder with the ID specified in the request.
         * @summary Get subfolders
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolders', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/subfolders`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed list of files and folders located in the \"My documents\" section.
         * @summary Get the \"My documents\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyFolder: async (userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (applyFilterOption !== undefined) {
                localVarQueryParameter['applyFilterOption'] = applyFilterOption;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the new items from a folder with the ID specified in the request.
         * @summary Get new folder items
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewItems: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getNewItems', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/news`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed list of files and folders located in the \"Private Room\" section.
         * @summary Get the \"Private Room\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacyFolder: async (userIdOrGroupId?: string, filterType?: FilterType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@privacy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the sections matching the parameters specified in the request.
         * @summary Get filtered sections
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {boolean} [withoutTrash] Specifies whether to return the \&quot;Trash\&quot; section or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolders: async (userIdOrGroupId?: string, filterType?: FilterType, withoutTrash?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (withoutTrash !== undefined) {
                localVarQueryParameter['withoutTrash'] = withoutTrash;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed list of files and folders located in the \"Trash\" section.
         * @summary Get the \"Trash\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrashFolder: async (userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@trash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (userIdOrGroupId !== undefined) {
                localVarQueryParameter['userIdOrGroupId'] = userIdOrGroupId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (applyFilterOption !== undefined) {
                localVarQueryParameter['applyFilterOption'] = applyFilterOption;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts a file specified in the request to the selected folder by single file uploading.
         * @summary Insert a file
         * @param {number} folderId Folder ID
         * @param {File} [insertFileFile] File
         * @param {string} [insertFileTitle] File name
         * @param {boolean} [insertFileCreateNewIfExist] Specifies whether to create a new file if it already exists or not
         * @param {boolean} [insertFileKeepConvertStatus] Specifies whether to keep the file converting status or not
         * @param {boolean} [insertFileStreamCanRead] 
         * @param {boolean} [insertFileStreamCanWrite] 
         * @param {boolean} [insertFileStreamCanSeek] 
         * @param {boolean} [insertFileStreamCanTimeout] 
         * @param {number} [insertFileStreamLength] 
         * @param {number} [insertFileStreamPosition] 
         * @param {number} [insertFileStreamReadTimeout] 
         * @param {number} [insertFileStreamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertFile: async (folderId: number, insertFileFile?: File, insertFileTitle?: string, insertFileCreateNewIfExist?: boolean, insertFileKeepConvertStatus?: boolean, insertFileStreamCanRead?: boolean, insertFileStreamCanWrite?: boolean, insertFileStreamCanSeek?: boolean, insertFileStreamCanTimeout?: boolean, insertFileStreamLength?: number, insertFileStreamPosition?: number, insertFileStreamReadTimeout?: number, insertFileStreamWriteTimeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('insertFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/insert`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication asc_auth_key required


            if (insertFileFile !== undefined) { 
                localVarFormParams.append('InsertFile.File', insertFileFile as any);
            }
    
            if (insertFileTitle !== undefined) { 
                localVarFormParams.append('InsertFile.Title', insertFileTitle as any);
            }
    
            if (insertFileCreateNewIfExist !== undefined) { 
                localVarFormParams.append('InsertFile.CreateNewIfExist', String(insertFileCreateNewIfExist) as any);
            }
    
            if (insertFileKeepConvertStatus !== undefined) { 
                localVarFormParams.append('InsertFile.KeepConvertStatus', String(insertFileKeepConvertStatus) as any);
            }
    
            if (insertFileStreamCanRead !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.CanRead', String(insertFileStreamCanRead) as any);
            }
    
            if (insertFileStreamCanWrite !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.CanWrite', String(insertFileStreamCanWrite) as any);
            }
    
            if (insertFileStreamCanSeek !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.CanSeek', String(insertFileStreamCanSeek) as any);
            }
    
            if (insertFileStreamCanTimeout !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.CanTimeout', String(insertFileStreamCanTimeout) as any);
            }
    
            if (insertFileStreamLength !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.Length', insertFileStreamLength as any);
            }
    
            if (insertFileStreamPosition !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.Position', insertFileStreamPosition as any);
            }
    
            if (insertFileStreamReadTimeout !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.ReadTimeout', insertFileStreamReadTimeout as any);
            }
    
            if (insertFileStreamWriteTimeout !== undefined) { 
                localVarFormParams.append('InsertFile.Stream.WriteTimeout', insertFileStreamWriteTimeout as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts a file specified in the request to the \"My documents\" section by single file uploading.
         * @summary Insert a file to the \"My documents\" section
         * @param {File} [file] File
         * @param {string} [title] File name
         * @param {boolean} [createNewIfExist] Specifies whether to create a new file if it already exists or not
         * @param {boolean} [keepConvertStatus] Specifies whether to keep the file converting status or not
         * @param {boolean} [streamCanRead] 
         * @param {boolean} [streamCanWrite] 
         * @param {boolean} [streamCanSeek] 
         * @param {boolean} [streamCanTimeout] 
         * @param {number} [streamLength] 
         * @param {number} [streamPosition] 
         * @param {number} [streamReadTimeout] 
         * @param {number} [streamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertFileToMyFromBody: async (file?: File, title?: string, createNewIfExist?: boolean, keepConvertStatus?: boolean, streamCanRead?: boolean, streamCanWrite?: boolean, streamCanSeek?: boolean, streamCanTimeout?: boolean, streamLength?: number, streamPosition?: number, streamReadTimeout?: number, streamWriteTimeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/insert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication asc_auth_key required


            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
            if (title !== undefined) { 
                localVarFormParams.append('Title', title as any);
            }
    
            if (createNewIfExist !== undefined) { 
                localVarFormParams.append('CreateNewIfExist', String(createNewIfExist) as any);
            }
    
            if (keepConvertStatus !== undefined) { 
                localVarFormParams.append('KeepConvertStatus', String(keepConvertStatus) as any);
            }
    
            if (streamCanRead !== undefined) { 
                localVarFormParams.append('Stream.CanRead', String(streamCanRead) as any);
            }
    
            if (streamCanWrite !== undefined) { 
                localVarFormParams.append('Stream.CanWrite', String(streamCanWrite) as any);
            }
    
            if (streamCanSeek !== undefined) { 
                localVarFormParams.append('Stream.CanSeek', String(streamCanSeek) as any);
            }
    
            if (streamCanTimeout !== undefined) { 
                localVarFormParams.append('Stream.CanTimeout', String(streamCanTimeout) as any);
            }
    
            if (streamLength !== undefined) { 
                localVarFormParams.append('Stream.Length', streamLength as any);
            }
    
            if (streamPosition !== undefined) { 
                localVarFormParams.append('Stream.Position', streamPosition as any);
            }
    
            if (streamReadTimeout !== undefined) { 
                localVarFormParams.append('Stream.ReadTimeout', streamReadTimeout as any);
            }
    
            if (streamWriteTimeout !== undefined) { 
                localVarFormParams.append('Stream.WriteTimeout', streamWriteTimeout as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames the selected folder with a new title specified in the request.
         * @summary Rename a folder
         * @param {number} folderId Folder ID
         * @param {CreateFolder} [createFolder] Folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameFolder: async (folderId: number, createFolder?: CreateFolder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('renameFolder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFolder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets file order in the folder with ID specified in the request
         * @summary Sets file order in the folder with ID specified in the request
         * @param {number} folderId The unique identifier of the folder
         * @param {OrderRequestDto} [orderRequestDto] Order information for the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFileOrder: async (folderId: number, orderRequestDto?: OrderRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('setFileOrder', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/folder/{folderId}/order`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file
         * @param {number} folderId Folder ID
         * @param {UploadRequestDto} [uploadRequestDto] Upload data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (folderId: number, uploadRequestDto?: UploadRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('uploadFile', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/upload`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file to the \"My documents\" section
         * @param {UploadRequestDto} [inDto] Request parameters for uploading a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileToMy: async (inDto?: UploadRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@my/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (inDto !== undefined) {
                for (const [key, value] of Object.entries(inDto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesFoldersApi - functional programming interface
 * @export
 */
export const FilesFoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesFoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks upload
         * @summary Checks upload
         * @param {number} folderId Folder ID
         * @param {CheckUploadRequest} [checkUploadRequest] Parameters for checking files uploading
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUpload(folderId: number, checkUploadRequest?: CheckUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<STRINGArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUpload(folderId, checkUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.checkUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new folder with the title specified in the request. The parent folder ID can be also specified.
         * @summary Create a folder
         * @param {number} folderId Folder ID
         * @param {CreateFolder} [createFolder] Folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(folderId, createFolder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a folder with the ID specified in the request.
         * @summary Delete a folder
         * @param {number} folderId Folder ID
         * @param {DeleteFolder} [deleteFolder] Parameters for deleting a folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId: number, deleteFolder?: DeleteFolder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderId, deleteFolder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.deleteFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the used space of files in the root folders.
         * @summary Get used space of files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilesUsedSpace(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesStatisticsResultWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesUsedSpace(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFilesUsedSpace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get form filter of a folder with id specified in request
         * @summary Get folder form filter
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormsItemArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed list of files and folders located in the folder with the ID specified in the request.
         * @summary Get a folder by ID
         * @param {number} folderId Folder ID
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {number} [roomId] Room ID
         * @param {boolean} [excludeSubject] Specifies whether to exclude a subject or not
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {string} [extension] Specifies whether to search for a specific file extension
         * @param {SearchArea} [searchArea] Search area
         * @param {string} [formsItemKey] 
         * @param {string} [formsItemType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderByFolderId(folderId: number, userIdOrGroupId?: string, filterType?: FilterType, roomId?: number, excludeSubject?: boolean, applyFilterOption?: ApplyFilterOption, extension?: string, searchArea?: SearchArea, formsItemKey?: string, formsItemType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderByFolderId(folderId, userIdOrGroupId, filterType, roomId, excludeSubject, applyFilterOption, extension, searchArea, formsItemKey, formsItemType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderByFolderId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the activity history of a folder with a specified identifier
         * @summary Get folder history
         * @param {number} folderId File ID
         * @param {ApiDateTime} [fromDate] Start date
         * @param {ApiDateTime} [toDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderHistory(folderId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderHistory(folderId, fromDate, toDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about a folder with the ID specified in the request.
         * @summary Get folder information
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderInfo(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderInfo(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a path to the folder with the ID specified in the request.
         * @summary Get the folder path
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderPath(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderPath(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderPath']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id Folder Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderPrimaryExternalLink(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolderPrimaryExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the subfolders from a folder with the ID specified in the request.
         * @summary Get subfolders
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolders(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolders(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed list of files and folders located in the \"My documents\" section.
         * @summary Get the \"My documents\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyFolder(userIdOrGroupId, filterType, applyFilterOption, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getMyFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the new items from a folder with the ID specified in the request.
         * @summary Get new folder items
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewItems(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewItems(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getNewItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed list of files and folders located in the \"Private Room\" section.
         * @summary Get the \"Private Room\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrivacyFolder(userIdOrGroupId?: string, filterType?: FilterType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrivacyFolder(userIdOrGroupId, filterType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getPrivacyFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all the sections matching the parameters specified in the request.
         * @summary Get filtered sections
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {boolean} [withoutTrash] Specifies whether to return the \&quot;Trash\&quot; section or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootFolders(userIdOrGroupId?: string, filterType?: FilterType, withoutTrash?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRootFolders(userIdOrGroupId, filterType, withoutTrash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getRootFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed list of files and folders located in the \"Trash\" section.
         * @summary Get the \"Trash\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrashFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrashFolder(userIdOrGroupId, filterType, applyFilterOption, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.getTrashFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts a file specified in the request to the selected folder by single file uploading.
         * @summary Insert a file
         * @param {number} folderId Folder ID
         * @param {File} [insertFileFile] File
         * @param {string} [insertFileTitle] File name
         * @param {boolean} [insertFileCreateNewIfExist] Specifies whether to create a new file if it already exists or not
         * @param {boolean} [insertFileKeepConvertStatus] Specifies whether to keep the file converting status or not
         * @param {boolean} [insertFileStreamCanRead] 
         * @param {boolean} [insertFileStreamCanWrite] 
         * @param {boolean} [insertFileStreamCanSeek] 
         * @param {boolean} [insertFileStreamCanTimeout] 
         * @param {number} [insertFileStreamLength] 
         * @param {number} [insertFileStreamPosition] 
         * @param {number} [insertFileStreamReadTimeout] 
         * @param {number} [insertFileStreamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertFile(folderId: number, insertFileFile?: File, insertFileTitle?: string, insertFileCreateNewIfExist?: boolean, insertFileKeepConvertStatus?: boolean, insertFileStreamCanRead?: boolean, insertFileStreamCanWrite?: boolean, insertFileStreamCanSeek?: boolean, insertFileStreamCanTimeout?: boolean, insertFileStreamLength?: number, insertFileStreamPosition?: number, insertFileStreamReadTimeout?: number, insertFileStreamWriteTimeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertFile(folderId, insertFileFile, insertFileTitle, insertFileCreateNewIfExist, insertFileKeepConvertStatus, insertFileStreamCanRead, insertFileStreamCanWrite, insertFileStreamCanSeek, insertFileStreamCanTimeout, insertFileStreamLength, insertFileStreamPosition, insertFileStreamReadTimeout, insertFileStreamWriteTimeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.insertFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts a file specified in the request to the \"My documents\" section by single file uploading.
         * @summary Insert a file to the \"My documents\" section
         * @param {File} [file] File
         * @param {string} [title] File name
         * @param {boolean} [createNewIfExist] Specifies whether to create a new file if it already exists or not
         * @param {boolean} [keepConvertStatus] Specifies whether to keep the file converting status or not
         * @param {boolean} [streamCanRead] 
         * @param {boolean} [streamCanWrite] 
         * @param {boolean} [streamCanSeek] 
         * @param {boolean} [streamCanTimeout] 
         * @param {number} [streamLength] 
         * @param {number} [streamPosition] 
         * @param {number} [streamReadTimeout] 
         * @param {number} [streamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertFileToMyFromBody(file?: File, title?: string, createNewIfExist?: boolean, keepConvertStatus?: boolean, streamCanRead?: boolean, streamCanWrite?: boolean, streamCanSeek?: boolean, streamCanTimeout?: boolean, streamLength?: number, streamPosition?: number, streamReadTimeout?: number, streamWriteTimeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertFileToMyFromBody(file, title, createNewIfExist, keepConvertStatus, streamCanRead, streamCanWrite, streamCanSeek, streamCanTimeout, streamLength, streamPosition, streamReadTimeout, streamWriteTimeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.insertFileToMyFromBody']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Renames the selected folder with a new title specified in the request.
         * @summary Rename a folder
         * @param {number} folderId Folder ID
         * @param {CreateFolder} [createFolder] Folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameFolder(folderId, createFolder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.renameFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets file order in the folder with ID specified in the request
         * @summary Sets file order in the folder with ID specified in the request
         * @param {number} folderId The unique identifier of the folder
         * @param {OrderRequestDto} [orderRequestDto] Order information for the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFileOrder(folderId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFileOrder(folderId, orderRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.setFileOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file
         * @param {number} folderId Folder ID
         * @param {UploadRequestDto} [uploadRequestDto] Upload data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(folderId: number, uploadRequestDto?: UploadRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(folderId, uploadRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file to the \"My documents\" section
         * @param {UploadRequestDto} [inDto] Request parameters for uploading a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileToMy(inDto?: UploadRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileToMy(inDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesFoldersApi.uploadFileToMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesFoldersApi - factory interface
 * @export
 */
export const FilesFoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesFoldersApiFp(configuration)
    return {
        /**
         * Checks upload
         * @summary Checks upload
         * @param {number} folderId Folder ID
         * @param {CheckUploadRequest} [checkUploadRequest] Parameters for checking files uploading
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUpload(folderId: number, checkUploadRequest?: CheckUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<STRINGArrayWrapper> {
            return localVarFp.checkUpload(folderId, checkUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new folder with the title specified in the request. The parent folder ID can be also specified.
         * @summary Create a folder
         * @param {number} folderId Folder ID
         * @param {CreateFolder} [createFolder] Folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.createFolder(folderId, createFolder, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a folder with the ID specified in the request.
         * @summary Delete a folder
         * @param {number} folderId Folder ID
         * @param {DeleteFolder} [deleteFolder] Parameters for deleting a folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(folderId: number, deleteFolder?: DeleteFolder, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.deleteFolder(folderId, deleteFolder, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the used space of files in the root folders.
         * @summary Get used space of files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesUsedSpace(options?: RawAxiosRequestConfig): AxiosPromise<FilesStatisticsResultWrapper> {
            return localVarFp.getFilesUsedSpace(options).then((request) => request(axios, basePath));
        },
        /**
         * Get form filter of a folder with id specified in request
         * @summary Get folder form filter
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FormsItemArrayWrapper> {
            return localVarFp.getFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed list of files and folders located in the folder with the ID specified in the request.
         * @summary Get a folder by ID
         * @param {number} folderId Folder ID
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {number} [roomId] Room ID
         * @param {boolean} [excludeSubject] Specifies whether to exclude a subject or not
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {string} [extension] Specifies whether to search for a specific file extension
         * @param {SearchArea} [searchArea] Search area
         * @param {string} [formsItemKey] 
         * @param {string} [formsItemType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderByFolderId(folderId: number, userIdOrGroupId?: string, filterType?: FilterType, roomId?: number, excludeSubject?: boolean, applyFilterOption?: ApplyFilterOption, extension?: string, searchArea?: SearchArea, formsItemKey?: string, formsItemType?: string, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getFolderByFolderId(folderId, userIdOrGroupId, filterType, roomId, excludeSubject, applyFilterOption, extension, searchArea, formsItemKey, formsItemType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the activity history of a folder with a specified identifier
         * @summary Get folder history
         * @param {number} folderId File ID
         * @param {ApiDateTime} [fromDate] Start date
         * @param {ApiDateTime} [toDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory(folderId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig): AxiosPromise<HistoryArrayWrapper> {
            return localVarFp.getFolderHistory(folderId, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about a folder with the ID specified in the request.
         * @summary Get folder information
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderInfo(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.getFolderInfo(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a path to the folder with the ID specified in the request.
         * @summary Get the folder path
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPath(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryArrayWrapper> {
            return localVarFp.getFolderPath(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary external link by the identifier specified in the request.
         * @summary Get primary external link
         * @param {number} id Folder Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.getFolderPrimaryExternalLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the subfolders from a folder with the ID specified in the request.
         * @summary Get subfolders
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryArrayWrapper> {
            return localVarFp.getFolders(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed list of files and folders located in the \"My documents\" section.
         * @summary Get the \"My documents\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getMyFolder(userIdOrGroupId, filterType, applyFilterOption, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the new items from a folder with the ID specified in the request.
         * @summary Get new folder items
         * @param {number} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewItems(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryArrayWrapper> {
            return localVarFp.getNewItems(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed list of files and folders located in the \"Private Room\" section.
         * @summary Get the \"Private Room\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivacyFolder(userIdOrGroupId?: string, filterType?: FilterType, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getPrivacyFolder(userIdOrGroupId, filterType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the sections matching the parameters specified in the request.
         * @summary Get filtered sections
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {boolean} [withoutTrash] Specifies whether to return the \&quot;Trash\&quot; section or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolders(userIdOrGroupId?: string, filterType?: FilterType, withoutTrash?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerArrayWrapper> {
            return localVarFp.getRootFolders(userIdOrGroupId, filterType, withoutTrash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed list of files and folders located in the \"Trash\" section.
         * @summary Get the \"Trash\" section
         * @param {string} [userIdOrGroupId] User or group ID
         * @param {FilterType} [filterType] Filter type
         * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrashFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getTrashFolder(userIdOrGroupId, filterType, applyFilterOption, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts a file specified in the request to the selected folder by single file uploading.
         * @summary Insert a file
         * @param {number} folderId Folder ID
         * @param {File} [insertFileFile] File
         * @param {string} [insertFileTitle] File name
         * @param {boolean} [insertFileCreateNewIfExist] Specifies whether to create a new file if it already exists or not
         * @param {boolean} [insertFileKeepConvertStatus] Specifies whether to keep the file converting status or not
         * @param {boolean} [insertFileStreamCanRead] 
         * @param {boolean} [insertFileStreamCanWrite] 
         * @param {boolean} [insertFileStreamCanSeek] 
         * @param {boolean} [insertFileStreamCanTimeout] 
         * @param {number} [insertFileStreamLength] 
         * @param {number} [insertFileStreamPosition] 
         * @param {number} [insertFileStreamReadTimeout] 
         * @param {number} [insertFileStreamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertFile(folderId: number, insertFileFile?: File, insertFileTitle?: string, insertFileCreateNewIfExist?: boolean, insertFileKeepConvertStatus?: boolean, insertFileStreamCanRead?: boolean, insertFileStreamCanWrite?: boolean, insertFileStreamCanSeek?: boolean, insertFileStreamCanTimeout?: boolean, insertFileStreamLength?: number, insertFileStreamPosition?: number, insertFileStreamReadTimeout?: number, insertFileStreamWriteTimeout?: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.insertFile(folderId, insertFileFile, insertFileTitle, insertFileCreateNewIfExist, insertFileKeepConvertStatus, insertFileStreamCanRead, insertFileStreamCanWrite, insertFileStreamCanSeek, insertFileStreamCanTimeout, insertFileStreamLength, insertFileStreamPosition, insertFileStreamReadTimeout, insertFileStreamWriteTimeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts a file specified in the request to the \"My documents\" section by single file uploading.
         * @summary Insert a file to the \"My documents\" section
         * @param {File} [file] File
         * @param {string} [title] File name
         * @param {boolean} [createNewIfExist] Specifies whether to create a new file if it already exists or not
         * @param {boolean} [keepConvertStatus] Specifies whether to keep the file converting status or not
         * @param {boolean} [streamCanRead] 
         * @param {boolean} [streamCanWrite] 
         * @param {boolean} [streamCanSeek] 
         * @param {boolean} [streamCanTimeout] 
         * @param {number} [streamLength] 
         * @param {number} [streamPosition] 
         * @param {number} [streamReadTimeout] 
         * @param {number} [streamWriteTimeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertFileToMyFromBody(file?: File, title?: string, createNewIfExist?: boolean, keepConvertStatus?: boolean, streamCanRead?: boolean, streamCanWrite?: boolean, streamCanSeek?: boolean, streamCanTimeout?: boolean, streamLength?: number, streamPosition?: number, streamReadTimeout?: number, streamWriteTimeout?: number, options?: RawAxiosRequestConfig): AxiosPromise<FileIntegerWrapper> {
            return localVarFp.insertFileToMyFromBody(file, title, createNewIfExist, keepConvertStatus, streamCanRead, streamCanWrite, streamCanSeek, streamCanTimeout, streamLength, streamPosition, streamReadTimeout, streamWriteTimeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames the selected folder with a new title specified in the request.
         * @summary Rename a folder
         * @param {number} folderId Folder ID
         * @param {CreateFolder} [createFolder] Folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.renameFolder(folderId, createFolder, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets file order in the folder with ID specified in the request
         * @summary Sets file order in the folder with ID specified in the request
         * @param {number} folderId The unique identifier of the folder
         * @param {OrderRequestDto} [orderRequestDto] Order information for the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFileOrder(folderId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setFileOrder(folderId, orderRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file
         * @param {number} folderId Folder ID
         * @param {UploadRequestDto} [uploadRequestDto] Upload data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(folderId: number, uploadRequestDto?: UploadRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.uploadFile(folderId, uploadRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
         * @summary Upload a file to the \"My documents\" section
         * @param {UploadRequestDto} [inDto] Request parameters for uploading a file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileToMy(inDto?: UploadRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.uploadFileToMy(inDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesFoldersApi - object-oriented interface
 * @export
 * @class FilesFoldersApi
 * @extends {BaseAPI}
 */
export class FilesFoldersApi extends BaseAPI {
    /**
     * Checks upload
     * @summary Checks upload
     * @param {number} folderId Folder ID
     * @param {CheckUploadRequest} [checkUploadRequest] Parameters for checking files uploading
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public checkUpload(folderId: number, checkUploadRequest?: CheckUploadRequest, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).checkUpload(folderId, checkUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new folder with the title specified in the request. The parent folder ID can be also specified.
     * @summary Create a folder
     * @param {number} folderId Folder ID
     * @param {CreateFolder} [createFolder] Folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public createFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).createFolder(folderId, createFolder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a folder with the ID specified in the request.
     * @summary Delete a folder
     * @param {number} folderId Folder ID
     * @param {DeleteFolder} [deleteFolder] Parameters for deleting a folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public deleteFolder(folderId: number, deleteFolder?: DeleteFolder, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).deleteFolder(folderId, deleteFolder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the used space of files in the root folders.
     * @summary Get used space of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFilesUsedSpace(options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFilesUsedSpace(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get form filter of a folder with id specified in request
     * @summary Get folder form filter
     * @param {number} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolder(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolder(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed list of files and folders located in the folder with the ID specified in the request.
     * @summary Get a folder by ID
     * @param {number} folderId Folder ID
     * @param {string} [userIdOrGroupId] User or group ID
     * @param {FilterType} [filterType] Filter type
     * @param {number} [roomId] Room ID
     * @param {boolean} [excludeSubject] Specifies whether to exclude a subject or not
     * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
     * @param {string} [extension] Specifies whether to search for a specific file extension
     * @param {SearchArea} [searchArea] Search area
     * @param {string} [formsItemKey] 
     * @param {string} [formsItemType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderByFolderId(folderId: number, userIdOrGroupId?: string, filterType?: FilterType, roomId?: number, excludeSubject?: boolean, applyFilterOption?: ApplyFilterOption, extension?: string, searchArea?: SearchArea, formsItemKey?: string, formsItemType?: string, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderByFolderId(folderId, userIdOrGroupId, filterType, roomId, excludeSubject, applyFilterOption, extension, searchArea, formsItemKey, formsItemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the activity history of a folder with a specified identifier
     * @summary Get folder history
     * @param {number} folderId File ID
     * @param {ApiDateTime} [fromDate] Start date
     * @param {ApiDateTime} [toDate] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderHistory(folderId: number, fromDate?: ApiDateTime, toDate?: ApiDateTime, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderHistory(folderId, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about a folder with the ID specified in the request.
     * @summary Get folder information
     * @param {number} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderInfo(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderInfo(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a path to the folder with the ID specified in the request.
     * @summary Get the folder path
     * @param {number} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderPath(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderPath(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary external link by the identifier specified in the request.
     * @summary Get primary external link
     * @param {number} id Folder Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolderPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolderPrimaryExternalLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the subfolders from a folder with the ID specified in the request.
     * @summary Get subfolders
     * @param {number} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getFolders(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getFolders(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed list of files and folders located in the \"My documents\" section.
     * @summary Get the \"My documents\" section
     * @param {string} [userIdOrGroupId] User or group ID
     * @param {FilterType} [filterType] Filter type
     * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getMyFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getMyFolder(userIdOrGroupId, filterType, applyFilterOption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the new items from a folder with the ID specified in the request.
     * @summary Get new folder items
     * @param {number} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getNewItems(folderId: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getNewItems(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed list of files and folders located in the \"Private Room\" section.
     * @summary Get the \"Private Room\" section
     * @param {string} [userIdOrGroupId] User or group ID
     * @param {FilterType} [filterType] Filter type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getPrivacyFolder(userIdOrGroupId?: string, filterType?: FilterType, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getPrivacyFolder(userIdOrGroupId, filterType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the sections matching the parameters specified in the request.
     * @summary Get filtered sections
     * @param {string} [userIdOrGroupId] User or group ID
     * @param {FilterType} [filterType] Filter type
     * @param {boolean} [withoutTrash] Specifies whether to return the \&quot;Trash\&quot; section or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getRootFolders(userIdOrGroupId?: string, filterType?: FilterType, withoutTrash?: boolean, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getRootFolders(userIdOrGroupId, filterType, withoutTrash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed list of files and folders located in the \"Trash\" section.
     * @summary Get the \"Trash\" section
     * @param {string} [userIdOrGroupId] User or group ID
     * @param {FilterType} [filterType] Filter type
     * @param {ApplyFilterOption} [applyFilterOption] Specifies whether to return only files, only folders or all elements from the specified folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public getTrashFolder(userIdOrGroupId?: string, filterType?: FilterType, applyFilterOption?: ApplyFilterOption, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).getTrashFolder(userIdOrGroupId, filterType, applyFilterOption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts a file specified in the request to the selected folder by single file uploading.
     * @summary Insert a file
     * @param {number} folderId Folder ID
     * @param {File} [insertFileFile] File
     * @param {string} [insertFileTitle] File name
     * @param {boolean} [insertFileCreateNewIfExist] Specifies whether to create a new file if it already exists or not
     * @param {boolean} [insertFileKeepConvertStatus] Specifies whether to keep the file converting status or not
     * @param {boolean} [insertFileStreamCanRead] 
     * @param {boolean} [insertFileStreamCanWrite] 
     * @param {boolean} [insertFileStreamCanSeek] 
     * @param {boolean} [insertFileStreamCanTimeout] 
     * @param {number} [insertFileStreamLength] 
     * @param {number} [insertFileStreamPosition] 
     * @param {number} [insertFileStreamReadTimeout] 
     * @param {number} [insertFileStreamWriteTimeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public insertFile(folderId: number, insertFileFile?: File, insertFileTitle?: string, insertFileCreateNewIfExist?: boolean, insertFileKeepConvertStatus?: boolean, insertFileStreamCanRead?: boolean, insertFileStreamCanWrite?: boolean, insertFileStreamCanSeek?: boolean, insertFileStreamCanTimeout?: boolean, insertFileStreamLength?: number, insertFileStreamPosition?: number, insertFileStreamReadTimeout?: number, insertFileStreamWriteTimeout?: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).insertFile(folderId, insertFileFile, insertFileTitle, insertFileCreateNewIfExist, insertFileKeepConvertStatus, insertFileStreamCanRead, insertFileStreamCanWrite, insertFileStreamCanSeek, insertFileStreamCanTimeout, insertFileStreamLength, insertFileStreamPosition, insertFileStreamReadTimeout, insertFileStreamWriteTimeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts a file specified in the request to the \"My documents\" section by single file uploading.
     * @summary Insert a file to the \"My documents\" section
     * @param {File} [file] File
     * @param {string} [title] File name
     * @param {boolean} [createNewIfExist] Specifies whether to create a new file if it already exists or not
     * @param {boolean} [keepConvertStatus] Specifies whether to keep the file converting status or not
     * @param {boolean} [streamCanRead] 
     * @param {boolean} [streamCanWrite] 
     * @param {boolean} [streamCanSeek] 
     * @param {boolean} [streamCanTimeout] 
     * @param {number} [streamLength] 
     * @param {number} [streamPosition] 
     * @param {number} [streamReadTimeout] 
     * @param {number} [streamWriteTimeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public insertFileToMyFromBody(file?: File, title?: string, createNewIfExist?: boolean, keepConvertStatus?: boolean, streamCanRead?: boolean, streamCanWrite?: boolean, streamCanSeek?: boolean, streamCanTimeout?: boolean, streamLength?: number, streamPosition?: number, streamReadTimeout?: number, streamWriteTimeout?: number, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).insertFileToMyFromBody(file, title, createNewIfExist, keepConvertStatus, streamCanRead, streamCanWrite, streamCanSeek, streamCanTimeout, streamLength, streamPosition, streamReadTimeout, streamWriteTimeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Renames the selected folder with a new title specified in the request.
     * @summary Rename a folder
     * @param {number} folderId Folder ID
     * @param {CreateFolder} [createFolder] Folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public renameFolder(folderId: number, createFolder?: CreateFolder, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).renameFolder(folderId, createFolder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets file order in the folder with ID specified in the request
     * @summary Sets file order in the folder with ID specified in the request
     * @param {number} folderId The unique identifier of the folder
     * @param {OrderRequestDto} [orderRequestDto] Order information for the folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public setFileOrder(folderId: number, orderRequestDto?: OrderRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).setFileOrder(folderId, orderRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
     * @summary Upload a file
     * @param {number} folderId Folder ID
     * @param {UploadRequestDto} [uploadRequestDto] Upload data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public uploadFile(folderId: number, uploadRequestDto?: UploadRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).uploadFile(folderId, uploadRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>
     * @summary Upload a file to the \"My documents\" section
     * @param {UploadRequestDto} [inDto] Request parameters for uploading a file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesFoldersApi
     */
    public uploadFileToMy(inDto?: UploadRequestDto, options?: RawAxiosRequestConfig) {
        return FilesFoldersApiFp(this.configuration).uploadFileToMy(inDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesOperationsApi - axios parameter creator
 * @export
 */
export const FilesOperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Starts the download process of files and folders with the IDs specified in the request.
         * @summary Bulk download
         * @param {DownloadRequestDto} [downloadRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownload: async (downloadRequestDto?: DownloadRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/bulkdownload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(downloadRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks the conversion status of a file with the ID specified in the request.
         * @summary Get conversion status
         * @param {number} fileId File ID
         * @param {boolean} [start] Specifies if a conversion operation is started or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConversion: async (fileId: number, start?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('checkConversion', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/checkconversion`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copies all the selected files and folders to the folder with the ID specified in the request.
         * @summary Copy to a folder
         * @param {BatchRequestDto} [batchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyBatchItems: async (batchRequestDto?: BatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/copy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session to upload large files in multiple chunks to the folder with the ID specified in the request.   **Note**: Each chunk can have different length but the length should be multiple of <b>512</b> and greater or equal to <b>10 mb</b>. Last chunk can have any size.  After the initial response to the request with the <b>200 OK</b> status, you must get the <em>location</em> field value from the response. Send all your chunks to this location.  Each chunk must be sent in the exact order the chunks appear in the file.  After receiving each chunk, the server will respond with the current information about the upload session if no errors occurred.  When the number of bytes uploaded is equal to the number of bytes you sent in the initial request, the server responds with the <b>201 Created</b> status and sends you information about the uploaded file.
         * @summary Chunked upload
         * @param {number} folderId Folder ID
         * @param {SessionRequest} [sessionRequest] Session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadSession: async (folderId: number, sessionRequest?: SessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createUploadSession', 'folderId', folderId)
            const localVarPath = `/api/2.0/files/{folderId}/upload/create_session`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the files and folders with the IDs specified in the request.
         * @summary Delete files and folders
         * @param {DeleteBatchRequestDto} [deleteBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchItems: async (deleteBatchRequestDto?: DeleteBatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteBatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteVersionBatchRequestDto} [deleteVersionBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileVersions: async (deleteVersionBatchRequestDto?: DeleteVersionBatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/deleteversion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteVersionBatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates all the selected files and folders
         * @summary Duplicates all the selected files and folders
         * @param {DuplicateRequestDto} [duplicateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateBatchItems: async (duplicateRequestDto?: DuplicateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/duplicate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duplicateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all the files and folders from the \"Trash\" folder.
         * @summary Empty the \"Trash\" folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/emptytrash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the active operations.
         * @summary Get active operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationStatuses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the statuses of operations filtered by the specified operation type.
         * @summary Retrieves the statuses of operations filtered by the specified operation type.
         * @param {FileOperationType} operationType Specifies the type of file operation to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationStatusesByType: async (operationType: FileOperationType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationType' is not null or undefined
            assertParamExists('getOperationStatusesByType', 'operationType', operationType)
            const localVarPath = `/api/2.0/files/fileops/{operationType}`
                .replace(`{${"operationType"}}`, encodeURIComponent(String(operationType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks the files and folders with the IDs specified in the request as read.
         * @summary Mark as read
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead: async (baseBatchRequestDto?: BaseBatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/markasread`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseBatchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves all the selected files and folders to the folder with the ID specified in the request.
         * @summary Move to a folder
         * @param {BatchRequestDto} [batchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBatchItems: async (batchRequestDto?: BatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks a batch of files and folders for conflicts when moving or copying them to the folder with the ID specified in the request.
         * @summary Check files and folders for conflicts
         * @param {BatchRequestDto} [inDto] Request parameters for copying/moving files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveOrCopyBatchCheck: async (inDto?: BatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (inDto !== undefined) {
                for (const [key, value] of Object.entries(inDto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves or copies
         * @summary Moves or copies
         * @param {BatchRequestDto} [inDto] Request parameters for copying/moving files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveOrCopyDestFolderCheck: async (inDto?: BatchRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/fileops/checkdestfolder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (inDto !== undefined) {
                for (const [key, value] of Object.entries(inDto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a conversion operation of a file with the ID specified in the request.
         * @summary Start file conversion
         * @param {number} fileId File ID
         * @param {CheckConversionRequestDtoInteger} [checkConversionRequestDtoInteger] Check conversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startConversion: async (fileId: number, checkConversionRequestDtoInteger?: CheckConversionRequestDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('startConversion', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/checkconversion`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkConversionRequestDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finishes an operation with the ID specified in the request or all the active operations.
         * @summary Finish active operations
         * @param {string} id Operation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateTasks: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('terminateTasks', 'id', id)
            const localVarPath = `/api/2.0/files/fileops/terminate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a comment in a file with the ID specified in the request.
         * @summary Update a comment
         * @param {number} fileId File ID
         * @param {UpdateComment} [updateComment] Parameters for updating a comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment: async (fileId: number, updateComment?: UpdateComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('updateComment', 'fileId', fileId)
            const localVarPath = `/api/2.0/files/file/{fileId}/comment`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesOperationsApi - functional programming interface
 * @export
 */
export const FilesOperationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesOperationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Starts the download process of files and folders with the IDs specified in the request.
         * @summary Bulk download
         * @param {DownloadRequestDto} [downloadRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDownload(downloadRequestDto?: DownloadRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDownload(downloadRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.bulkDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks the conversion status of a file with the ID specified in the request.
         * @summary Get conversion status
         * @param {number} fileId File ID
         * @param {boolean} [start] Specifies if a conversion operation is started or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkConversion(fileId: number, start?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationResultArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkConversion(fileId, start, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.checkConversion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Copies all the selected files and folders to the folder with the ID specified in the request.
         * @summary Copy to a folder
         * @param {BatchRequestDto} [batchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyBatchItems(batchRequestDto?: BatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyBatchItems(batchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.copyBatchItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a session to upload large files in multiple chunks to the folder with the ID specified in the request.   **Note**: Each chunk can have different length but the length should be multiple of <b>512</b> and greater or equal to <b>10 mb</b>. Last chunk can have any size.  After the initial response to the request with the <b>200 OK</b> status, you must get the <em>location</em> field value from the response. Send all your chunks to this location.  Each chunk must be sent in the exact order the chunks appear in the file.  After receiving each chunk, the server will respond with the current information about the upload session if no errors occurred.  When the number of bytes uploaded is equal to the number of bytes you sent in the initial request, the server responds with the <b>201 Created</b> status and sends you information about the uploaded file.
         * @summary Chunked upload
         * @param {number} folderId Folder ID
         * @param {SessionRequest} [sessionRequest] Session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUploadSession(folderId: number, sessionRequest?: SessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUploadSession(folderId, sessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.createUploadSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the files and folders with the IDs specified in the request.
         * @summary Delete files and folders
         * @param {DeleteBatchRequestDto} [deleteBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatchItems(deleteBatchRequestDto?: DeleteBatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatchItems(deleteBatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.deleteBatchItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteVersionBatchRequestDto} [deleteVersionBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileVersions(deleteVersionBatchRequestDto?: DeleteVersionBatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileVersions(deleteVersionBatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.deleteFileVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Duplicates all the selected files and folders
         * @summary Duplicates all the selected files and folders
         * @param {DuplicateRequestDto} [duplicateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async duplicateBatchItems(duplicateRequestDto?: DuplicateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.duplicateBatchItems(duplicateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.duplicateBatchItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all the files and folders from the \"Trash\" folder.
         * @summary Empty the \"Trash\" folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emptyTrash(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emptyTrash(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.emptyTrash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the active operations.
         * @summary Get active operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperationStatuses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperationStatuses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.getOperationStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the statuses of operations filtered by the specified operation type.
         * @summary Retrieves the statuses of operations filtered by the specified operation type.
         * @param {FileOperationType} operationType Specifies the type of file operation to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperationStatusesByType(operationType: FileOperationType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperationStatusesByType(operationType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.getOperationStatusesByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks the files and folders with the IDs specified in the request as read.
         * @summary Mark as read
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsRead(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsRead(baseBatchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.markAsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Moves all the selected files and folders to the folder with the ID specified in the request.
         * @summary Move to a folder
         * @param {BatchRequestDto} [batchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveBatchItems(batchRequestDto?: BatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveBatchItems(batchRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.moveBatchItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks a batch of files and folders for conflicts when moving or copying them to the folder with the ID specified in the request.
         * @summary Check files and folders for conflicts
         * @param {BatchRequestDto} [inDto] Request parameters for copying/moving files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveOrCopyBatchCheck(inDto?: BatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveOrCopyBatchCheck(inDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.moveOrCopyBatchCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Moves or copies
         * @summary Moves or copies
         * @param {BatchRequestDto} [inDto] Request parameters for copying/moving files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveOrCopyDestFolderCheck(inDto?: BatchRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckDestFolderWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveOrCopyDestFolderCheck(inDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.moveOrCopyDestFolderCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts a conversion operation of a file with the ID specified in the request.
         * @summary Start file conversion
         * @param {number} fileId File ID
         * @param {CheckConversionRequestDtoInteger} [checkConversionRequestDtoInteger] Check conversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startConversion(fileId: number, checkConversionRequestDtoInteger?: CheckConversionRequestDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationResultArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startConversion(fileId, checkConversionRequestDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.startConversion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finishes an operation with the ID specified in the request or all the active operations.
         * @summary Finish active operations
         * @param {string} id Operation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateTasks(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateTasks(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.terminateTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a comment in a file with the ID specified in the request.
         * @summary Update a comment
         * @param {number} fileId File ID
         * @param {UpdateComment} [updateComment] Parameters for updating a comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateComment(fileId: number, updateComment?: UpdateComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateComment(fileId, updateComment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesOperationsApi.updateComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesOperationsApi - factory interface
 * @export
 */
export const FilesOperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesOperationsApiFp(configuration)
    return {
        /**
         * Starts the download process of files and folders with the IDs specified in the request.
         * @summary Bulk download
         * @param {DownloadRequestDto} [downloadRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownload(downloadRequestDto?: DownloadRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.bulkDownload(downloadRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks the conversion status of a file with the ID specified in the request.
         * @summary Get conversion status
         * @param {number} fileId File ID
         * @param {boolean} [start] Specifies if a conversion operation is started or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConversion(fileId: number, start?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResultArrayWrapper> {
            return localVarFp.checkConversion(fileId, start, options).then((request) => request(axios, basePath));
        },
        /**
         * Copies all the selected files and folders to the folder with the ID specified in the request.
         * @summary Copy to a folder
         * @param {BatchRequestDto} [batchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyBatchItems(batchRequestDto?: BatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.copyBatchItems(batchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a session to upload large files in multiple chunks to the folder with the ID specified in the request.   **Note**: Each chunk can have different length but the length should be multiple of <b>512</b> and greater or equal to <b>10 mb</b>. Last chunk can have any size.  After the initial response to the request with the <b>200 OK</b> status, you must get the <em>location</em> field value from the response. Send all your chunks to this location.  Each chunk must be sent in the exact order the chunks appear in the file.  After receiving each chunk, the server will respond with the current information about the upload session if no errors occurred.  When the number of bytes uploaded is equal to the number of bytes you sent in the initial request, the server responds with the <b>201 Created</b> status and sends you information about the uploaded file.
         * @summary Chunked upload
         * @param {number} folderId Folder ID
         * @param {SessionRequest} [sessionRequest] Session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadSession(folderId: number, sessionRequest?: SessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.createUploadSession(folderId, sessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the files and folders with the IDs specified in the request.
         * @summary Delete files and folders
         * @param {DeleteBatchRequestDto} [deleteBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchItems(deleteBatchRequestDto?: DeleteBatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.deleteBatchItems(deleteBatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteVersionBatchRequestDto} [deleteVersionBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileVersions(deleteVersionBatchRequestDto?: DeleteVersionBatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationWrapper> {
            return localVarFp.deleteFileVersions(deleteVersionBatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates all the selected files and folders
         * @summary Duplicates all the selected files and folders
         * @param {DuplicateRequestDto} [duplicateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateBatchItems(duplicateRequestDto?: DuplicateRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.duplicateBatchItems(duplicateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all the files and folders from the \"Trash\" folder.
         * @summary Empty the \"Trash\" folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash(options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.emptyTrash(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the active operations.
         * @summary Get active operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationStatuses(options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.getOperationStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the statuses of operations filtered by the specified operation type.
         * @summary Retrieves the statuses of operations filtered by the specified operation type.
         * @param {FileOperationType} operationType Specifies the type of file operation to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationStatusesByType(operationType: FileOperationType, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.getOperationStatusesByType(operationType, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks the files and folders with the IDs specified in the request as read.
         * @summary Mark as read
         * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.markAsRead(baseBatchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves all the selected files and folders to the folder with the ID specified in the request.
         * @summary Move to a folder
         * @param {BatchRequestDto} [batchRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBatchItems(batchRequestDto?: BatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.moveBatchItems(batchRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks a batch of files and folders for conflicts when moving or copying them to the folder with the ID specified in the request.
         * @summary Check files and folders for conflicts
         * @param {BatchRequestDto} [inDto] Request parameters for copying/moving files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveOrCopyBatchCheck(inDto?: BatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FileEntryArrayWrapper> {
            return localVarFp.moveOrCopyBatchCheck(inDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves or copies
         * @summary Moves or copies
         * @param {BatchRequestDto} [inDto] Request parameters for copying/moving files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveOrCopyDestFolderCheck(inDto?: BatchRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<CheckDestFolderWrapper> {
            return localVarFp.moveOrCopyDestFolderCheck(inDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a conversion operation of a file with the ID specified in the request.
         * @summary Start file conversion
         * @param {number} fileId File ID
         * @param {CheckConversionRequestDtoInteger} [checkConversionRequestDtoInteger] Check conversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startConversion(fileId: number, checkConversionRequestDtoInteger?: CheckConversionRequestDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResultArrayWrapper> {
            return localVarFp.startConversion(fileId, checkConversionRequestDtoInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Finishes an operation with the ID specified in the request or all the active operations.
         * @summary Finish active operations
         * @param {string} id Operation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateTasks(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationArrayWrapper> {
            return localVarFp.terminateTasks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a comment in a file with the ID specified in the request.
         * @summary Update a comment
         * @param {number} fileId File ID
         * @param {UpdateComment} [updateComment] Parameters for updating a comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment(fileId: number, updateComment?: UpdateComment, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.updateComment(fileId, updateComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesOperationsApi - object-oriented interface
 * @export
 * @class FilesOperationsApi
 * @extends {BaseAPI}
 */
export class FilesOperationsApi extends BaseAPI {
    /**
     * Starts the download process of files and folders with the IDs specified in the request.
     * @summary Bulk download
     * @param {DownloadRequestDto} [downloadRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public bulkDownload(downloadRequestDto?: DownloadRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).bulkDownload(downloadRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks the conversion status of a file with the ID specified in the request.
     * @summary Get conversion status
     * @param {number} fileId File ID
     * @param {boolean} [start] Specifies if a conversion operation is started or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public checkConversion(fileId: number, start?: boolean, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).checkConversion(fileId, start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copies all the selected files and folders to the folder with the ID specified in the request.
     * @summary Copy to a folder
     * @param {BatchRequestDto} [batchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public copyBatchItems(batchRequestDto?: BatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).copyBatchItems(batchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a session to upload large files in multiple chunks to the folder with the ID specified in the request.   **Note**: Each chunk can have different length but the length should be multiple of <b>512</b> and greater or equal to <b>10 mb</b>. Last chunk can have any size.  After the initial response to the request with the <b>200 OK</b> status, you must get the <em>location</em> field value from the response. Send all your chunks to this location.  Each chunk must be sent in the exact order the chunks appear in the file.  After receiving each chunk, the server will respond with the current information about the upload session if no errors occurred.  When the number of bytes uploaded is equal to the number of bytes you sent in the initial request, the server responds with the <b>201 Created</b> status and sends you information about the uploaded file.
     * @summary Chunked upload
     * @param {number} folderId Folder ID
     * @param {SessionRequest} [sessionRequest] Session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public createUploadSession(folderId: number, sessionRequest?: SessionRequest, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).createUploadSession(folderId, sessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the files and folders with the IDs specified in the request.
     * @summary Delete files and folders
     * @param {DeleteBatchRequestDto} [deleteBatchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public deleteBatchItems(deleteBatchRequestDto?: DeleteBatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).deleteBatchItems(deleteBatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteVersionBatchRequestDto} [deleteVersionBatchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public deleteFileVersions(deleteVersionBatchRequestDto?: DeleteVersionBatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).deleteFileVersions(deleteVersionBatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Duplicates all the selected files and folders
     * @summary Duplicates all the selected files and folders
     * @param {DuplicateRequestDto} [duplicateRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public duplicateBatchItems(duplicateRequestDto?: DuplicateRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).duplicateBatchItems(duplicateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all the files and folders from the \"Trash\" folder.
     * @summary Empty the \"Trash\" folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public emptyTrash(options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).emptyTrash(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the active operations.
     * @summary Get active operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public getOperationStatuses(options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).getOperationStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the statuses of operations filtered by the specified operation type.
     * @summary Retrieves the statuses of operations filtered by the specified operation type.
     * @param {FileOperationType} operationType Specifies the type of file operation to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public getOperationStatusesByType(operationType: FileOperationType, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).getOperationStatusesByType(operationType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks the files and folders with the IDs specified in the request as read.
     * @summary Mark as read
     * @param {BaseBatchRequestDto} [baseBatchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public markAsRead(baseBatchRequestDto?: BaseBatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).markAsRead(baseBatchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moves all the selected files and folders to the folder with the ID specified in the request.
     * @summary Move to a folder
     * @param {BatchRequestDto} [batchRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public moveBatchItems(batchRequestDto?: BatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).moveBatchItems(batchRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks a batch of files and folders for conflicts when moving or copying them to the folder with the ID specified in the request.
     * @summary Check files and folders for conflicts
     * @param {BatchRequestDto} [inDto] Request parameters for copying/moving files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public moveOrCopyBatchCheck(inDto?: BatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).moveOrCopyBatchCheck(inDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moves or copies
     * @summary Moves or copies
     * @param {BatchRequestDto} [inDto] Request parameters for copying/moving files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public moveOrCopyDestFolderCheck(inDto?: BatchRequestDto, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).moveOrCopyDestFolderCheck(inDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a conversion operation of a file with the ID specified in the request.
     * @summary Start file conversion
     * @param {number} fileId File ID
     * @param {CheckConversionRequestDtoInteger} [checkConversionRequestDtoInteger] Check conversion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public startConversion(fileId: number, checkConversionRequestDtoInteger?: CheckConversionRequestDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).startConversion(fileId, checkConversionRequestDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finishes an operation with the ID specified in the request or all the active operations.
     * @summary Finish active operations
     * @param {string} id Operation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public terminateTasks(id: string, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).terminateTasks(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a comment in a file with the ID specified in the request.
     * @summary Update a comment
     * @param {number} fileId File ID
     * @param {UpdateComment} [updateComment] Parameters for updating a comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesOperationsApi
     */
    public updateComment(fileId: number, updateComment?: UpdateComment, options?: RawAxiosRequestConfig) {
        return FilesOperationsApiFp(this.configuration).updateComment(fileId, updateComment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesQuotaApi - axios parameter creator
 * @export
 */
export const FilesQuotaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resets a quota limit for the rooms with the IDs specified in the request.
         * @summary Reset a room quota limit
         * @param {UpdateRoomsRoomIdsRequestDtoInteger} [updateRoomsRoomIdsRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetRoomQuota: async (updateRoomsRoomIdsRequestDtoInteger?: UpdateRoomsRoomIdsRequestDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms/resetquota`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomsRoomIdsRequestDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a quota limit for the rooms with the IDs specified in the request.
         * @summary Change a room quota limit
         * @param {UpdateRoomsQuotaRequestDtoInteger} [updateRoomsQuotaRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoomsQuota: async (updateRoomsQuotaRequestDtoInteger?: UpdateRoomsQuotaRequestDtoInteger, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms/roomquota`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomsQuotaRequestDtoInteger, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesQuotaApi - functional programming interface
 * @export
 */
export const FilesQuotaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesQuotaApiAxiosParamCreator(configuration)
    return {
        /**
         * Resets a quota limit for the rooms with the IDs specified in the request.
         * @summary Reset a room quota limit
         * @param {UpdateRoomsRoomIdsRequestDtoInteger} [updateRoomsRoomIdsRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetRoomQuota(updateRoomsRoomIdsRequestDtoInteger?: UpdateRoomsRoomIdsRequestDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetRoomQuota(updateRoomsRoomIdsRequestDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesQuotaApi.resetRoomQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes a quota limit for the rooms with the IDs specified in the request.
         * @summary Change a room quota limit
         * @param {UpdateRoomsQuotaRequestDtoInteger} [updateRoomsQuotaRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoomsQuota(updateRoomsQuotaRequestDtoInteger?: UpdateRoomsQuotaRequestDtoInteger, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoomsQuota(updateRoomsQuotaRequestDtoInteger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesQuotaApi.updateRoomsQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesQuotaApi - factory interface
 * @export
 */
export const FilesQuotaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesQuotaApiFp(configuration)
    return {
        /**
         * Resets a quota limit for the rooms with the IDs specified in the request.
         * @summary Reset a room quota limit
         * @param {UpdateRoomsRoomIdsRequestDtoInteger} [updateRoomsRoomIdsRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetRoomQuota(updateRoomsRoomIdsRequestDtoInteger?: UpdateRoomsRoomIdsRequestDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerArrayWrapper> {
            return localVarFp.resetRoomQuota(updateRoomsRoomIdsRequestDtoInteger, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes a quota limit for the rooms with the IDs specified in the request.
         * @summary Change a room quota limit
         * @param {UpdateRoomsQuotaRequestDtoInteger} [updateRoomsQuotaRequestDtoInteger] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoomsQuota(updateRoomsQuotaRequestDtoInteger?: UpdateRoomsQuotaRequestDtoInteger, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerArrayWrapper> {
            return localVarFp.updateRoomsQuota(updateRoomsQuotaRequestDtoInteger, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesQuotaApi - object-oriented interface
 * @export
 * @class FilesQuotaApi
 * @extends {BaseAPI}
 */
export class FilesQuotaApi extends BaseAPI {
    /**
     * Resets a quota limit for the rooms with the IDs specified in the request.
     * @summary Reset a room quota limit
     * @param {UpdateRoomsRoomIdsRequestDtoInteger} [updateRoomsRoomIdsRequestDtoInteger] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesQuotaApi
     */
    public resetRoomQuota(updateRoomsRoomIdsRequestDtoInteger?: UpdateRoomsRoomIdsRequestDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesQuotaApiFp(this.configuration).resetRoomQuota(updateRoomsRoomIdsRequestDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes a quota limit for the rooms with the IDs specified in the request.
     * @summary Change a room quota limit
     * @param {UpdateRoomsQuotaRequestDtoInteger} [updateRoomsQuotaRequestDtoInteger] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesQuotaApi
     */
    public updateRoomsQuota(updateRoomsQuotaRequestDtoInteger?: UpdateRoomsQuotaRequestDtoInteger, options?: RawAxiosRequestConfig) {
        return FilesQuotaApiFp(this.configuration).updateRoomsQuota(updateRoomsQuotaRequestDtoInteger, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesRoomsApi - axios parameter creator
 * @export
 */
export const FilesRoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds the tags to a room with the ID specified in the request.
         * @summary Add room tags
         * @param {number} id Room Id
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] Batch tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTags: async (id: number, batchTagsRequestDto?: BatchTagsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addTags', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchTagsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves a room with the ID specified in the request to the \"Archive\" section.
         * @summary Archive a room
         * @param {number} id Room ID
         * @param {ArchiveRoomRequest} [archiveRoomRequest] Parameters for archiving a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRoom: async (id: number, archiveRoomRequest?: ArchiveRoomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveRoom', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archiveRoomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes room cover
         * @summary Changes room cover
         * @param {number} id Room ID
         * @param {CoverRequestDto} [coverRequestDto] Parameters to change the room cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeRoomCover: async (id: number, coverRequestDto?: CoverRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeRoomCover', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/cover`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coverRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a room in the \"Rooms\" section.
         * @summary Create a room
         * @param {CreateRoomRequestDto} [createRoomRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom: async (createRoomRequestDto?: CreateRoomRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start create a room in the \"Rooms\" section based on a template.
         * @summary Start create a room based on a template
         * @param {CreateRoomFromTemplateDto} [createRoomFromTemplateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomFromTemplate: async (createRoomFromTemplateDto?: CreateRoomFromTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms/fromtemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomFromTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a logo for a room with the ID specified in the request.
         * @summary Create a room logo
         * @param {number} id Room Id
         * @param {LogoRequest} [logoRequest] Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomLogo: async (id: number, logoRequest?: LogoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createRoomLogo', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a room in the \"Rooms\" section stored in a third-party storage.
         * @summary Create a third-party room
         * @param {string} id ID of the folder in the third-party storage in which the contents of the room will be stored
         * @param {CreateThirdPartyRoom} [createThirdPartyRoom] ThirdParty room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomThirdParty: async (id: string, createThirdPartyRoom?: CreateThirdPartyRoom, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createRoomThirdParty', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/thirdparty/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createThirdPartyRoom, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a custom tag with the parameters specified in the request.
         * @summary Create a tag
         * @param {CreateTagRequestDto} [createTagRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (createTagRequestDto?: CreateTagRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start create room template
         * @summary Start create room template
         * @param {RoomTemplateDto} [roomTemplateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (roomTemplateDto?: RoomTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/roomtemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a bunch of custom tags specified in the request.
         * @summary Delete tags
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomTags: async (batchTagsRequestDto?: BatchTagsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchTagsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a room with the ID specified in the request.
         * @summary Remove a room
         * @param {number} id Room ID
         * @param {DeleteRoomRequest} [deleteRoomRequest] Parameters for deleting a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom: async (id: number, deleteRoomRequest?: DeleteRoomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoom', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRoomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a logo from a room with the ID specified in the request.
         * @summary Remove a room logo
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoomLogo: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoomLogo', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the tags from a room with the ID specified in the request.
         * @summary Remove room tags
         * @param {number} id Room Id
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] Batch tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTags: async (id: number, batchTagsRequestDto?: BatchTagsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTags', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchTagsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets covers
         * @summary Gets covers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCovers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms/covers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the new items from a room with the ID specified in the request.
         * @summary Get new room items
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewRoomItems: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNewRoomItems', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/news`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get progress creating room based a template
         * @summary Get progress creating room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomCreatingStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms/fromtemplate/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets room index export
         * @summary Gets room index export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomIndexExport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms/indexexport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the room information.
         * @summary Get room information
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInfo: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoomInfo', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the links of a room with the ID specified in the request.
         * @summary Get room links
         * @param {number} id Room ID
         * @param {LinkType} [type] Link type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomLinks: async (id: number, type?: LinkType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoomLinks', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the access rights of a room with the ID specified in the request.
         * @summary Get room access rights
         * @param {number} id Room ID
         * @param {ShareFilterType} [filterType] Share filter type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomSecurityInfo: async (id: number, filterType?: ShareFilterType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoomSecurityInfo', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/share`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the contents of the \"Rooms\" section by the parameters specified in the request.
         * @summary Get rooms
         * @param {Array<RoomType>} [type] Filter by room type
         * @param {string} [subjectId] Filter by user ID
         * @param {SearchArea} [searchArea] Room search area (Active, Archive, Any, Recent by links)
         * @param {boolean} [withoutTags] Specifies whether to search by tags or not
         * @param {string} [tags] Tags in the serialized format
         * @param {boolean} [excludeSubject] Specifies whether to exclude a subject or not
         * @param {ProviderFilter} [provider] Filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage)
         * @param {SubjectFilter} [subjectFilter] Filter by subject (Owner - 0, Member - 1)
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {StorageFilter} [storageFilter] Filter by storage (None - 0, Internal - 1, ThirdParty - 2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomsFolder: async (type?: Array<RoomType>, subjectId?: string, searchArea?: SearchArea, withoutTags?: boolean, tags?: string, excludeSubject?: boolean, provider?: ProviderFilter, subjectFilter?: SubjectFilter, quotaFilter?: QuotaFilter, storageFilter?: StorageFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (type) {
                localVarQueryParameter['type'] = type.join(COLLECTION_FORMATS.csv);
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subjectId'] = subjectId;
            }

            if (searchArea !== undefined) {
                localVarQueryParameter['searchArea'] = searchArea;
            }

            if (withoutTags !== undefined) {
                localVarQueryParameter['withoutTags'] = withoutTags;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (excludeSubject !== undefined) {
                localVarQueryParameter['excludeSubject'] = excludeSubject;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (subjectFilter !== undefined) {
                localVarQueryParameter['subjectFilter'] = subjectFilter;
            }

            if (quotaFilter !== undefined) {
                localVarQueryParameter['quotaFilter'] = quotaFilter;
            }

            if (storageFilter !== undefined) {
                localVarQueryParameter['storageFilter'] = storageFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets room new items
         * @summary Gets room new items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomsNewItems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the primary external link of a room with the ID specified in the request.
         * @summary Get primary external link
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomsPrimaryExternalLink: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoomsPrimaryExternalLink', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of custom tags.
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get progress creating room template
         * @summary Get progress creating room template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateCreatingStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/roomtemplate/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public settings
         * @summary Get public
         * @param {number} id Template id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isPublic: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('isPublic', 'id', id)
            const localVarPath = `/api/2.0/files/roomtemplate/{id}/public`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pins a room with the ID specified in the request to the top of the list.
         * @summary Pin a room
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinRoom: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pinRoom', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/pin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reorders to a room with ID specified in the request
         * @summary Reorders to a room with ID specified in the request
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorder: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reorder', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/reorder`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends the email invitations to a room with the ID specified in the request to the selected users.
         * @summary Resend room invitations
         * @param {number} id Room Id
         * @param {UserInvitation} [userInvitation] User invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailInvitations: async (id: number, userInvitation?: UserInvitation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendEmailInvitations', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/resend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvitation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets an external or invitation link with the ID specified in the request.
         * @summary Set an external or invitation link
         * @param {number} id Room ID
         * @param {RoomLinkRequest} [roomLinkRequest] Room link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLink: async (id: number, roomLinkRequest?: RoomLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setLink', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set public settings
         * @summary Set public
         * @param {SetPublicDto} [setPublicDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublic: async (setPublicDto?: SetPublicDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/roomtemplate/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPublicDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the access rights to a room with the ID specified in the request.
         * @summary Set room access rights
         * @param {number} id Room ID
         * @param {RoomInvitationRequest} [roomInvitationRequest] Room invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomSecurity: async (id: number, roomInvitationRequest?: RoomInvitationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setRoomSecurity', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/share`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomInvitationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts room index export
         * @summary Starts room index export
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRoomIndexExport: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startRoomIndexExport', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/indexexport`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates room index export
         * @summary Terminates room index export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRoomIndexExport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/rooms/indexexport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves a room with the ID specified in the request from the \"Archive\" section to the \"Rooms\" section.
         * @summary Unarchive a room
         * @param {number} id Room ID
         * @param {ArchiveRoomRequest} [archiveRoomRequest] Parameters for archiving a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveRoom: async (id: number, archiveRoomRequest?: ArchiveRoomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unarchiveRoom', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/unarchive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archiveRoomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpins a room with the ID specified in the request from the top of the list.
         * @summary Unpin a room
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinRoom: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unpinRoom', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}/unpin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames a room with the ID specified in  the request.
         * @summary Rename a room
         * @param {number} id Room ID
         * @param {UpdateRoomRequest} [updateRoomRequest] Update room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoom: async (id: number, updateRoomRequest?: UpdateRoomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRoom', 'id', id)
            const localVarPath = `/api/2.0/files/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a temporary image to create a room logo.
         * @summary Upload an image for room logo
         * @param {Array<KeyValuePairStringStringValues>} [formCollection] Image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRoomLogo: async (formCollection?: Array<KeyValuePairStringStringValues>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/logos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication asc_auth_key required

            if (formCollection) {
                formCollection.forEach((element) => {
                    localVarFormParams.append('FormCollection', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesRoomsApi - functional programming interface
 * @export
 */
export const FilesRoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesRoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds the tags to a room with the ID specified in the request.
         * @summary Add room tags
         * @param {number} id Room Id
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] Batch tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTags(id: number, batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTags(id, batchTagsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.addTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Moves a room with the ID specified in the request to the \"Archive\" section.
         * @summary Archive a room
         * @param {number} id Room ID
         * @param {ArchiveRoomRequest} [archiveRoomRequest] Parameters for archiving a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveRoom(id: number, archiveRoomRequest?: ArchiveRoomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveRoom(id, archiveRoomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.archiveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes room cover
         * @summary Changes room cover
         * @param {number} id Room ID
         * @param {CoverRequestDto} [coverRequestDto] Parameters to change the room cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeRoomCover(id: number, coverRequestDto?: CoverRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeRoomCover(id, coverRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.changeRoomCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a room in the \"Rooms\" section.
         * @summary Create a room
         * @param {CreateRoomRequestDto} [createRoomRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoom(createRoomRequestDto?: CreateRoomRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoom(createRoomRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.createRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start create a room in the \"Rooms\" section based on a template.
         * @summary Start create a room based on a template
         * @param {CreateRoomFromTemplateDto} [createRoomFromTemplateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoomFromTemplate(createRoomFromTemplateDto?: CreateRoomFromTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomFromTemplateStatusWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoomFromTemplate(createRoomFromTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.createRoomFromTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a logo for a room with the ID specified in the request.
         * @summary Create a room logo
         * @param {number} id Room Id
         * @param {LogoRequest} [logoRequest] Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoomLogo(id: number, logoRequest?: LogoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoomLogo(id, logoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.createRoomLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a room in the \"Rooms\" section stored in a third-party storage.
         * @summary Create a third-party room
         * @param {string} id ID of the folder in the third-party storage in which the contents of the room will be stored
         * @param {CreateThirdPartyRoom} [createThirdPartyRoom] ThirdParty room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoomThirdParty(id: string, createThirdPartyRoom?: CreateThirdPartyRoom, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderStringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoomThirdParty(id, createThirdPartyRoom, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.createRoomThirdParty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a custom tag with the parameters specified in the request.
         * @summary Create a tag
         * @param {CreateTagRequestDto} [createTagRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(createTagRequestDto?: CreateTagRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(createTagRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.createTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start create room template
         * @summary Start create room template
         * @param {RoomTemplateDto} [roomTemplateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(roomTemplateDto?: RoomTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomTemplateStatusWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(roomTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.createTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a bunch of custom tags specified in the request.
         * @summary Delete tags
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomTags(batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomTags(batchTagsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.deleteCustomTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a room with the ID specified in the request.
         * @summary Remove a room
         * @param {number} id Room ID
         * @param {DeleteRoomRequest} [deleteRoomRequest] Parameters for deleting a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoom(id: number, deleteRoomRequest?: DeleteRoomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoom(id, deleteRoomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.deleteRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a logo from a room with the ID specified in the request.
         * @summary Remove a room logo
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoomLogo(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoomLogo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.deleteRoomLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the tags from a room with the ID specified in the request.
         * @summary Remove room tags
         * @param {number} id Room Id
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] Batch tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTags(id: number, batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTags(id, batchTagsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.deleteTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets covers
         * @summary Gets covers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCovers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoversResultArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCovers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getCovers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the new items from a room with the ID specified in the request.
         * @summary Get new room items
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewRoomItems(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewItemsFileEntryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewRoomItems(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getNewRoomItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get progress creating room based a template
         * @summary Get progress creating room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomCreatingStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomFromTemplateStatusWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomCreatingStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getRoomCreatingStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets room index export
         * @summary Gets room index export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomIndexExport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentBuilderTaskWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomIndexExport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getRoomIndexExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the room information.
         * @summary Get room information
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomInfo(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomInfo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the links of a room with the ID specified in the request.
         * @summary Get room links
         * @param {number} id Room ID
         * @param {LinkType} [type] Link type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomLinks(id: number, type?: LinkType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomLinks(id, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getRoomLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the access rights of a room with the ID specified in the request.
         * @summary Get room access rights
         * @param {number} id Room ID
         * @param {ShareFilterType} [filterType] Share filter type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomSecurityInfo(id: number, filterType?: ShareFilterType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomSecurityInfo(id, filterType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getRoomSecurityInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the contents of the \"Rooms\" section by the parameters specified in the request.
         * @summary Get rooms
         * @param {Array<RoomType>} [type] Filter by room type
         * @param {string} [subjectId] Filter by user ID
         * @param {SearchArea} [searchArea] Room search area (Active, Archive, Any, Recent by links)
         * @param {boolean} [withoutTags] Specifies whether to search by tags or not
         * @param {string} [tags] Tags in the serialized format
         * @param {boolean} [excludeSubject] Specifies whether to exclude a subject or not
         * @param {ProviderFilter} [provider] Filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage)
         * @param {SubjectFilter} [subjectFilter] Filter by subject (Owner - 0, Member - 1)
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {StorageFilter} [storageFilter] Filter by storage (None - 0, Internal - 1, ThirdParty - 2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomsFolder(type?: Array<RoomType>, subjectId?: string, searchArea?: SearchArea, withoutTags?: boolean, tags?: string, excludeSubject?: boolean, provider?: ProviderFilter, subjectFilter?: SubjectFilter, quotaFilter?: QuotaFilter, storageFilter?: StorageFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomsFolder(type, subjectId, searchArea, withoutTags, tags, excludeSubject, provider, subjectFilter, quotaFilter, storageFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getRoomsFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets room new items
         * @summary Gets room new items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomsNewItems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewItemsRoomNewItemsArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomsNewItems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getRoomsNewItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the primary external link of a room with the ID specified in the request.
         * @summary Get primary external link
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomsPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomsPrimaryExternalLink(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getRoomsPrimaryExternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of custom tags.
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagsInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagsInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getTagsInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get progress creating room template
         * @summary Get progress creating room template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateCreatingStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomTemplateStatusWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateCreatingStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.getTemplateCreatingStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get public settings
         * @summary Get public
         * @param {number} id Template id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isPublic(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isPublic(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.isPublic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pins a room with the ID specified in the request to the top of the list.
         * @summary Pin a room
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinRoom(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinRoom(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.pinRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reorders to a room with ID specified in the request
         * @summary Reorders to a room with ID specified in the request
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorder(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.reorder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends the email invitations to a room with the ID specified in the request to the selected users.
         * @summary Resend room invitations
         * @param {number} id Room Id
         * @param {UserInvitation} [userInvitation] User invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmailInvitations(id: number, userInvitation?: UserInvitation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmailInvitations(id, userInvitation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.resendEmailInvitations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets an external or invitation link with the ID specified in the request.
         * @summary Set an external or invitation link
         * @param {number} id Room ID
         * @param {RoomLinkRequest} [roomLinkRequest] Room link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLink(id: number, roomLinkRequest?: RoomLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLink(id, roomLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.setLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set public settings
         * @summary Set public
         * @param {SetPublicDto} [setPublicDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPublic(setPublicDto?: SetPublicDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPublic(setPublicDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.setPublic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the access rights to a room with the ID specified in the request.
         * @summary Set room access rights
         * @param {number} id Room ID
         * @param {RoomInvitationRequest} [roomInvitationRequest] Room invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoomSecurity(id: number, roomInvitationRequest?: RoomInvitationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomSecurityWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRoomSecurity(id, roomInvitationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.setRoomSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts room index export
         * @summary Starts room index export
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRoomIndexExport(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentBuilderTaskWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRoomIndexExport(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.startRoomIndexExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminates room index export
         * @summary Terminates room index export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateRoomIndexExport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateRoomIndexExport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.terminateRoomIndexExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Moves a room with the ID specified in the request from the \"Archive\" section to the \"Rooms\" section.
         * @summary Unarchive a room
         * @param {number} id Room ID
         * @param {ArchiveRoomRequest} [archiveRoomRequest] Parameters for archiving a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveRoom(id: number, archiveRoomRequest?: ArchiveRoomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileOperationWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveRoom(id, archiveRoomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.unarchiveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpins a room with the ID specified in the request from the top of the list.
         * @summary Unpin a room
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpinRoom(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpinRoom(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.unpinRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Renames a room with the ID specified in  the request.
         * @summary Rename a room
         * @param {number} id Room ID
         * @param {UpdateRoomRequest} [updateRoomRequest] Update room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoom(id: number, updateRoomRequest?: UpdateRoomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderIntegerWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoom(id, updateRoomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.updateRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a temporary image to create a room logo.
         * @summary Upload an image for room logo
         * @param {Array<KeyValuePairStringStringValues>} [formCollection] Image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRoomLogo(formCollection?: Array<KeyValuePairStringStringValues>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadResultWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRoomLogo(formCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesRoomsApi.uploadRoomLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesRoomsApi - factory interface
 * @export
 */
export const FilesRoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesRoomsApiFp(configuration)
    return {
        /**
         * Adds the tags to a room with the ID specified in the request.
         * @summary Add room tags
         * @param {number} id Room Id
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] Batch tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTags(id: number, batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.addTags(id, batchTagsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves a room with the ID specified in the request to the \"Archive\" section.
         * @summary Archive a room
         * @param {number} id Room ID
         * @param {ArchiveRoomRequest} [archiveRoomRequest] Parameters for archiving a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRoom(id: number, archiveRoomRequest?: ArchiveRoomRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationWrapper> {
            return localVarFp.archiveRoom(id, archiveRoomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes room cover
         * @summary Changes room cover
         * @param {number} id Room ID
         * @param {CoverRequestDto} [coverRequestDto] Parameters to change the room cover
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeRoomCover(id: number, coverRequestDto?: CoverRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.changeRoomCover(id, coverRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a room in the \"Rooms\" section.
         * @summary Create a room
         * @param {CreateRoomRequestDto} [createRoomRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom(createRoomRequestDto?: CreateRoomRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.createRoom(createRoomRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Start create a room in the \"Rooms\" section based on a template.
         * @summary Start create a room based on a template
         * @param {CreateRoomFromTemplateDto} [createRoomFromTemplateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomFromTemplate(createRoomFromTemplateDto?: CreateRoomFromTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomFromTemplateStatusWrapper> {
            return localVarFp.createRoomFromTemplate(createRoomFromTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a logo for a room with the ID specified in the request.
         * @summary Create a room logo
         * @param {number} id Room Id
         * @param {LogoRequest} [logoRequest] Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomLogo(id: number, logoRequest?: LogoRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.createRoomLogo(id, logoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a room in the \"Rooms\" section stored in a third-party storage.
         * @summary Create a third-party room
         * @param {string} id ID of the folder in the third-party storage in which the contents of the room will be stored
         * @param {CreateThirdPartyRoom} [createThirdPartyRoom] ThirdParty room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomThirdParty(id: string, createThirdPartyRoom?: CreateThirdPartyRoom, options?: RawAxiosRequestConfig): AxiosPromise<FolderStringWrapper> {
            return localVarFp.createRoomThirdParty(id, createThirdPartyRoom, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a custom tag with the parameters specified in the request.
         * @summary Create a tag
         * @param {CreateTagRequestDto} [createTagRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(createTagRequestDto?: CreateTagRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.createTag(createTagRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Start create room template
         * @summary Start create room template
         * @param {RoomTemplateDto} [roomTemplateDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(roomTemplateDto?: RoomTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomTemplateStatusWrapper> {
            return localVarFp.createTemplate(roomTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a bunch of custom tags specified in the request.
         * @summary Delete tags
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomTags(batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomTags(batchTagsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a room with the ID specified in the request.
         * @summary Remove a room
         * @param {number} id Room ID
         * @param {DeleteRoomRequest} [deleteRoomRequest] Parameters for deleting a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom(id: number, deleteRoomRequest?: DeleteRoomRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationWrapper> {
            return localVarFp.deleteRoom(id, deleteRoomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a logo from a room with the ID specified in the request.
         * @summary Remove a room logo
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoomLogo(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.deleteRoomLogo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the tags from a room with the ID specified in the request.
         * @summary Remove room tags
         * @param {number} id Room Id
         * @param {BatchTagsRequestDto} [batchTagsRequestDto] Batch tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTags(id: number, batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.deleteTags(id, batchTagsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets covers
         * @summary Gets covers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCovers(options?: RawAxiosRequestConfig): AxiosPromise<CoversResultArrayWrapper> {
            return localVarFp.getCovers(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the new items from a room with the ID specified in the request.
         * @summary Get new room items
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewRoomItems(id: number, options?: RawAxiosRequestConfig): AxiosPromise<NewItemsFileEntryArrayWrapper> {
            return localVarFp.getNewRoomItems(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get progress creating room based a template
         * @summary Get progress creating room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomCreatingStatus(options?: RawAxiosRequestConfig): AxiosPromise<RoomFromTemplateStatusWrapper> {
            return localVarFp.getRoomCreatingStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets room index export
         * @summary Gets room index export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomIndexExport(options?: RawAxiosRequestConfig): AxiosPromise<DocumentBuilderTaskWrapper> {
            return localVarFp.getRoomIndexExport(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the room information.
         * @summary Get room information
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInfo(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.getRoomInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the links of a room with the ID specified in the request.
         * @summary Get room links
         * @param {number} id Room ID
         * @param {LinkType} [type] Link type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomLinks(id: number, type?: LinkType, options?: RawAxiosRequestConfig): AxiosPromise<FileShareArrayWrapper> {
            return localVarFp.getRoomLinks(id, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the access rights of a room with the ID specified in the request.
         * @summary Get room access rights
         * @param {number} id Room ID
         * @param {ShareFilterType} [filterType] Share filter type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomSecurityInfo(id: number, filterType?: ShareFilterType, options?: RawAxiosRequestConfig): AxiosPromise<FileShareArrayWrapper> {
            return localVarFp.getRoomSecurityInfo(id, filterType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the contents of the \"Rooms\" section by the parameters specified in the request.
         * @summary Get rooms
         * @param {Array<RoomType>} [type] Filter by room type
         * @param {string} [subjectId] Filter by user ID
         * @param {SearchArea} [searchArea] Room search area (Active, Archive, Any, Recent by links)
         * @param {boolean} [withoutTags] Specifies whether to search by tags or not
         * @param {string} [tags] Tags in the serialized format
         * @param {boolean} [excludeSubject] Specifies whether to exclude a subject or not
         * @param {ProviderFilter} [provider] Filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage)
         * @param {SubjectFilter} [subjectFilter] Filter by subject (Owner - 0, Member - 1)
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {StorageFilter} [storageFilter] Filter by storage (None - 0, Internal - 1, ThirdParty - 2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomsFolder(type?: Array<RoomType>, subjectId?: string, searchArea?: SearchArea, withoutTags?: boolean, tags?: string, excludeSubject?: boolean, provider?: ProviderFilter, subjectFilter?: SubjectFilter, quotaFilter?: QuotaFilter, storageFilter?: StorageFilter, options?: RawAxiosRequestConfig): AxiosPromise<FolderContentIntegerWrapper> {
            return localVarFp.getRoomsFolder(type, subjectId, searchArea, withoutTags, tags, excludeSubject, provider, subjectFilter, quotaFilter, storageFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets room new items
         * @summary Gets room new items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomsNewItems(options?: RawAxiosRequestConfig): AxiosPromise<NewItemsRoomNewItemsArrayWrapper> {
            return localVarFp.getRoomsNewItems(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the primary external link of a room with the ID specified in the request.
         * @summary Get primary external link
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomsPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.getRoomsPrimaryExternalLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of custom tags.
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsInfo(options?: RawAxiosRequestConfig): AxiosPromise<ObjectArrayWrapper> {
            return localVarFp.getTagsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get progress creating room template
         * @summary Get progress creating room template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateCreatingStatus(options?: RawAxiosRequestConfig): AxiosPromise<RoomTemplateStatusWrapper> {
            return localVarFp.getTemplateCreatingStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get public settings
         * @summary Get public
         * @param {number} id Template id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isPublic(id: number, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.isPublic(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Pins a room with the ID specified in the request to the top of the list.
         * @summary Pin a room
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinRoom(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.pinRoom(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Reorders to a room with ID specified in the request
         * @summary Reorders to a room with ID specified in the request
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorder(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.reorder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends the email invitations to a room with the ID specified in the request to the selected users.
         * @summary Resend room invitations
         * @param {number} id Room Id
         * @param {UserInvitation} [userInvitation] User invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailInvitations(id: number, userInvitation?: UserInvitation, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendEmailInvitations(id, userInvitation, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets an external or invitation link with the ID specified in the request.
         * @summary Set an external or invitation link
         * @param {number} id Room ID
         * @param {RoomLinkRequest} [roomLinkRequest] Room link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLink(id: number, roomLinkRequest?: RoomLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileShareWrapper> {
            return localVarFp.setLink(id, roomLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set public settings
         * @summary Set public
         * @param {SetPublicDto} [setPublicDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublic(setPublicDto?: SetPublicDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setPublic(setPublicDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the access rights to a room with the ID specified in the request.
         * @summary Set room access rights
         * @param {number} id Room ID
         * @param {RoomInvitationRequest} [roomInvitationRequest] Room invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomSecurity(id: number, roomInvitationRequest?: RoomInvitationRequest, options?: RawAxiosRequestConfig): AxiosPromise<RoomSecurityWrapper> {
            return localVarFp.setRoomSecurity(id, roomInvitationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts room index export
         * @summary Starts room index export
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRoomIndexExport(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentBuilderTaskWrapper> {
            return localVarFp.startRoomIndexExport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates room index export
         * @summary Terminates room index export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRoomIndexExport(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.terminateRoomIndexExport(options).then((request) => request(axios, basePath));
        },
        /**
         * Moves a room with the ID specified in the request from the \"Archive\" section to the \"Rooms\" section.
         * @summary Unarchive a room
         * @param {number} id Room ID
         * @param {ArchiveRoomRequest} [archiveRoomRequest] Parameters for archiving a room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveRoom(id: number, archiveRoomRequest?: ArchiveRoomRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileOperationWrapper> {
            return localVarFp.unarchiveRoom(id, archiveRoomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpins a room with the ID specified in the request from the top of the list.
         * @summary Unpin a room
         * @param {number} id Room Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinRoom(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.unpinRoom(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames a room with the ID specified in  the request.
         * @summary Rename a room
         * @param {number} id Room ID
         * @param {UpdateRoomRequest} [updateRoomRequest] Update room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoom(id: number, updateRoomRequest?: UpdateRoomRequest, options?: RawAxiosRequestConfig): AxiosPromise<FolderIntegerWrapper> {
            return localVarFp.updateRoom(id, updateRoomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a temporary image to create a room logo.
         * @summary Upload an image for room logo
         * @param {Array<KeyValuePairStringStringValues>} [formCollection] Image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRoomLogo(formCollection?: Array<KeyValuePairStringStringValues>, options?: RawAxiosRequestConfig): AxiosPromise<UploadResultWrapper> {
            return localVarFp.uploadRoomLogo(formCollection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesRoomsApi - object-oriented interface
 * @export
 * @class FilesRoomsApi
 * @extends {BaseAPI}
 */
export class FilesRoomsApi extends BaseAPI {
    /**
     * Adds the tags to a room with the ID specified in the request.
     * @summary Add room tags
     * @param {number} id Room Id
     * @param {BatchTagsRequestDto} [batchTagsRequestDto] Batch tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public addTags(id: number, batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).addTags(id, batchTagsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moves a room with the ID specified in the request to the \"Archive\" section.
     * @summary Archive a room
     * @param {number} id Room ID
     * @param {ArchiveRoomRequest} [archiveRoomRequest] Parameters for archiving a room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public archiveRoom(id: number, archiveRoomRequest?: ArchiveRoomRequest, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).archiveRoom(id, archiveRoomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes room cover
     * @summary Changes room cover
     * @param {number} id Room ID
     * @param {CoverRequestDto} [coverRequestDto] Parameters to change the room cover
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public changeRoomCover(id: number, coverRequestDto?: CoverRequestDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).changeRoomCover(id, coverRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a room in the \"Rooms\" section.
     * @summary Create a room
     * @param {CreateRoomRequestDto} [createRoomRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public createRoom(createRoomRequestDto?: CreateRoomRequestDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).createRoom(createRoomRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start create a room in the \"Rooms\" section based on a template.
     * @summary Start create a room based on a template
     * @param {CreateRoomFromTemplateDto} [createRoomFromTemplateDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public createRoomFromTemplate(createRoomFromTemplateDto?: CreateRoomFromTemplateDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).createRoomFromTemplate(createRoomFromTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a logo for a room with the ID specified in the request.
     * @summary Create a room logo
     * @param {number} id Room Id
     * @param {LogoRequest} [logoRequest] Logo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public createRoomLogo(id: number, logoRequest?: LogoRequest, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).createRoomLogo(id, logoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a room in the \"Rooms\" section stored in a third-party storage.
     * @summary Create a third-party room
     * @param {string} id ID of the folder in the third-party storage in which the contents of the room will be stored
     * @param {CreateThirdPartyRoom} [createThirdPartyRoom] ThirdParty room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public createRoomThirdParty(id: string, createThirdPartyRoom?: CreateThirdPartyRoom, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).createRoomThirdParty(id, createThirdPartyRoom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a custom tag with the parameters specified in the request.
     * @summary Create a tag
     * @param {CreateTagRequestDto} [createTagRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public createTag(createTagRequestDto?: CreateTagRequestDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).createTag(createTagRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start create room template
     * @summary Start create room template
     * @param {RoomTemplateDto} [roomTemplateDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public createTemplate(roomTemplateDto?: RoomTemplateDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).createTemplate(roomTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a bunch of custom tags specified in the request.
     * @summary Delete tags
     * @param {BatchTagsRequestDto} [batchTagsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public deleteCustomTags(batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).deleteCustomTags(batchTagsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a room with the ID specified in the request.
     * @summary Remove a room
     * @param {number} id Room ID
     * @param {DeleteRoomRequest} [deleteRoomRequest] Parameters for deleting a room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public deleteRoom(id: number, deleteRoomRequest?: DeleteRoomRequest, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).deleteRoom(id, deleteRoomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a logo from a room with the ID specified in the request.
     * @summary Remove a room logo
     * @param {number} id Room Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public deleteRoomLogo(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).deleteRoomLogo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the tags from a room with the ID specified in the request.
     * @summary Remove room tags
     * @param {number} id Room Id
     * @param {BatchTagsRequestDto} [batchTagsRequestDto] Batch tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public deleteTags(id: number, batchTagsRequestDto?: BatchTagsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).deleteTags(id, batchTagsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets covers
     * @summary Gets covers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getCovers(options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getCovers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the new items from a room with the ID specified in the request.
     * @summary Get new room items
     * @param {number} id Room Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getNewRoomItems(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getNewRoomItems(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get progress creating room based a template
     * @summary Get progress creating room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getRoomCreatingStatus(options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getRoomCreatingStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets room index export
     * @summary Gets room index export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getRoomIndexExport(options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getRoomIndexExport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the room information.
     * @summary Get room information
     * @param {number} id Room Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getRoomInfo(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getRoomInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the links of a room with the ID specified in the request.
     * @summary Get room links
     * @param {number} id Room ID
     * @param {LinkType} [type] Link type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getRoomLinks(id: number, type?: LinkType, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getRoomLinks(id, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the access rights of a room with the ID specified in the request.
     * @summary Get room access rights
     * @param {number} id Room ID
     * @param {ShareFilterType} [filterType] Share filter type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getRoomSecurityInfo(id: number, filterType?: ShareFilterType, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getRoomSecurityInfo(id, filterType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the contents of the \"Rooms\" section by the parameters specified in the request.
     * @summary Get rooms
     * @param {Array<RoomType>} [type] Filter by room type
     * @param {string} [subjectId] Filter by user ID
     * @param {SearchArea} [searchArea] Room search area (Active, Archive, Any, Recent by links)
     * @param {boolean} [withoutTags] Specifies whether to search by tags or not
     * @param {string} [tags] Tags in the serialized format
     * @param {boolean} [excludeSubject] Specifies whether to exclude a subject or not
     * @param {ProviderFilter} [provider] Filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage)
     * @param {SubjectFilter} [subjectFilter] Filter by subject (Owner - 0, Member - 1)
     * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
     * @param {StorageFilter} [storageFilter] Filter by storage (None - 0, Internal - 1, ThirdParty - 2)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getRoomsFolder(type?: Array<RoomType>, subjectId?: string, searchArea?: SearchArea, withoutTags?: boolean, tags?: string, excludeSubject?: boolean, provider?: ProviderFilter, subjectFilter?: SubjectFilter, quotaFilter?: QuotaFilter, storageFilter?: StorageFilter, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getRoomsFolder(type, subjectId, searchArea, withoutTags, tags, excludeSubject, provider, subjectFilter, quotaFilter, storageFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets room new items
     * @summary Gets room new items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getRoomsNewItems(options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getRoomsNewItems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the primary external link of a room with the ID specified in the request.
     * @summary Get primary external link
     * @param {number} id Room Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getRoomsPrimaryExternalLink(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getRoomsPrimaryExternalLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of custom tags.
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getTagsInfo(options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getTagsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get progress creating room template
     * @summary Get progress creating room template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public getTemplateCreatingStatus(options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).getTemplateCreatingStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public settings
     * @summary Get public
     * @param {number} id Template id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public isPublic(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).isPublic(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pins a room with the ID specified in the request to the top of the list.
     * @summary Pin a room
     * @param {number} id Room Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public pinRoom(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).pinRoom(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reorders to a room with ID specified in the request
     * @summary Reorders to a room with ID specified in the request
     * @param {number} id Room Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public reorder(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).reorder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends the email invitations to a room with the ID specified in the request to the selected users.
     * @summary Resend room invitations
     * @param {number} id Room Id
     * @param {UserInvitation} [userInvitation] User invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public resendEmailInvitations(id: number, userInvitation?: UserInvitation, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).resendEmailInvitations(id, userInvitation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets an external or invitation link with the ID specified in the request.
     * @summary Set an external or invitation link
     * @param {number} id Room ID
     * @param {RoomLinkRequest} [roomLinkRequest] Room link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public setLink(id: number, roomLinkRequest?: RoomLinkRequest, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).setLink(id, roomLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set public settings
     * @summary Set public
     * @param {SetPublicDto} [setPublicDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public setPublic(setPublicDto?: SetPublicDto, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).setPublic(setPublicDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the access rights to a room with the ID specified in the request.
     * @summary Set room access rights
     * @param {number} id Room ID
     * @param {RoomInvitationRequest} [roomInvitationRequest] Room invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public setRoomSecurity(id: number, roomInvitationRequest?: RoomInvitationRequest, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).setRoomSecurity(id, roomInvitationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts room index export
     * @summary Starts room index export
     * @param {number} id Room Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public startRoomIndexExport(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).startRoomIndexExport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates room index export
     * @summary Terminates room index export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public terminateRoomIndexExport(options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).terminateRoomIndexExport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moves a room with the ID specified in the request from the \"Archive\" section to the \"Rooms\" section.
     * @summary Unarchive a room
     * @param {number} id Room ID
     * @param {ArchiveRoomRequest} [archiveRoomRequest] Parameters for archiving a room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public unarchiveRoom(id: number, archiveRoomRequest?: ArchiveRoomRequest, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).unarchiveRoom(id, archiveRoomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpins a room with the ID specified in the request from the top of the list.
     * @summary Unpin a room
     * @param {number} id Room Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public unpinRoom(id: number, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).unpinRoom(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Renames a room with the ID specified in  the request.
     * @summary Rename a room
     * @param {number} id Room ID
     * @param {UpdateRoomRequest} [updateRoomRequest] Update room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public updateRoom(id: number, updateRoomRequest?: UpdateRoomRequest, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).updateRoom(id, updateRoomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a temporary image to create a room logo.
     * @summary Upload an image for room logo
     * @param {Array<KeyValuePairStringStringValues>} [formCollection] Image data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRoomsApi
     */
    public uploadRoomLogo(formCollection?: Array<KeyValuePairStringStringValues>, options?: RawAxiosRequestConfig) {
        return FilesRoomsApiFp(this.configuration).uploadRoomLogo(formCollection, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesSettingsApi - axios parameter creator
 * @export
 */
export const FilesSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes the access to the third-party settings.
         * @summary Change the third-party settings access
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccessToThirdparty: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the trash bin auto-clearing setting.
         * @summary Update the trash bin auto-clearing setting
         * @param {AutoCleanupRequestDto} [autoCleanupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAutomaticallyCleanUp: async (autoCleanupRequestDto?: AutoCleanupRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/autocleanup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoCleanupRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the default access rights in the sharing settings.
         * @summary Change the default access rights
         * @param {Array<FileShare>} [fileShare] Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDefaultAccessRights: async (fileShare?: Array<FileShare>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/dafaultaccessrights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileShare, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies whether to confirm the file deletion or not.
         * @summary Confirm the file deletion
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDeleteConfirm: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/changedeleteconfrim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the format of the downloaded archive from .zip to .tar.gz. This method uses the body parameters.
         * @summary Change the archive format (using body parameters)
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDownloadZipFromBody: async (displayRequestDto?: DisplayRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/downloadtargz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(displayRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks the document service location.
         * @summary Check the document service URL
         * @param {CheckDocServiceUrlRequestDto} [checkDocServiceUrlRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDocServiceUrl: async (checkDocServiceUrlRequestDto?: CheckDocServiceUrlRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/docservice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkDocServiceUrlRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies whether to display a file extension or not.
         * @summary Display a file extension
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayFileExtension: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/displayfileextension`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to share a file externally.
         * @summary Change the external sharing ability
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalShare: async (displayRequestDto?: DisplayRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/external`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(displayRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to share a file externally on social networks.
         * @summary Change the external sharing ability on social networks
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalShareSocialMedia: async (displayRequestDto?: DisplayRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/externalsocialmedia`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(displayRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to force save a file.
         * @summary Change the forcasaving ability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forcesave: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/forcesave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the trash bin auto-clearing setting.
         * @summary Get the trash bin auto-clearing setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomaticallyCleanUp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/autocleanup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the information about the Documents module.
         * @summary Get the Documents information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesModule: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the file settings.
         * @summary Get file settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hide confirmation dialog when canceling operation.
         * @summary Hide confirmation dialog when canceling operation
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmCancelOperation: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/hideconfirmcanceloperation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides the confirmation dialog for saving the file copy in the original format when converting a file.
         * @summary Hide the confirmation dialog when converting
         * @param {HideConfirmConvertRequestDto} [hideConfirmConvertRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmConvert: async (hideConfirmConvertRequestDto?: HideConfirmConvertRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/hideconfirmconvert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hideConfirmConvertRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hide confirmation dialog when changing room lifetime settings.
         * @summary Hide confirmation dialog when changing room lifetime settings
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmRoomLifetime: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/hideconfirmroomlifetime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the Private Room settings are available or not.
         * @summary Check the Private Room availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAvailablePrivacyRoomSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/@privacy/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies whether to ask a user for a file name on creation or not.
         * @summary Ask a new file name
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keepNewFileName: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/keepnewfilename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the ability to open in a document in the same browser tab
         * @summary Open document in same browser tab
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOpenEditorInSameTab: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/settings/openeditorinsametab`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to store the forcesaved file versions.
         * @summary Change the ability to store the forcesaved files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeForcesave: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/storeforcesave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the ability to upload documents in the original formats as well.
         * @summary Change the ability to upload original formats
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOriginal: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/storeoriginal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a file version if a file with such a name already exists.
         * @summary Update a file version if it exists
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIfExist: async (settingsRequestDto?: SettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/updateifexist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesSettingsApi - functional programming interface
 * @export
 */
export const FilesSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Changes the access to the third-party settings.
         * @summary Change the third-party settings access
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAccessToThirdparty(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeAccessToThirdparty(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeAccessToThirdparty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the trash bin auto-clearing setting.
         * @summary Update the trash bin auto-clearing setting
         * @param {AutoCleanupRequestDto} [autoCleanupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAutomaticallyCleanUp(autoCleanupRequestDto?: AutoCleanupRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoCleanUpDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeAutomaticallyCleanUp(autoCleanupRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeAutomaticallyCleanUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the default access rights in the sharing settings.
         * @summary Change the default access rights
         * @param {Array<FileShare>} [fileShare] Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDefaultAccessRights(fileShare?: Array<FileShare>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShareArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDefaultAccessRights(fileShare, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeDefaultAccessRights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies whether to confirm the file deletion or not.
         * @summary Confirm the file deletion
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDeleteConfirm(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDeleteConfirm(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeDeleteConfirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the format of the downloaded archive from .zip to .tar.gz. This method uses the body parameters.
         * @summary Change the archive format (using body parameters)
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDownloadZipFromBody(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICompressWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDownloadZipFromBody(displayRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.changeDownloadZipFromBody']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks the document service location.
         * @summary Check the document service URL
         * @param {CheckDocServiceUrlRequestDto} [checkDocServiceUrlRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDocServiceUrl(checkDocServiceUrlRequestDto?: CheckDocServiceUrlRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocServiceUrlWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDocServiceUrl(checkDocServiceUrlRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.checkDocServiceUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies whether to display a file extension or not.
         * @summary Display a file extension
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayFileExtension(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayFileExtension(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.displayFileExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to share a file externally.
         * @summary Change the external sharing ability
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalShare(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalShare(displayRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.externalShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to share a file externally on social networks.
         * @summary Change the external sharing ability on social networks
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalShareSocialMedia(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalShareSocialMedia(displayRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.externalShareSocialMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to force save a file.
         * @summary Change the forcasaving ability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forcesave(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forcesave(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.forcesave']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the trash bin auto-clearing setting.
         * @summary Get the trash bin auto-clearing setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutomaticallyCleanUp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoCleanUpDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutomaticallyCleanUp(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.getAutomaticallyCleanUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the information about the Documents module.
         * @summary Get the Documents information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilesModule(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesModule(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.getFilesModule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all the file settings.
         * @summary Get file settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilesSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.getFilesSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hide confirmation dialog when canceling operation.
         * @summary Hide confirmation dialog when canceling operation
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideConfirmCancelOperation(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideConfirmCancelOperation(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.hideConfirmCancelOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hides the confirmation dialog for saving the file copy in the original format when converting a file.
         * @summary Hide the confirmation dialog when converting
         * @param {HideConfirmConvertRequestDto} [hideConfirmConvertRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideConfirmConvert(hideConfirmConvertRequestDto?: HideConfirmConvertRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideConfirmConvert(hideConfirmConvertRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.hideConfirmConvert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Hide confirmation dialog when changing room lifetime settings.
         * @summary Hide confirmation dialog when changing room lifetime settings
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideConfirmRoomLifetime(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideConfirmRoomLifetime(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.hideConfirmRoomLifetime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the Private Room settings are available or not.
         * @summary Check the Private Room availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAvailablePrivacyRoomSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAvailablePrivacyRoomSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.isAvailablePrivacyRoomSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies whether to ask a user for a file name on creation or not.
         * @summary Ask a new file name
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keepNewFileName(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keepNewFileName(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.keepNewFileName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change the ability to open in a document in the same browser tab
         * @summary Open document in same browser tab
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOpenEditorInSameTab(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOpenEditorInSameTab(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.setOpenEditorInSameTab']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to store the forcesaved file versions.
         * @summary Change the ability to store the forcesaved files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeForcesave(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeForcesave(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.storeForcesave']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the ability to upload documents in the original formats as well.
         * @summary Change the ability to upload original formats
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeOriginal(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeOriginal(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.storeOriginal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a file version if a file with such a name already exists.
         * @summary Update a file version if it exists
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIfExist(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIfExist(settingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesSettingsApi.updateIfExist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesSettingsApi - factory interface
 * @export
 */
export const FilesSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesSettingsApiFp(configuration)
    return {
        /**
         * Changes the access to the third-party settings.
         * @summary Change the third-party settings access
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccessToThirdparty(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.changeAccessToThirdparty(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the trash bin auto-clearing setting.
         * @summary Update the trash bin auto-clearing setting
         * @param {AutoCleanupRequestDto} [autoCleanupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAutomaticallyCleanUp(autoCleanupRequestDto?: AutoCleanupRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<AutoCleanUpDataWrapper> {
            return localVarFp.changeAutomaticallyCleanUp(autoCleanupRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the default access rights in the sharing settings.
         * @summary Change the default access rights
         * @param {Array<FileShare>} [fileShare] Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDefaultAccessRights(fileShare?: Array<FileShare>, options?: RawAxiosRequestConfig): AxiosPromise<FileShareArrayWrapper> {
            return localVarFp.changeDefaultAccessRights(fileShare, options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies whether to confirm the file deletion or not.
         * @summary Confirm the file deletion
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDeleteConfirm(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.changeDeleteConfirm(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the format of the downloaded archive from .zip to .tar.gz. This method uses the body parameters.
         * @summary Change the archive format (using body parameters)
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDownloadZipFromBody(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ICompressWrapper> {
            return localVarFp.changeDownloadZipFromBody(displayRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks the document service location.
         * @summary Check the document service URL
         * @param {CheckDocServiceUrlRequestDto} [checkDocServiceUrlRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDocServiceUrl(checkDocServiceUrlRequestDto?: CheckDocServiceUrlRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<DocServiceUrlWrapper> {
            return localVarFp.checkDocServiceUrl(checkDocServiceUrlRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies whether to display a file extension or not.
         * @summary Display a file extension
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayFileExtension(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.displayFileExtension(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to share a file externally.
         * @summary Change the external sharing ability
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalShare(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.externalShare(displayRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to share a file externally on social networks.
         * @summary Change the external sharing ability on social networks
         * @param {DisplayRequestDto} [displayRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalShareSocialMedia(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.externalShareSocialMedia(displayRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to force save a file.
         * @summary Change the forcasaving ability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forcesave(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.forcesave(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the trash bin auto-clearing setting.
         * @summary Get the trash bin auto-clearing setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomaticallyCleanUp(options?: RawAxiosRequestConfig): AxiosPromise<AutoCleanUpDataWrapper> {
            return localVarFp.getAutomaticallyCleanUp(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the information about the Documents module.
         * @summary Get the Documents information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesModule(options?: RawAxiosRequestConfig): AxiosPromise<ModuleWrapper> {
            return localVarFp.getFilesModule(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the file settings.
         * @summary Get file settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilesSettings(options?: RawAxiosRequestConfig): AxiosPromise<FilesSettingsWrapper> {
            return localVarFp.getFilesSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Hide confirmation dialog when canceling operation.
         * @summary Hide confirmation dialog when canceling operation
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmCancelOperation(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.hideConfirmCancelOperation(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Hides the confirmation dialog for saving the file copy in the original format when converting a file.
         * @summary Hide the confirmation dialog when converting
         * @param {HideConfirmConvertRequestDto} [hideConfirmConvertRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmConvert(hideConfirmConvertRequestDto?: HideConfirmConvertRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ModuleWrapper> {
            return localVarFp.hideConfirmConvert(hideConfirmConvertRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Hide confirmation dialog when changing room lifetime settings.
         * @summary Hide confirmation dialog when changing room lifetime settings
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideConfirmRoomLifetime(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.hideConfirmRoomLifetime(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the Private Room settings are available or not.
         * @summary Check the Private Room availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAvailablePrivacyRoomSettings(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.isAvailablePrivacyRoomSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies whether to ask a user for a file name on creation or not.
         * @summary Ask a new file name
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keepNewFileName(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.keepNewFileName(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the ability to open in a document in the same browser tab
         * @summary Open document in same browser tab
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOpenEditorInSameTab(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.setOpenEditorInSameTab(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to store the forcesaved file versions.
         * @summary Change the ability to store the forcesaved files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeForcesave(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.storeForcesave(options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the ability to upload documents in the original formats as well.
         * @summary Change the ability to upload original formats
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOriginal(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.storeOriginal(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a file version if a file with such a name already exists.
         * @summary Update a file version if it exists
         * @param {SettingsRequestDto} [settingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIfExist(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.updateIfExist(settingsRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesSettingsApi - object-oriented interface
 * @export
 * @class FilesSettingsApi
 * @extends {BaseAPI}
 */
export class FilesSettingsApi extends BaseAPI {
    /**
     * Changes the access to the third-party settings.
     * @summary Change the third-party settings access
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeAccessToThirdparty(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeAccessToThirdparty(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the trash bin auto-clearing setting.
     * @summary Update the trash bin auto-clearing setting
     * @param {AutoCleanupRequestDto} [autoCleanupRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeAutomaticallyCleanUp(autoCleanupRequestDto?: AutoCleanupRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeAutomaticallyCleanUp(autoCleanupRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the default access rights in the sharing settings.
     * @summary Change the default access rights
     * @param {Array<FileShare>} [fileShare] Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeDefaultAccessRights(fileShare?: Array<FileShare>, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeDefaultAccessRights(fileShare, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies whether to confirm the file deletion or not.
     * @summary Confirm the file deletion
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeDeleteConfirm(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeDeleteConfirm(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the format of the downloaded archive from .zip to .tar.gz. This method uses the body parameters.
     * @summary Change the archive format (using body parameters)
     * @param {DisplayRequestDto} [displayRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public changeDownloadZipFromBody(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).changeDownloadZipFromBody(displayRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks the document service location.
     * @summary Check the document service URL
     * @param {CheckDocServiceUrlRequestDto} [checkDocServiceUrlRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public checkDocServiceUrl(checkDocServiceUrlRequestDto?: CheckDocServiceUrlRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).checkDocServiceUrl(checkDocServiceUrlRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies whether to display a file extension or not.
     * @summary Display a file extension
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public displayFileExtension(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).displayFileExtension(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to share a file externally.
     * @summary Change the external sharing ability
     * @param {DisplayRequestDto} [displayRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public externalShare(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).externalShare(displayRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to share a file externally on social networks.
     * @summary Change the external sharing ability on social networks
     * @param {DisplayRequestDto} [displayRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public externalShareSocialMedia(displayRequestDto?: DisplayRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).externalShareSocialMedia(displayRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to force save a file.
     * @summary Change the forcasaving ability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public forcesave(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).forcesave(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the trash bin auto-clearing setting.
     * @summary Get the trash bin auto-clearing setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public getAutomaticallyCleanUp(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).getAutomaticallyCleanUp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the information about the Documents module.
     * @summary Get the Documents information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public getFilesModule(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).getFilesModule(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the file settings.
     * @summary Get file settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public getFilesSettings(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).getFilesSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hide confirmation dialog when canceling operation.
     * @summary Hide confirmation dialog when canceling operation
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public hideConfirmCancelOperation(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).hideConfirmCancelOperation(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hides the confirmation dialog for saving the file copy in the original format when converting a file.
     * @summary Hide the confirmation dialog when converting
     * @param {HideConfirmConvertRequestDto} [hideConfirmConvertRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public hideConfirmConvert(hideConfirmConvertRequestDto?: HideConfirmConvertRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).hideConfirmConvert(hideConfirmConvertRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hide confirmation dialog when changing room lifetime settings.
     * @summary Hide confirmation dialog when changing room lifetime settings
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public hideConfirmRoomLifetime(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).hideConfirmRoomLifetime(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the Private Room settings are available or not.
     * @summary Check the Private Room availability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public isAvailablePrivacyRoomSettings(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).isAvailablePrivacyRoomSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies whether to ask a user for a file name on creation or not.
     * @summary Ask a new file name
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public keepNewFileName(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).keepNewFileName(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the ability to open in a document in the same browser tab
     * @summary Open document in same browser tab
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public setOpenEditorInSameTab(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).setOpenEditorInSameTab(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to store the forcesaved file versions.
     * @summary Change the ability to store the forcesaved files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public storeForcesave(options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).storeForcesave(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the ability to upload documents in the original formats as well.
     * @summary Change the ability to upload original formats
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public storeOriginal(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).storeOriginal(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a file version if a file with such a name already exists.
     * @summary Update a file version if it exists
     * @param {SettingsRequestDto} [settingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesSettingsApi
     */
    public updateIfExist(settingsRequestDto?: SettingsRequestDto, options?: RawAxiosRequestConfig) {
        return FilesSettingsApiFp(this.configuration).updateIfExist(settingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesThirdPartyIntegrationApi - axios parameter creator
 * @export
 */
export const FilesThirdPartyIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of the available providers.   **Note**: Available provider keys: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive.
         * @summary Get providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capabilities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty/capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the third-party storage service account with the ID specified in the request.
         * @summary Remove a third-party account
         * @param {number} providerId Provider ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThirdParty: async (providerId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('deleteThirdParty', 'providerId', providerId)
            const localVarPath = `/api/2.0/files/thirdparty/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the all providers.   **Note**: Available provider keys: Dropbox, Box, WebDav, OneDrive, GoogleDrive, kDrive, ownCloud, Nextcloud
         * @summary Get all providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a backup of the connected third-party account.
         * @summary Get a third-party account backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupThirdPartyAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the third-party services connected to the \"Common\" section.
         * @summary Get common third-party services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommonThirdPartyFolders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty/common`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the connected third-party accounts.
         * @summary Get third-party accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThirdPartyAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the third-party storage service account. For WebDav, Yandex, kDrive and SharePoint, the login and password are used for authentication. For other providers, the authentication is performed using a token received via OAuth 2.0.   **Note**: List of provider keys: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive.
         * @summary Save a third-party account
         * @param {ThirdPartyRequestDto} [thirdPartyRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveThirdParty: async (thirdPartyRequestDto?: ThirdPartyRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thirdPartyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves a backup of the connected third-party account.   **Note**: List of provider key: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive
         * @summary Save a third-party account backup
         * @param {ThirdPartyBackupRequestDto} [thirdPartyBackupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveThirdPartyBackup: async (thirdPartyBackupRequestDto?: ThirdPartyBackupRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/files/thirdparty/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thirdPartyBackupRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesThirdPartyIntegrationApi - functional programming interface
 * @export
 */
export const FilesThirdPartyIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesThirdPartyIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of the available providers.   **Note**: Available provider keys: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive.
         * @summary Get providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capabilities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capabilities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesThirdPartyIntegrationApi.capabilities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the third-party storage service account with the ID specified in the request.
         * @summary Remove a third-party account
         * @param {number} providerId Provider ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteThirdParty(providerId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThirdParty(providerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesThirdPartyIntegrationApi.deleteThirdParty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the all providers.   **Note**: Available provider keys: Dropbox, Box, WebDav, OneDrive, GoogleDrive, kDrive, ownCloud, Nextcloud
         * @summary Get all providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesThirdPartyIntegrationApi.getAllProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a backup of the connected third-party account.
         * @summary Get a third-party account backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupThirdPartyAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderStringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupThirdPartyAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesThirdPartyIntegrationApi.getBackupThirdPartyAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the third-party services connected to the \"Common\" section.
         * @summary Get common third-party services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommonThirdPartyFolders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderStringArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommonThirdPartyFolders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesThirdPartyIntegrationApi.getCommonThirdPartyFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the connected third-party accounts.
         * @summary Get third-party accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThirdPartyAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThirdPartyParamsArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThirdPartyAccounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesThirdPartyIntegrationApi.getThirdPartyAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the third-party storage service account. For WebDav, Yandex, kDrive and SharePoint, the login and password are used for authentication. For other providers, the authentication is performed using a token received via OAuth 2.0.   **Note**: List of provider keys: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive.
         * @summary Save a third-party account
         * @param {ThirdPartyRequestDto} [thirdPartyRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveThirdParty(thirdPartyRequestDto?: ThirdPartyRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderStringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveThirdParty(thirdPartyRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesThirdPartyIntegrationApi.saveThirdParty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves a backup of the connected third-party account.   **Note**: List of provider key: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive
         * @summary Save a third-party account backup
         * @param {ThirdPartyBackupRequestDto} [thirdPartyBackupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveThirdPartyBackup(thirdPartyBackupRequestDto?: ThirdPartyBackupRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderStringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveThirdPartyBackup(thirdPartyBackupRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesThirdPartyIntegrationApi.saveThirdPartyBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesThirdPartyIntegrationApi - factory interface
 * @export
 */
export const FilesThirdPartyIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesThirdPartyIntegrationApiFp(configuration)
    return {
        /**
         * Returns a list of the available providers.   **Note**: Available provider keys: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive.
         * @summary Get providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capabilities(options?: RawAxiosRequestConfig): AxiosPromise<ArrayArrayWrapper> {
            return localVarFp.capabilities(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the third-party storage service account with the ID specified in the request.
         * @summary Remove a third-party account
         * @param {number} providerId Provider ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThirdParty(providerId: number, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.deleteThirdParty(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the all providers.   **Note**: Available provider keys: Dropbox, Box, WebDav, OneDrive, GoogleDrive, kDrive, ownCloud, Nextcloud
         * @summary Get all providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProviders(options?: RawAxiosRequestConfig): AxiosPromise<ProviderArrayWrapper> {
            return localVarFp.getAllProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a backup of the connected third-party account.
         * @summary Get a third-party account backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupThirdPartyAccount(options?: RawAxiosRequestConfig): AxiosPromise<FolderStringWrapper> {
            return localVarFp.getBackupThirdPartyAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the third-party services connected to the \"Common\" section.
         * @summary Get common third-party services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommonThirdPartyFolders(options?: RawAxiosRequestConfig): AxiosPromise<FolderStringArrayWrapper> {
            return localVarFp.getCommonThirdPartyFolders(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the connected third-party accounts.
         * @summary Get third-party accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThirdPartyAccounts(options?: RawAxiosRequestConfig): AxiosPromise<ThirdPartyParamsArrayWrapper> {
            return localVarFp.getThirdPartyAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the third-party storage service account. For WebDav, Yandex, kDrive and SharePoint, the login and password are used for authentication. For other providers, the authentication is performed using a token received via OAuth 2.0.   **Note**: List of provider keys: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive.
         * @summary Save a third-party account
         * @param {ThirdPartyRequestDto} [thirdPartyRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveThirdParty(thirdPartyRequestDto?: ThirdPartyRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FolderStringWrapper> {
            return localVarFp.saveThirdParty(thirdPartyRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves a backup of the connected third-party account.   **Note**: List of provider key: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive
         * @summary Save a third-party account backup
         * @param {ThirdPartyBackupRequestDto} [thirdPartyBackupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveThirdPartyBackup(thirdPartyBackupRequestDto?: ThirdPartyBackupRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<FolderStringWrapper> {
            return localVarFp.saveThirdPartyBackup(thirdPartyBackupRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesThirdPartyIntegrationApi - object-oriented interface
 * @export
 * @class FilesThirdPartyIntegrationApi
 * @extends {BaseAPI}
 */
export class FilesThirdPartyIntegrationApi extends BaseAPI {
    /**
     * Returns a list of the available providers.   **Note**: Available provider keys: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive.
     * @summary Get providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesThirdPartyIntegrationApi
     */
    public capabilities(options?: RawAxiosRequestConfig) {
        return FilesThirdPartyIntegrationApiFp(this.configuration).capabilities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the third-party storage service account with the ID specified in the request.
     * @summary Remove a third-party account
     * @param {number} providerId Provider ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesThirdPartyIntegrationApi
     */
    public deleteThirdParty(providerId: number, options?: RawAxiosRequestConfig) {
        return FilesThirdPartyIntegrationApiFp(this.configuration).deleteThirdParty(providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the all providers.   **Note**: Available provider keys: Dropbox, Box, WebDav, OneDrive, GoogleDrive, kDrive, ownCloud, Nextcloud
     * @summary Get all providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesThirdPartyIntegrationApi
     */
    public getAllProviders(options?: RawAxiosRequestConfig) {
        return FilesThirdPartyIntegrationApiFp(this.configuration).getAllProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a backup of the connected third-party account.
     * @summary Get a third-party account backup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesThirdPartyIntegrationApi
     */
    public getBackupThirdPartyAccount(options?: RawAxiosRequestConfig) {
        return FilesThirdPartyIntegrationApiFp(this.configuration).getBackupThirdPartyAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the third-party services connected to the \"Common\" section.
     * @summary Get common third-party services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesThirdPartyIntegrationApi
     */
    public getCommonThirdPartyFolders(options?: RawAxiosRequestConfig) {
        return FilesThirdPartyIntegrationApiFp(this.configuration).getCommonThirdPartyFolders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the connected third-party accounts.
     * @summary Get third-party accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesThirdPartyIntegrationApi
     */
    public getThirdPartyAccounts(options?: RawAxiosRequestConfig) {
        return FilesThirdPartyIntegrationApiFp(this.configuration).getThirdPartyAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the third-party storage service account. For WebDav, Yandex, kDrive and SharePoint, the login and password are used for authentication. For other providers, the authentication is performed using a token received via OAuth 2.0.   **Note**: List of provider keys: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive.
     * @summary Save a third-party account
     * @param {ThirdPartyRequestDto} [thirdPartyRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesThirdPartyIntegrationApi
     */
    public saveThirdParty(thirdPartyRequestDto?: ThirdPartyRequestDto, options?: RawAxiosRequestConfig) {
        return FilesThirdPartyIntegrationApiFp(this.configuration).saveThirdParty(thirdPartyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves a backup of the connected third-party account.   **Note**: List of provider key: DropboxV2, Box, WebDav, Yandex, OneDrive, SharePoint, GoogleDrive, kDrive
     * @summary Save a third-party account backup
     * @param {ThirdPartyBackupRequestDto} [thirdPartyBackupRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesThirdPartyIntegrationApi
     */
    public saveThirdPartyBackup(thirdPartyBackupRequestDto?: ThirdPartyBackupRequestDto, options?: RawAxiosRequestConfig) {
        return FilesThirdPartyIntegrationApiFp(this.configuration).saveThirdPartyBackup(thirdPartyBackupRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new group with the group manager, name, and members specified in the request.
         * @summary Add a new group
         * @param {GroupRequestDto} [groupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroup: async (groupRequestDto?: GroupRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds new group members to the group with the ID specified in the request.
         * @summary Add group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMembersTo: async (id: string, membersRequest?: MembersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addMembersTo', 'id', id)
            const localVarPath = `/api/2.0/group/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a group with the ID specified in the request from the list of groups on the portal.
         * @summary Delete a group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/api/2.0/group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of groups for the user with the ID specified in the request.
         * @summary Get user groups
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId: async (userid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getByUserId', 'userid', userid)
            const localVarPath = `/api/2.0/group/user/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about the selected group.   **Note**: This method returns full group information.
         * @summary Get a group
         * @param {string} id Group ID
         * @param {boolean} [includeMembers] Include members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (id: string, includeMembers?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroup', 'id', id)
            const localVarPath = `/api/2.0/group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (includeMembers !== undefined) {
                localVarQueryParameter['includeMembers'] = includeMembers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the general information about all the groups, such as group ID and group manager.   **Note**: This method returns partial group information.
         * @summary Get groups
         * @param {string} [userId] User ID
         * @param {boolean} [manager] Specifies if the user is a manager or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: async (userId?: string, manager?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (manager !== undefined) {
                localVarQueryParameter['manager'] = manager;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the group members specified in the request from the selected group.
         * @summary Remove group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMembersFrom: async (id: string, membersRequest?: MembersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeMembersFrom', 'id', id)
            const localVarPath = `/api/2.0/group/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a user with the ID specified in the request as a group manager.
         * @summary Set a group manager
         * @param {string} id Group ID
         * @param {SetManagerRequest} [setManagerRequest] Set manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setManager: async (id: string, setManagerRequest?: SetManagerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setManager', 'id', id)
            const localVarPath = `/api/2.0/group/{id}/manager`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setManagerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the group members with those specified in the request.
         * @summary Replace group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMembersTo: async (id: string, membersRequest?: MembersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setMembersTo', 'id', id)
            const localVarPath = `/api/2.0/group/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves all the members from the selected group to another one specified in the request.
         * @summary Move group members
         * @param {string} fromId Group ID to move from
         * @param {string} toId Group ID to move to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferMembersTo: async (fromId: string, toId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromId' is not null or undefined
            assertParamExists('transferMembersTo', 'fromId', fromId)
            // verify required parameter 'toId' is not null or undefined
            assertParamExists('transferMembersTo', 'toId', toId)
            const localVarPath = `/api/2.0/group/{fromId}/members/{toId}`
                .replace(`{${"fromId"}}`, encodeURIComponent(String(fromId)))
                .replace(`{${"toId"}}`, encodeURIComponent(String(toId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the existing group changing the group manager, name, and/or members.
         * @summary Update a group
         * @param {string} id Group ID
         * @param {UpdateGroupRequest} [updateGroupRequest] Update group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (id: string, updateGroupRequest?: UpdateGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroup', 'id', id)
            const localVarPath = `/api/2.0/group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new group with the group manager, name, and members specified in the request.
         * @summary Add a new group
         * @param {GroupRequestDto} [groupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroup(groupRequestDto?: GroupRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroup(groupRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.addGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds new group members to the group with the ID specified in the request.
         * @summary Add group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMembersTo(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMembersTo(id, membersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.addMembersTo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a group with the ID specified in the request from the list of groups on the portal.
         * @summary Delete a group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NoContentResultWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of groups for the user with the ID specified in the request.
         * @summary Get user groups
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUserId(userid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSummaryArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUserId(userid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about the selected group.   **Note**: This method returns full group information.
         * @summary Get a group
         * @param {string} id Group ID
         * @param {boolean} [includeMembers] Include members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(id: string, includeMembers?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(id, includeMembers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the general information about all the groups, such as group ID and group manager.   **Note**: This method returns partial group information.
         * @summary Get groups
         * @param {string} [userId] User ID
         * @param {boolean} [manager] Specifies if the user is a manager or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroups(userId?: string, manager?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(userId, manager, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the group members specified in the request from the selected group.
         * @summary Remove group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMembersFrom(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMembersFrom(id, membersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.removeMembersFrom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets a user with the ID specified in the request as a group manager.
         * @summary Set a group manager
         * @param {string} id Group ID
         * @param {SetManagerRequest} [setManagerRequest] Set manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setManager(id: string, setManagerRequest?: SetManagerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setManager(id, setManagerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.setManager']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the group members with those specified in the request.
         * @summary Replace group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMembersTo(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMembersTo(id, membersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.setMembersTo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Moves all the members from the selected group to another one specified in the request.
         * @summary Move group members
         * @param {string} fromId Group ID to move from
         * @param {string} toId Group ID to move to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferMembersTo(fromId: string, toId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferMembersTo(fromId, toId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.transferMembersTo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the existing group changing the group manager, name, and/or members.
         * @summary Update a group
         * @param {string} id Group ID
         * @param {UpdateGroupRequest} [updateGroupRequest] Update group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(id: string, updateGroupRequest?: UpdateGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(id, updateGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.updateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * Adds a new group with the group manager, name, and members specified in the request.
         * @summary Add a new group
         * @param {GroupRequestDto} [groupRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroup(groupRequestDto?: GroupRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<GroupWrapper> {
            return localVarFp.addGroup(groupRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds new group members to the group with the ID specified in the request.
         * @summary Add group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMembersTo(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupWrapper> {
            return localVarFp.addMembersTo(id, membersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a group with the ID specified in the request from the list of groups on the portal.
         * @summary Delete a group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NoContentResultWrapper> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of groups for the user with the ID specified in the request.
         * @summary Get user groups
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId(userid: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupSummaryArrayWrapper> {
            return localVarFp.getByUserId(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about the selected group.   **Note**: This method returns full group information.
         * @summary Get a group
         * @param {string} id Group ID
         * @param {boolean} [includeMembers] Include members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(id: string, includeMembers?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GroupWrapper> {
            return localVarFp.getGroup(id, includeMembers, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the general information about all the groups, such as group ID and group manager.   **Note**: This method returns partial group information.
         * @summary Get groups
         * @param {string} [userId] User ID
         * @param {boolean} [manager] Specifies if the user is a manager or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(userId?: string, manager?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GroupArrayWrapper> {
            return localVarFp.getGroups(userId, manager, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the group members specified in the request from the selected group.
         * @summary Remove group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMembersFrom(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupWrapper> {
            return localVarFp.removeMembersFrom(id, membersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a user with the ID specified in the request as a group manager.
         * @summary Set a group manager
         * @param {string} id Group ID
         * @param {SetManagerRequest} [setManagerRequest] Set manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setManager(id: string, setManagerRequest?: SetManagerRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupWrapper> {
            return localVarFp.setManager(id, setManagerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the group members with those specified in the request.
         * @summary Replace group members
         * @param {string} id Group ID
         * @param {MembersRequest} [membersRequest] Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMembersTo(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupWrapper> {
            return localVarFp.setMembersTo(id, membersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves all the members from the selected group to another one specified in the request.
         * @summary Move group members
         * @param {string} fromId Group ID to move from
         * @param {string} toId Group ID to move to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferMembersTo(fromId: string, toId: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupWrapper> {
            return localVarFp.transferMembersTo(fromId, toId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the existing group changing the group manager, name, and/or members.
         * @summary Update a group
         * @param {string} id Group ID
         * @param {UpdateGroupRequest} [updateGroupRequest] Update group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(id: string, updateGroupRequest?: UpdateGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupWrapper> {
            return localVarFp.updateGroup(id, updateGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * Adds a new group with the group manager, name, and members specified in the request.
     * @summary Add a new group
     * @param {GroupRequestDto} [groupRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addGroup(groupRequestDto?: GroupRequestDto, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).addGroup(groupRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds new group members to the group with the ID specified in the request.
     * @summary Add group members
     * @param {string} id Group ID
     * @param {MembersRequest} [membersRequest] Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addMembersTo(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).addMembersTo(id, membersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a group with the ID specified in the request from the list of groups on the portal.
     * @summary Delete a group
     * @param {string} id Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(id: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of groups for the user with the ID specified in the request.
     * @summary Get user groups
     * @param {string} userid User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getByUserId(userid: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getByUserId(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about the selected group.   **Note**: This method returns full group information.
     * @summary Get a group
     * @param {string} id Group ID
     * @param {boolean} [includeMembers] Include members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(id: string, includeMembers?: boolean, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(id, includeMembers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the general information about all the groups, such as group ID and group manager.   **Note**: This method returns partial group information.
     * @summary Get groups
     * @param {string} [userId] User ID
     * @param {boolean} [manager] Specifies if the user is a manager or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroups(userId?: string, manager?: boolean, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroups(userId, manager, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the group members specified in the request from the selected group.
     * @summary Remove group members
     * @param {string} id Group ID
     * @param {MembersRequest} [membersRequest] Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public removeMembersFrom(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).removeMembersFrom(id, membersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a user with the ID specified in the request as a group manager.
     * @summary Set a group manager
     * @param {string} id Group ID
     * @param {SetManagerRequest} [setManagerRequest] Set manager
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public setManager(id: string, setManagerRequest?: SetManagerRequest, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).setManager(id, setManagerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the group members with those specified in the request.
     * @summary Replace group members
     * @param {string} id Group ID
     * @param {MembersRequest} [membersRequest] Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public setMembersTo(id: string, membersRequest?: MembersRequest, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).setMembersTo(id, membersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moves all the members from the selected group to another one specified in the request.
     * @summary Move group members
     * @param {string} fromId Group ID to move from
     * @param {string} toId Group ID to move to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public transferMembersTo(fromId: string, toId: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).transferMembersTo(fromId, toId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the existing group changing the group manager, name, and/or members.
     * @summary Update a group
     * @param {string} id Group ID
     * @param {UpdateGroupRequest} [updateGroupRequest] Update group parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(id: string, updateGroupRequest?: UpdateGroupRequest, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).updateGroup(id, updateGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupRoomsApi - axios parameter creator
 * @export
 */
export const GroupRoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets groups with shared
         * @summary Gets groups with shared
         * @param {number} id ID
         * @param {boolean} [excludeShared] Exclude shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsWithShared: async (id: number, excludeShared?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupsWithShared', 'id', id)
            const localVarPath = `/api/2.0/group/room/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (excludeShared !== undefined) {
                localVarQueryParameter['excludeShared'] = excludeShared;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupRoomsApi - functional programming interface
 * @export
 */
export const GroupRoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupRoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets groups with shared
         * @summary Gets groups with shared
         * @param {number} id ID
         * @param {boolean} [excludeShared] Exclude shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsWithShared(id: number, excludeShared?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsWithShared(id, excludeShared, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupRoomsApi.getGroupsWithShared']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupRoomsApi - factory interface
 * @export
 */
export const GroupRoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupRoomsApiFp(configuration)
    return {
        /**
         * Gets groups with shared
         * @summary Gets groups with shared
         * @param {number} id ID
         * @param {boolean} [excludeShared] Exclude shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsWithShared(id: number, excludeShared?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GroupArrayWrapper> {
            return localVarFp.getGroupsWithShared(id, excludeShared, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupRoomsApi - object-oriented interface
 * @export
 * @class GroupRoomsApi
 * @extends {BaseAPI}
 */
export class GroupRoomsApi extends BaseAPI {
    /**
     * Gets groups with shared
     * @summary Gets groups with shared
     * @param {number} id ID
     * @param {boolean} [excludeShared] Exclude shared
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRoomsApi
     */
    public getGroupsWithShared(id: number, excludeShared?: boolean, options?: RawAxiosRequestConfig) {
        return GroupRoomsApiFp(this.configuration).getGroupsWithShared(id, excludeShared, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MigrationApi - axios parameter creator
 * @export
 */
export const MigrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels migration
         * @summary Cancels migration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/migration/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clears migration
         * @summary Clears migration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clear: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/migration/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finishes migration
         * @summary Finishes migration
         * @param {FinishDto} [finishDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finish: async (finishDto?: FinishDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/migration/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finishDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets migration list
         * @summary Gets migration list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/migration/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets migration logs
         * @summary Gets migration logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/migration/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Migrates
         * @summary Migrates
         * @param {MigrationApiInfo} [migrationApiInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrate: async (migrationApiInfo?: MigrationApiInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/migration/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(migrationApiInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets migration status
         * @summary Gets migration status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/migration/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads and inits migration
         * @summary Uploads and inits migration
         * @param {string} migratorName Migrator name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAndInit: async (migratorName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'migratorName' is not null or undefined
            assertParamExists('uploadAndInit', 'migratorName', migratorName)
            const localVarPath = `/api/2.0/migration/init/{migratorName}`
                .replace(`{${"migratorName"}}`, encodeURIComponent(String(migratorName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MigrationApi - functional programming interface
 * @export
 */
export const MigrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MigrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels migration
         * @summary Cancels migration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clears migration
         * @summary Clears migration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clear(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clear(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationApi.clear']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finishes migration
         * @summary Finishes migration
         * @param {FinishDto} [finishDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finish(finishDto?: FinishDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finish(finishDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationApi.finish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets migration list
         * @summary Gets migration list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<STRINGArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets migration logs
         * @summary Gets migration logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationApi.logs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Migrates
         * @summary Migrates
         * @param {MigrationApiInfo} [migrationApiInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async migrate(migrationApiInfo?: MigrationApiInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.migrate(migrationApiInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationApi.migrate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets migration status
         * @summary Gets migration status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async status(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MigrationStatusWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.status(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationApi.status']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads and inits migration
         * @summary Uploads and inits migration
         * @param {string} migratorName Migrator name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAndInit(migratorName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAndInit(migratorName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationApi.uploadAndInit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MigrationApi - factory interface
 * @export
 */
export const MigrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MigrationApiFp(configuration)
    return {
        /**
         * Cancels migration
         * @summary Cancels migration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancel(options).then((request) => request(axios, basePath));
        },
        /**
         * Clears migration
         * @summary Clears migration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clear(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clear(options).then((request) => request(axios, basePath));
        },
        /**
         * Finishes migration
         * @summary Finishes migration
         * @param {FinishDto} [finishDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finish(finishDto?: FinishDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.finish(finishDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets migration list
         * @summary Gets migration list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: RawAxiosRequestConfig): AxiosPromise<STRINGArrayWrapper> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets migration logs
         * @summary Gets migration logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logs(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logs(options).then((request) => request(axios, basePath));
        },
        /**
         * Migrates
         * @summary Migrates
         * @param {MigrationApiInfo} [migrationApiInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrate(migrationApiInfo?: MigrationApiInfo, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.migrate(migrationApiInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets migration status
         * @summary Gets migration status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status(options?: RawAxiosRequestConfig): AxiosPromise<MigrationStatusWrapper> {
            return localVarFp.status(options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads and inits migration
         * @summary Uploads and inits migration
         * @param {string} migratorName Migrator name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAndInit(migratorName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadAndInit(migratorName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MigrationApi - object-oriented interface
 * @export
 * @class MigrationApi
 * @extends {BaseAPI}
 */
export class MigrationApi extends BaseAPI {
    /**
     * Cancels migration
     * @summary Cancels migration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationApi
     */
    public cancel(options?: RawAxiosRequestConfig) {
        return MigrationApiFp(this.configuration).cancel(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clears migration
     * @summary Clears migration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationApi
     */
    public clear(options?: RawAxiosRequestConfig) {
        return MigrationApiFp(this.configuration).clear(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finishes migration
     * @summary Finishes migration
     * @param {FinishDto} [finishDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationApi
     */
    public finish(finishDto?: FinishDto, options?: RawAxiosRequestConfig) {
        return MigrationApiFp(this.configuration).finish(finishDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets migration list
     * @summary Gets migration list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationApi
     */
    public list(options?: RawAxiosRequestConfig) {
        return MigrationApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets migration logs
     * @summary Gets migration logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationApi
     */
    public logs(options?: RawAxiosRequestConfig) {
        return MigrationApiFp(this.configuration).logs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Migrates
     * @summary Migrates
     * @param {MigrationApiInfo} [migrationApiInfo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationApi
     */
    public migrate(migrationApiInfo?: MigrationApiInfo, options?: RawAxiosRequestConfig) {
        return MigrationApiFp(this.configuration).migrate(migrationApiInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets migration status
     * @summary Gets migration status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationApi
     */
    public status(options?: RawAxiosRequestConfig) {
        return MigrationApiFp(this.configuration).status(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads and inits migration
     * @summary Uploads and inits migration
     * @param {string} migratorName Migrator name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationApi
     */
    public uploadAndInit(migratorName: string, options?: RawAxiosRequestConfig) {
        return MigrationApiFp(this.configuration).uploadAndInit(migratorName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModulesApi - axios parameter creator
 * @export
 */
export const ModulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all the portal modules.
         * @summary Get modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPortalModules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/modules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the portal modules with their information.
         * @summary Get modules information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWithInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/modules/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModulesApi - functional programming interface
 * @export
 */
export const ModulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all the portal modules.
         * @summary Get modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPortalModules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<STRINGArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPortalModules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModulesApi.getAllPortalModules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the portal modules with their information.
         * @summary Get modules information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWithInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWithInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModulesApi.getAllWithInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModulesApi - factory interface
 * @export
 */
export const ModulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModulesApiFp(configuration)
    return {
        /**
         * Returns a list of all the portal modules.
         * @summary Get modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPortalModules(options?: RawAxiosRequestConfig): AxiosPromise<STRINGArrayWrapper> {
            return localVarFp.getAllPortalModules(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the portal modules with their information.
         * @summary Get modules information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWithInfo(options?: RawAxiosRequestConfig): AxiosPromise<ModuleArrayWrapper> {
            return localVarFp.getAllWithInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModulesApi - object-oriented interface
 * @export
 * @class ModulesApi
 * @extends {BaseAPI}
 */
export class ModulesApi extends BaseAPI {
    /**
     * Returns a list of all the portal modules.
     * @summary Get modules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApi
     */
    public getAllPortalModules(options?: RawAxiosRequestConfig) {
        return ModulesApiFp(this.configuration).getAllPortalModules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the portal modules with their information.
     * @summary Get modules information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApi
     */
    public getAllWithInfo(options?: RawAxiosRequestConfig) {
        return ModulesApiFp(this.configuration).getAllWithInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleContactsApi - axios parameter creator
 * @export
 */
export const PeopleContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the contacts of the user with the ID specified in the request from the portal.
         * @summary Delete user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberContacts: async (userid: string, contactsRequest?: ContactsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('deleteMemberContacts', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/contacts`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the contacts of the user with the ID specified in the request replacing the current portal data with the new data.
         * @summary Set user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMemberContacts: async (userid: string, contactsRequest?: ContactsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('setMemberContacts', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/contacts`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the contact information of the user with the ID specified in the request merging the new data into the current portal data.
         * @summary Update user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberContacts: async (userid: string, contactsRequest?: ContactsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('updateMemberContacts', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/contacts`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleContactsApi - functional programming interface
 * @export
 */
export const PeopleContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the contacts of the user with the ID specified in the request from the portal.
         * @summary Delete user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMemberContacts(userid, contactsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleContactsApi.deleteMemberContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the contacts of the user with the ID specified in the request replacing the current portal data with the new data.
         * @summary Set user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMemberContacts(userid, contactsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleContactsApi.setMemberContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the contact information of the user with the ID specified in the request merging the new data into the current portal data.
         * @summary Update user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMemberContacts(userid, contactsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleContactsApi.updateMemberContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleContactsApi - factory interface
 * @export
 */
export const PeopleContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleContactsApiFp(configuration)
    return {
        /**
         * Deletes the contacts of the user with the ID specified in the request from the portal.
         * @summary Delete user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.deleteMemberContacts(userid, contactsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the contacts of the user with the ID specified in the request replacing the current portal data with the new data.
         * @summary Set user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.setMemberContacts(userid, contactsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the contact information of the user with the ID specified in the request merging the new data into the current portal data.
         * @summary Update user contacts
         * @param {string} userid User ID
         * @param {ContactsRequest} [contactsRequest] Contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.updateMemberContacts(userid, contactsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleContactsApi - object-oriented interface
 * @export
 * @class PeopleContactsApi
 * @extends {BaseAPI}
 */
export class PeopleContactsApi extends BaseAPI {
    /**
     * Deletes the contacts of the user with the ID specified in the request from the portal.
     * @summary Delete user contacts
     * @param {string} userid User ID
     * @param {ContactsRequest} [contactsRequest] Contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleContactsApi
     */
    public deleteMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig) {
        return PeopleContactsApiFp(this.configuration).deleteMemberContacts(userid, contactsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the contacts of the user with the ID specified in the request replacing the current portal data with the new data.
     * @summary Set user contacts
     * @param {string} userid User ID
     * @param {ContactsRequest} [contactsRequest] Contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleContactsApi
     */
    public setMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig) {
        return PeopleContactsApiFp(this.configuration).setMemberContacts(userid, contactsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the contact information of the user with the ID specified in the request merging the new data into the current portal data.
     * @summary Update user contacts
     * @param {string} userid User ID
     * @param {ContactsRequest} [contactsRequest] Contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleContactsApi
     */
    public updateMemberContacts(userid: string, contactsRequest?: ContactsRequest, options?: RawAxiosRequestConfig) {
        return PeopleContactsApiFp(this.configuration).updateMemberContacts(userid, contactsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleGuestsApi - axios parameter creator
 * @export
 */
export const PeopleGuestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes guests from the list and excludes them from rooms to which you have invited them
         * @summary Removes guests from the list and from rooms
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuests: async (updateMembersRequestDto?: UpdateMembersRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/guests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMembersRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleGuestsApi - functional programming interface
 * @export
 */
export const PeopleGuestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleGuestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes guests from the list and excludes them from rooms to which you have invited them
         * @summary Removes guests from the list and from rooms
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuests(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuests(updateMembersRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleGuestsApi.deleteGuests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleGuestsApi - factory interface
 * @export
 */
export const PeopleGuestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleGuestsApiFp(configuration)
    return {
        /**
         * Removes guests from the list and excludes them from rooms to which you have invited them
         * @summary Removes guests from the list and from rooms
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuests(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGuests(updateMembersRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleGuestsApi - object-oriented interface
 * @export
 * @class PeopleGuestsApi
 * @extends {BaseAPI}
 */
export class PeopleGuestsApi extends BaseAPI {
    /**
     * Removes guests from the list and excludes them from rooms to which you have invited them
     * @summary Removes guests from the list and from rooms
     * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleGuestsApi
     */
    public deleteGuests(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleGuestsApiFp(this.configuration).deleteGuests(updateMembersRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeoplePasswordApi - axios parameter creator
 * @export
 */
export const PeoplePasswordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sets a new password to the user with the ID specified in the request.
         * @summary Change a user password
         * @param {string} userid User ID
         * @param {MemberBaseRequestDto} [memberBaseRequestDto] Member base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword: async (userid: string, memberBaseRequestDto?: MemberBaseRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('changeUserPassword', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/password`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberBaseRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reminds a password to the user using the email address specified in the request.
         * @summary Remind a user password
         * @param {EmailMemberRequestDto} [emailMemberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendUserPassword: async (emailMemberRequestDto?: EmailMemberRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailMemberRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeoplePasswordApi - functional programming interface
 * @export
 */
export const PeoplePasswordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeoplePasswordApiAxiosParamCreator(configuration)
    return {
        /**
         * Sets a new password to the user with the ID specified in the request.
         * @summary Change a user password
         * @param {string} userid User ID
         * @param {MemberBaseRequestDto} [memberBaseRequestDto] Member base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserPassword(userid: string, memberBaseRequestDto?: MemberBaseRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserPassword(userid, memberBaseRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeoplePasswordApi.changeUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reminds a password to the user using the email address specified in the request.
         * @summary Remind a user password
         * @param {EmailMemberRequestDto} [emailMemberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendUserPassword(emailMemberRequestDto?: EmailMemberRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendUserPassword(emailMemberRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeoplePasswordApi.sendUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeoplePasswordApi - factory interface
 * @export
 */
export const PeoplePasswordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeoplePasswordApiFp(configuration)
    return {
        /**
         * Sets a new password to the user with the ID specified in the request.
         * @summary Change a user password
         * @param {string} userid User ID
         * @param {MemberBaseRequestDto} [memberBaseRequestDto] Member base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword(userid: string, memberBaseRequestDto?: MemberBaseRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.changeUserPassword(userid, memberBaseRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Reminds a password to the user using the email address specified in the request.
         * @summary Remind a user password
         * @param {EmailMemberRequestDto} [emailMemberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendUserPassword(emailMemberRequestDto?: EmailMemberRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.sendUserPassword(emailMemberRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeoplePasswordApi - object-oriented interface
 * @export
 * @class PeoplePasswordApi
 * @extends {BaseAPI}
 */
export class PeoplePasswordApi extends BaseAPI {
    /**
     * Sets a new password to the user with the ID specified in the request.
     * @summary Change a user password
     * @param {string} userid User ID
     * @param {MemberBaseRequestDto} [memberBaseRequestDto] Member base
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeoplePasswordApi
     */
    public changeUserPassword(userid: string, memberBaseRequestDto?: MemberBaseRequestDto, options?: RawAxiosRequestConfig) {
        return PeoplePasswordApiFp(this.configuration).changeUserPassword(userid, memberBaseRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reminds a password to the user using the email address specified in the request.
     * @summary Remind a user password
     * @param {EmailMemberRequestDto} [emailMemberRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeoplePasswordApi
     */
    public sendUserPassword(emailMemberRequestDto?: EmailMemberRequestDto, options?: RawAxiosRequestConfig) {
        return PeoplePasswordApiFp(this.configuration).sendUserPassword(emailMemberRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeoplePhotosApi - axios parameter creator
 * @export
 */
export const PeoplePhotosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates photo thumbnails by coordinates of the original image specified in the request.
         * @summary Create photo thumbnails
         * @param {string} userid User ID
         * @param {ThumbnailsRequest} [thumbnailsRequest] Thumbnails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberPhotoThumbnails: async (userid: string, thumbnailsRequest?: ThumbnailsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('createMemberPhotoThumbnails', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/photo/thumbnails`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thumbnailsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a photo of the user with the ID specified in the request.
         * @summary Delete a user photo
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberPhoto: async (userid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('deleteMemberPhoto', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/photo`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a photo of the user with the ID specified in the request.
         * @summary Get a user photo
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberPhoto: async (userid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getMemberPhoto', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/photo`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a photo of the user with the ID specified in the request.
         * @summary Update a user photo
         * @param {string} userid User ID
         * @param {UpdatePhotoMemberRequest} [updatePhotoMemberRequest] Update photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberPhoto: async (userid: string, updatePhotoMemberRequest?: UpdatePhotoMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('updateMemberPhoto', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/photo`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePhotoMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a photo of the user with the ID specified in the request.
         * @summary Upload a user photo
         * @param {string} userid User ID
         * @param {Array<KeyValuePairStringStringValues>} [formCollection] Image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMemberPhoto: async (userid: string, formCollection?: Array<KeyValuePairStringStringValues>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('uploadMemberPhoto', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/photo`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication asc_auth_key required

            if (formCollection) {
                formCollection.forEach((element) => {
                    localVarFormParams.append('formCollection', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeoplePhotosApi - functional programming interface
 * @export
 */
export const PeoplePhotosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeoplePhotosApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates photo thumbnails by coordinates of the original image specified in the request.
         * @summary Create photo thumbnails
         * @param {string} userid User ID
         * @param {ThumbnailsRequest} [thumbnailsRequest] Thumbnails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMemberPhotoThumbnails(userid: string, thumbnailsRequest?: ThumbnailsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbnailsDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMemberPhotoThumbnails(userid, thumbnailsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeoplePhotosApi.createMemberPhotoThumbnails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a photo of the user with the ID specified in the request.
         * @summary Delete a user photo
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMemberPhoto(userid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbnailsDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMemberPhoto(userid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeoplePhotosApi.deleteMemberPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a photo of the user with the ID specified in the request.
         * @summary Get a user photo
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberPhoto(userid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbnailsDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberPhoto(userid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeoplePhotosApi.getMemberPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a photo of the user with the ID specified in the request.
         * @summary Update a user photo
         * @param {string} userid User ID
         * @param {UpdatePhotoMemberRequest} [updatePhotoMemberRequest] Update photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMemberPhoto(userid: string, updatePhotoMemberRequest?: UpdatePhotoMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbnailsDataWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMemberPhoto(userid, updatePhotoMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeoplePhotosApi.updateMemberPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a photo of the user with the ID specified in the request.
         * @summary Upload a user photo
         * @param {string} userid User ID
         * @param {Array<KeyValuePairStringStringValues>} [formCollection] Image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMemberPhoto(userid: string, formCollection?: Array<KeyValuePairStringStringValues>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResultWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMemberPhoto(userid, formCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeoplePhotosApi.uploadMemberPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeoplePhotosApi - factory interface
 * @export
 */
export const PeoplePhotosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeoplePhotosApiFp(configuration)
    return {
        /**
         * Creates photo thumbnails by coordinates of the original image specified in the request.
         * @summary Create photo thumbnails
         * @param {string} userid User ID
         * @param {ThumbnailsRequest} [thumbnailsRequest] Thumbnails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberPhotoThumbnails(userid: string, thumbnailsRequest?: ThumbnailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThumbnailsDataWrapper> {
            return localVarFp.createMemberPhotoThumbnails(userid, thumbnailsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a photo of the user with the ID specified in the request.
         * @summary Delete a user photo
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberPhoto(userid: string, options?: RawAxiosRequestConfig): AxiosPromise<ThumbnailsDataWrapper> {
            return localVarFp.deleteMemberPhoto(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a photo of the user with the ID specified in the request.
         * @summary Get a user photo
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberPhoto(userid: string, options?: RawAxiosRequestConfig): AxiosPromise<ThumbnailsDataWrapper> {
            return localVarFp.getMemberPhoto(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a photo of the user with the ID specified in the request.
         * @summary Update a user photo
         * @param {string} userid User ID
         * @param {UpdatePhotoMemberRequest} [updatePhotoMemberRequest] Update photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberPhoto(userid: string, updatePhotoMemberRequest?: UpdatePhotoMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThumbnailsDataWrapper> {
            return localVarFp.updateMemberPhoto(userid, updatePhotoMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a photo of the user with the ID specified in the request.
         * @summary Upload a user photo
         * @param {string} userid User ID
         * @param {Array<KeyValuePairStringStringValues>} [formCollection] Image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMemberPhoto(userid: string, formCollection?: Array<KeyValuePairStringStringValues>, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResultWrapper> {
            return localVarFp.uploadMemberPhoto(userid, formCollection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeoplePhotosApi - object-oriented interface
 * @export
 * @class PeoplePhotosApi
 * @extends {BaseAPI}
 */
export class PeoplePhotosApi extends BaseAPI {
    /**
     * Creates photo thumbnails by coordinates of the original image specified in the request.
     * @summary Create photo thumbnails
     * @param {string} userid User ID
     * @param {ThumbnailsRequest} [thumbnailsRequest] Thumbnails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeoplePhotosApi
     */
    public createMemberPhotoThumbnails(userid: string, thumbnailsRequest?: ThumbnailsRequest, options?: RawAxiosRequestConfig) {
        return PeoplePhotosApiFp(this.configuration).createMemberPhotoThumbnails(userid, thumbnailsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a photo of the user with the ID specified in the request.
     * @summary Delete a user photo
     * @param {string} userid User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeoplePhotosApi
     */
    public deleteMemberPhoto(userid: string, options?: RawAxiosRequestConfig) {
        return PeoplePhotosApiFp(this.configuration).deleteMemberPhoto(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a photo of the user with the ID specified in the request.
     * @summary Get a user photo
     * @param {string} userid User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeoplePhotosApi
     */
    public getMemberPhoto(userid: string, options?: RawAxiosRequestConfig) {
        return PeoplePhotosApiFp(this.configuration).getMemberPhoto(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a photo of the user with the ID specified in the request.
     * @summary Update a user photo
     * @param {string} userid User ID
     * @param {UpdatePhotoMemberRequest} [updatePhotoMemberRequest] Update photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeoplePhotosApi
     */
    public updateMemberPhoto(userid: string, updatePhotoMemberRequest?: UpdatePhotoMemberRequest, options?: RawAxiosRequestConfig) {
        return PeoplePhotosApiFp(this.configuration).updateMemberPhoto(userid, updatePhotoMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a photo of the user with the ID specified in the request.
     * @summary Upload a user photo
     * @param {string} userid User ID
     * @param {Array<KeyValuePairStringStringValues>} [formCollection] Image data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeoplePhotosApi
     */
    public uploadMemberPhoto(userid: string, formCollection?: Array<KeyValuePairStringStringValues>, options?: RawAxiosRequestConfig) {
        return PeoplePhotosApiFp(this.configuration).uploadMemberPhoto(userid, formCollection, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleProfilesApi - axios parameter creator
 * @export
 */
export const PeopleProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new portal user with the first name, last name, email address, and several optional parameters specified in the request.
         * @summary Add a user
         * @param {MemberRequestDto} [memberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember: async (memberRequestDto?: MemberRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a user with the ID specified in the request from the portal.
         * @summary Delete a user
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (userid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('deleteMember', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the current user profile.
         * @summary Delete my profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/@self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of profiles for all the portal users.
         * @summary Get profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about a profile of the user with the email specified in the request.
         * @summary Get a profile by user email
         * @param {string} [email] User email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByEmail: async (email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about a profile of the user with the name specified in the request.
         * @summary Get a profile by user name
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (userid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getById', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets claims
         * @summary Gets claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaims: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/tokendiagnostics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites users specified in the request to the current portal.
         * @summary Invite users
         * @param {InviteUsersRequestDto} [inviteUsersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUsers: async (inviteUsersRequestDto?: InviteUsersRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteUsersRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a list of the users with the IDs specified in the request.
         * @summary Delete users
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUsers: async (updateMembersRequestDto?: UpdateMembersRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMembersRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends emails to the users who have not activated their emails.
         * @summary Resend activation emails
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUserInvites: async (updateMembersRequestDto?: UpdateMembersRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMembersRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the detailed information about the current user profile.
         * @summary Get my profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        self: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/@self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a message to the user email with the instructions to change the email address connected to the portal.
         * @summary Send instructions to change email
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailChangeInstructions: async (updateMemberRequestDto?: UpdateMemberRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the data for the selected portal user with the first name, last name, email address, and/or optional parameters specified in the request.
         * @summary Update a user
         * @param {string} userid User ID
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] Update member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember: async (userid: string, updateMemberRequestDto?: UpdateMemberRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('updateMember', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the user language with the parameter specified in the request.
         * @summary Update user language
         * @param {string} userid User ID
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] Update member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberCulture: async (userid: string, updateMemberRequestDto?: UpdateMemberRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('updateMemberCulture', 'userid', userid)
            const localVarPath = `/api/2.0/people/{userid}/culture`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleProfilesApi - functional programming interface
 * @export
 */
export const PeopleProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new portal user with the first name, last name, email address, and several optional parameters specified in the request.
         * @summary Add a user
         * @param {MemberRequestDto} [memberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMember(memberRequestDto?: MemberRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMember(memberRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.addMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a user with the ID specified in the request from the portal.
         * @summary Delete a user
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(userid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(userid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.deleteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the current user profile.
         * @summary Delete my profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.deleteProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of profiles for all the portal users.
         * @summary Get profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.getAllProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about a profile of the user with the email specified in the request.
         * @summary Get a profile by user email
         * @param {string} [email] User email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByEmail(email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.getByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about a profile of the user with the name specified in the request.
         * @summary Get a profile by user name
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(userid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(userid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets claims
         * @summary Gets claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaims(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaims(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.getClaims']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invites users specified in the request to the current portal.
         * @summary Invite users
         * @param {InviteUsersRequestDto} [inviteUsersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUsers(inviteUsersRequestDto?: InviteUsersRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUsers(inviteUsersRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.inviteUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a list of the users with the IDs specified in the request.
         * @summary Delete users
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUsers(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUsers(updateMembersRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.removeUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends emails to the users who have not activated their emails.
         * @summary Resend activation emails
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendUserInvites(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendUserInvites(updateMembersRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.resendUserInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the detailed information about the current user profile.
         * @summary Get my profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async self(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.self(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.self']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a message to the user email with the instructions to change the email address connected to the portal.
         * @summary Send instructions to change email
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmailChangeInstructions(updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmailChangeInstructions(updateMemberRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.sendEmailChangeInstructions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the data for the selected portal user with the first name, last name, email address, and/or optional parameters specified in the request.
         * @summary Update a user
         * @param {string} userid User ID
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] Update member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMember(userid: string, updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMember(userid, updateMemberRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.updateMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the user language with the parameter specified in the request.
         * @summary Update user language
         * @param {string} userid User ID
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] Update member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMemberCulture(userid: string, updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMemberCulture(userid, updateMemberRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleProfilesApi.updateMemberCulture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleProfilesApi - factory interface
 * @export
 */
export const PeopleProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleProfilesApiFp(configuration)
    return {
        /**
         * Adds a new portal user with the first name, last name, email address, and several optional parameters specified in the request.
         * @summary Add a user
         * @param {MemberRequestDto} [memberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember(memberRequestDto?: MemberRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.addMember(memberRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a user with the ID specified in the request from the portal.
         * @summary Delete a user
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(userid: string, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.deleteMember(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the current user profile.
         * @summary Delete my profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.deleteProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of profiles for all the portal users.
         * @summary Get profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProfiles(options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.getAllProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about a profile of the user with the email specified in the request.
         * @summary Get a profile by user email
         * @param {string} [email] User email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByEmail(email?: string, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.getByEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about a profile of the user with the name specified in the request.
         * @summary Get a profile by user name
         * @param {string} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(userid: string, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.getById(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets claims
         * @summary Gets claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaims(options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getClaims(options).then((request) => request(axios, basePath));
        },
        /**
         * Invites users specified in the request to the current portal.
         * @summary Invite users
         * @param {InviteUsersRequestDto} [inviteUsersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUsers(inviteUsersRequestDto?: InviteUsersRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeArrayWrapper> {
            return localVarFp.inviteUsers(inviteUsersRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a list of the users with the IDs specified in the request.
         * @summary Delete users
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUsers(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.removeUsers(updateMembersRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends emails to the users who have not activated their emails.
         * @summary Resend activation emails
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUserInvites(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.resendUserInvites(updateMembersRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the detailed information about the current user profile.
         * @summary Get my profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        self(options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.self(options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a message to the user email with the instructions to change the email address connected to the portal.
         * @summary Send instructions to change email
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailChangeInstructions(updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.sendEmailChangeInstructions(updateMemberRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the data for the selected portal user with the first name, last name, email address, and/or optional parameters specified in the request.
         * @summary Update a user
         * @param {string} userid User ID
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] Update member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember(userid: string, updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.updateMember(userid, updateMemberRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the user language with the parameter specified in the request.
         * @summary Update user language
         * @param {string} userid User ID
         * @param {UpdateMemberRequestDto} [updateMemberRequestDto] Update member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberCulture(userid: string, updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullWrapper> {
            return localVarFp.updateMemberCulture(userid, updateMemberRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleProfilesApi - object-oriented interface
 * @export
 * @class PeopleProfilesApi
 * @extends {BaseAPI}
 */
export class PeopleProfilesApi extends BaseAPI {
    /**
     * Adds a new portal user with the first name, last name, email address, and several optional parameters specified in the request.
     * @summary Add a user
     * @param {MemberRequestDto} [memberRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public addMember(memberRequestDto?: MemberRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).addMember(memberRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a user with the ID specified in the request from the portal.
     * @summary Delete a user
     * @param {string} userid User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public deleteMember(userid: string, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).deleteMember(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the current user profile.
     * @summary Delete my profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public deleteProfile(options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).deleteProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of profiles for all the portal users.
     * @summary Get profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public getAllProfiles(options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).getAllProfiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about a profile of the user with the email specified in the request.
     * @summary Get a profile by user email
     * @param {string} [email] User email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public getByEmail(email?: string, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).getByEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about a profile of the user with the name specified in the request.
     * @summary Get a profile by user name
     * @param {string} userid User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public getById(userid: string, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).getById(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets claims
     * @summary Gets claims
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public getClaims(options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).getClaims(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites users specified in the request to the current portal.
     * @summary Invite users
     * @param {InviteUsersRequestDto} [inviteUsersRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public inviteUsers(inviteUsersRequestDto?: InviteUsersRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).inviteUsers(inviteUsersRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a list of the users with the IDs specified in the request.
     * @summary Delete users
     * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public removeUsers(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).removeUsers(updateMembersRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends emails to the users who have not activated their emails.
     * @summary Resend activation emails
     * @param {UpdateMembersRequestDto} [updateMembersRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public resendUserInvites(updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).resendUserInvites(updateMembersRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the detailed information about the current user profile.
     * @summary Get my profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public self(options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).self(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a message to the user email with the instructions to change the email address connected to the portal.
     * @summary Send instructions to change email
     * @param {UpdateMemberRequestDto} [updateMemberRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public sendEmailChangeInstructions(updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).sendEmailChangeInstructions(updateMemberRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the data for the selected portal user with the first name, last name, email address, and/or optional parameters specified in the request.
     * @summary Update a user
     * @param {string} userid User ID
     * @param {UpdateMemberRequestDto} [updateMemberRequestDto] Update member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public updateMember(userid: string, updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).updateMember(userid, updateMemberRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the user language with the parameter specified in the request.
     * @summary Update user language
     * @param {string} userid User ID
     * @param {UpdateMemberRequestDto} [updateMemberRequestDto] Update member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleProfilesApi
     */
    public updateMemberCulture(userid: string, updateMemberRequestDto?: UpdateMemberRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleProfilesApiFp(this.configuration).updateMemberCulture(userid, updateMemberRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleQuotaApi - axios parameter creator
 * @export
 */
export const PeopleQuotaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resets a user quota limit with the ID specified in the request from the portal.
         * @summary Reset a user quota limit
         * @param {UpdateMembersQuotaRequestDto} [updateMembersQuotaRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUsersQuota: async (updateMembersQuotaRequestDto?: UpdateMembersQuotaRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/resetquota`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMembersQuotaRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a quota limit for the users with the IDs specified in the request.
         * @summary Change a user quota limit
         * @param {UpdateMembersQuotaRequestDto} [updateMembersQuotaRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserQuota: async (updateMembersQuotaRequestDto?: UpdateMembersQuotaRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/userquota`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMembersQuotaRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleQuotaApi - functional programming interface
 * @export
 */
export const PeopleQuotaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleQuotaApiAxiosParamCreator(configuration)
    return {
        /**
         * Resets a user quota limit with the ID specified in the request from the portal.
         * @summary Reset a user quota limit
         * @param {UpdateMembersQuotaRequestDto} [updateMembersQuotaRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUsersQuota(updateMembersQuotaRequestDto?: UpdateMembersQuotaRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUsersQuota(updateMembersQuotaRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleQuotaApi.resetUsersQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes a quota limit for the users with the IDs specified in the request.
         * @summary Change a user quota limit
         * @param {UpdateMembersQuotaRequestDto} [updateMembersQuotaRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserQuota(updateMembersQuotaRequestDto?: UpdateMembersQuotaRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserQuota(updateMembersQuotaRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleQuotaApi.updateUserQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleQuotaApi - factory interface
 * @export
 */
export const PeopleQuotaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleQuotaApiFp(configuration)
    return {
        /**
         * Resets a user quota limit with the ID specified in the request from the portal.
         * @summary Reset a user quota limit
         * @param {UpdateMembersQuotaRequestDto} [updateMembersQuotaRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUsersQuota(updateMembersQuotaRequestDto?: UpdateMembersQuotaRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.resetUsersQuota(updateMembersQuotaRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes a quota limit for the users with the IDs specified in the request.
         * @summary Change a user quota limit
         * @param {UpdateMembersQuotaRequestDto} [updateMembersQuotaRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserQuota(updateMembersQuotaRequestDto?: UpdateMembersQuotaRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.updateUserQuota(updateMembersQuotaRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleQuotaApi - object-oriented interface
 * @export
 * @class PeopleQuotaApi
 * @extends {BaseAPI}
 */
export class PeopleQuotaApi extends BaseAPI {
    /**
     * Resets a user quota limit with the ID specified in the request from the portal.
     * @summary Reset a user quota limit
     * @param {UpdateMembersQuotaRequestDto} [updateMembersQuotaRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleQuotaApi
     */
    public resetUsersQuota(updateMembersQuotaRequestDto?: UpdateMembersQuotaRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleQuotaApiFp(this.configuration).resetUsersQuota(updateMembersQuotaRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes a quota limit for the users with the IDs specified in the request.
     * @summary Change a user quota limit
     * @param {UpdateMembersQuotaRequestDto} [updateMembersQuotaRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleQuotaApi
     */
    public updateUserQuota(updateMembersQuotaRequestDto?: UpdateMembersQuotaRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleQuotaApiFp(this.configuration).updateUserQuota(updateMembersQuotaRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleSearchApi - axios parameter creator
 * @export
 */
export const PeopleSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts entries with shared
         * @summary Gets accounts entries with shared
         * @param {number} id ID
         * @param {EmployeeStatus} [employeeStatus] Employee status
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {boolean} [excludeShared] Exclude shared
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {Array<EmployeeType>} [employeeTypes] Employee Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsEntriesWithShared: async (id: number, employeeStatus?: EmployeeStatus, activationStatus?: EmployeeActivationStatus, excludeShared?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, employeeTypes?: Array<EmployeeType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountsEntriesWithShared', 'id', id)
            const localVarPath = `/api/2.0/accounts/room/{id}/search`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (employeeStatus !== undefined) {
                localVarQueryParameter['employeeStatus'] = employeeStatus;
            }

            if (activationStatus !== undefined) {
                localVarQueryParameter['activationStatus'] = activationStatus;
            }

            if (excludeShared !== undefined) {
                localVarQueryParameter['excludeShared'] = excludeShared;
            }

            if (invitedByMe !== undefined) {
                localVarQueryParameter['invitedByMe'] = invitedByMe;
            }

            if (inviterId !== undefined) {
                localVarQueryParameter['inviterId'] = inviterId;
            }

            if (area !== undefined) {
                localVarQueryParameter['area'] = area;
            }

            if (employeeTypes) {
                localVarQueryParameter['employeeTypes'] = employeeTypes.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users matching the status filter and search query.
         * @summary Search users by status filter
         * @param {EmployeeStatus} status User status
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvanced: async (status: EmployeeStatus, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getAdvanced', 'status', status)
            const localVarPath = `/api/2.0/people/status/{status}/search`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users with full information about them matching the parameters specified in the request.
         * @summary Search users and their information by extended filter
         * @param {EmployeeStatus} [employeeStatus] User status
         * @param {string} [groupId] Group ID
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {EmployeeType} [employeeType] User type
         * @param {Array<EmployeeType>} [employeeTypes] List of user types
         * @param {boolean} [isAdministrator] Specifies if the user is an administrator or not
         * @param {Payments} [payments] User payment status
         * @param {AccountLoginType} [accountLoginType] Account login type
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {boolean} [withoutGroup] Specifies whether the user should be a member of a group or not
         * @param {boolean} [excludeGroup] Specifies whether or not the user should be a member of the group with the specified ID
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullByFilter: async (employeeStatus?: EmployeeStatus, groupId?: string, activationStatus?: EmployeeActivationStatus, employeeType?: EmployeeType, employeeTypes?: Array<EmployeeType>, isAdministrator?: boolean, payments?: Payments, accountLoginType?: AccountLoginType, quotaFilter?: QuotaFilter, withoutGroup?: boolean, excludeGroup?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (employeeStatus !== undefined) {
                localVarQueryParameter['employeeStatus'] = employeeStatus;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (activationStatus !== undefined) {
                localVarQueryParameter['activationStatus'] = activationStatus;
            }

            if (employeeType !== undefined) {
                localVarQueryParameter['employeeType'] = employeeType;
            }

            if (employeeTypes) {
                localVarQueryParameter['employeeTypes'] = employeeTypes.join(COLLECTION_FORMATS.csv);
            }

            if (isAdministrator !== undefined) {
                localVarQueryParameter['isAdministrator'] = isAdministrator;
            }

            if (payments !== undefined) {
                localVarQueryParameter['payments'] = payments;
            }

            if (accountLoginType !== undefined) {
                localVarQueryParameter['accountLoginType'] = accountLoginType;
            }

            if (quotaFilter !== undefined) {
                localVarQueryParameter['quotaFilter'] = quotaFilter;
            }

            if (withoutGroup !== undefined) {
                localVarQueryParameter['withoutGroup'] = withoutGroup;
            }

            if (excludeGroup !== undefined) {
                localVarQueryParameter['excludeGroup'] = excludeGroup;
            }

            if (invitedByMe !== undefined) {
                localVarQueryParameter['invitedByMe'] = invitedByMe;
            }

            if (inviterId !== undefined) {
                localVarQueryParameter['inviterId'] = inviterId;
            }

            if (area !== undefined) {
                localVarQueryParameter['area'] = area;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users matching the search query. This method uses the query parameters.
         * @summary Search users (using query parameters)
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeopleSearch: async (query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users matching the search query.
         * @summary Search users
         * @param {string} query Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch: async (query: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getSearch', 'query', query)
            const localVarPath = `/api/2.0/people/@search/{query}`
                .replace(`{${"query"}}`, encodeURIComponent(String(query)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users matching the parameters specified in the request.
         * @summary Search users by extended filter
         * @param {EmployeeStatus} [employeeStatus] User status
         * @param {string} [groupId] Group ID
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {EmployeeType} [employeeType] User type
         * @param {Array<EmployeeType>} [employeeTypes] List of user types
         * @param {boolean} [isAdministrator] Specifies if the user is an administrator or not
         * @param {Payments} [payments] User payment status
         * @param {AccountLoginType} [accountLoginType] Account login type
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {boolean} [withoutGroup] Specifies whether the user should be a member of a group or not
         * @param {boolean} [excludeGroup] Specifies whether or not the user should be a member of the group with the specified ID
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimpleByFilter: async (employeeStatus?: EmployeeStatus, groupId?: string, activationStatus?: EmployeeActivationStatus, employeeType?: EmployeeType, employeeTypes?: Array<EmployeeType>, isAdministrator?: boolean, payments?: Payments, accountLoginType?: AccountLoginType, quotaFilter?: QuotaFilter, withoutGroup?: boolean, excludeGroup?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/simple/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (employeeStatus !== undefined) {
                localVarQueryParameter['employeeStatus'] = employeeStatus;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (activationStatus !== undefined) {
                localVarQueryParameter['activationStatus'] = activationStatus;
            }

            if (employeeType !== undefined) {
                localVarQueryParameter['employeeType'] = employeeType;
            }

            if (employeeTypes) {
                localVarQueryParameter['employeeTypes'] = employeeTypes.join(COLLECTION_FORMATS.csv);
            }

            if (isAdministrator !== undefined) {
                localVarQueryParameter['isAdministrator'] = isAdministrator;
            }

            if (payments !== undefined) {
                localVarQueryParameter['payments'] = payments;
            }

            if (accountLoginType !== undefined) {
                localVarQueryParameter['accountLoginType'] = accountLoginType;
            }

            if (quotaFilter !== undefined) {
                localVarQueryParameter['quotaFilter'] = quotaFilter;
            }

            if (withoutGroup !== undefined) {
                localVarQueryParameter['withoutGroup'] = withoutGroup;
            }

            if (excludeGroup !== undefined) {
                localVarQueryParameter['excludeGroup'] = excludeGroup;
            }

            if (invitedByMe !== undefined) {
                localVarQueryParameter['invitedByMe'] = invitedByMe;
            }

            if (inviterId !== undefined) {
                localVarQueryParameter['inviterId'] = inviterId;
            }

            if (area !== undefined) {
                localVarQueryParameter['area'] = area;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users with shared in room ID specified in request
         * @summary Gets users with shared in room ID specified in request
         * @param {number} id Id
         * @param {EmployeeStatus} [employeeStatus] Employee status
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {boolean} [excludeShared] Exclude shared
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {Array<EmployeeType>} [employeeTypes] Employee Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersWithRoomShared: async (id: number, employeeStatus?: EmployeeStatus, activationStatus?: EmployeeActivationStatus, excludeShared?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, employeeTypes?: Array<EmployeeType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersWithRoomShared', 'id', id)
            const localVarPath = `/api/2.0/people/room/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (employeeStatus !== undefined) {
                localVarQueryParameter['employeeStatus'] = employeeStatus;
            }

            if (activationStatus !== undefined) {
                localVarQueryParameter['activationStatus'] = activationStatus;
            }

            if (excludeShared !== undefined) {
                localVarQueryParameter['excludeShared'] = excludeShared;
            }

            if (invitedByMe !== undefined) {
                localVarQueryParameter['invitedByMe'] = invitedByMe;
            }

            if (inviterId !== undefined) {
                localVarQueryParameter['inviterId'] = inviterId;
            }

            if (area !== undefined) {
                localVarQueryParameter['area'] = area;
            }

            if (employeeTypes) {
                localVarQueryParameter['employeeTypes'] = employeeTypes.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleSearchApi - functional programming interface
 * @export
 */
export const PeopleSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets accounts entries with shared
         * @summary Gets accounts entries with shared
         * @param {number} id ID
         * @param {EmployeeStatus} [employeeStatus] Employee status
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {boolean} [excludeShared] Exclude shared
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {Array<EmployeeType>} [employeeTypes] Employee Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsEntriesWithShared(id: number, employeeStatus?: EmployeeStatus, activationStatus?: EmployeeActivationStatus, excludeShared?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, employeeTypes?: Array<EmployeeType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsEntriesWithShared(id, employeeStatus, activationStatus, excludeShared, invitedByMe, inviterId, area, employeeTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleSearchApi.getAccountsEntriesWithShared']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of users matching the status filter and search query.
         * @summary Search users by status filter
         * @param {EmployeeStatus} status User status
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdvanced(status: EmployeeStatus, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdvanced(status, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleSearchApi.getAdvanced']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of users with full information about them matching the parameters specified in the request.
         * @summary Search users and their information by extended filter
         * @param {EmployeeStatus} [employeeStatus] User status
         * @param {string} [groupId] Group ID
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {EmployeeType} [employeeType] User type
         * @param {Array<EmployeeType>} [employeeTypes] List of user types
         * @param {boolean} [isAdministrator] Specifies if the user is an administrator or not
         * @param {Payments} [payments] User payment status
         * @param {AccountLoginType} [accountLoginType] Account login type
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {boolean} [withoutGroup] Specifies whether the user should be a member of a group or not
         * @param {boolean} [excludeGroup] Specifies whether or not the user should be a member of the group with the specified ID
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullByFilter(employeeStatus?: EmployeeStatus, groupId?: string, activationStatus?: EmployeeActivationStatus, employeeType?: EmployeeType, employeeTypes?: Array<EmployeeType>, isAdministrator?: boolean, payments?: Payments, accountLoginType?: AccountLoginType, quotaFilter?: QuotaFilter, withoutGroup?: boolean, excludeGroup?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullByFilter(employeeStatus, groupId, activationStatus, employeeType, employeeTypes, isAdministrator, payments, accountLoginType, quotaFilter, withoutGroup, excludeGroup, invitedByMe, inviterId, area, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleSearchApi.getFullByFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of users matching the search query. This method uses the query parameters.
         * @summary Search users (using query parameters)
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeopleSearch(query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeopleSearch(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleSearchApi.getPeopleSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of users matching the search query.
         * @summary Search users
         * @param {string} query Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearch(query: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearch(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleSearchApi.getSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of users matching the parameters specified in the request.
         * @summary Search users by extended filter
         * @param {EmployeeStatus} [employeeStatus] User status
         * @param {string} [groupId] Group ID
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {EmployeeType} [employeeType] User type
         * @param {Array<EmployeeType>} [employeeTypes] List of user types
         * @param {boolean} [isAdministrator] Specifies if the user is an administrator or not
         * @param {Payments} [payments] User payment status
         * @param {AccountLoginType} [accountLoginType] Account login type
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {boolean} [withoutGroup] Specifies whether the user should be a member of a group or not
         * @param {boolean} [excludeGroup] Specifies whether or not the user should be a member of the group with the specified ID
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimpleByFilter(employeeStatus?: EmployeeStatus, groupId?: string, activationStatus?: EmployeeActivationStatus, employeeType?: EmployeeType, employeeTypes?: Array<EmployeeType>, isAdministrator?: boolean, payments?: Payments, accountLoginType?: AccountLoginType, quotaFilter?: QuotaFilter, withoutGroup?: boolean, excludeGroup?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimpleByFilter(employeeStatus, groupId, activationStatus, employeeType, employeeTypes, isAdministrator, payments, accountLoginType, quotaFilter, withoutGroup, excludeGroup, invitedByMe, inviterId, area, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleSearchApi.getSimpleByFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets users with shared in room ID specified in request
         * @summary Gets users with shared in room ID specified in request
         * @param {number} id Id
         * @param {EmployeeStatus} [employeeStatus] Employee status
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {boolean} [excludeShared] Exclude shared
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {Array<EmployeeType>} [employeeTypes] Employee Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersWithRoomShared(id: number, employeeStatus?: EmployeeStatus, activationStatus?: EmployeeActivationStatus, excludeShared?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, employeeTypes?: Array<EmployeeType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersWithRoomShared(id, employeeStatus, activationStatus, excludeShared, invitedByMe, inviterId, area, employeeTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleSearchApi.getUsersWithRoomShared']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleSearchApi - factory interface
 * @export
 */
export const PeopleSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleSearchApiFp(configuration)
    return {
        /**
         * Gets accounts entries with shared
         * @summary Gets accounts entries with shared
         * @param {number} id ID
         * @param {EmployeeStatus} [employeeStatus] Employee status
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {boolean} [excludeShared] Exclude shared
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {Array<EmployeeType>} [employeeTypes] Employee Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsEntriesWithShared(id: number, employeeStatus?: EmployeeStatus, activationStatus?: EmployeeActivationStatus, excludeShared?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, employeeTypes?: Array<EmployeeType>, options?: RawAxiosRequestConfig): AxiosPromise<ObjectArrayWrapper> {
            return localVarFp.getAccountsEntriesWithShared(id, employeeStatus, activationStatus, excludeShared, invitedByMe, inviterId, area, employeeTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users matching the status filter and search query.
         * @summary Search users by status filter
         * @param {EmployeeStatus} status User status
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvanced(status: EmployeeStatus, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.getAdvanced(status, query, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users with full information about them matching the parameters specified in the request.
         * @summary Search users and their information by extended filter
         * @param {EmployeeStatus} [employeeStatus] User status
         * @param {string} [groupId] Group ID
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {EmployeeType} [employeeType] User type
         * @param {Array<EmployeeType>} [employeeTypes] List of user types
         * @param {boolean} [isAdministrator] Specifies if the user is an administrator or not
         * @param {Payments} [payments] User payment status
         * @param {AccountLoginType} [accountLoginType] Account login type
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {boolean} [withoutGroup] Specifies whether the user should be a member of a group or not
         * @param {boolean} [excludeGroup] Specifies whether or not the user should be a member of the group with the specified ID
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullByFilter(employeeStatus?: EmployeeStatus, groupId?: string, activationStatus?: EmployeeActivationStatus, employeeType?: EmployeeType, employeeTypes?: Array<EmployeeType>, isAdministrator?: boolean, payments?: Payments, accountLoginType?: AccountLoginType, quotaFilter?: QuotaFilter, withoutGroup?: boolean, excludeGroup?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.getFullByFilter(employeeStatus, groupId, activationStatus, employeeType, employeeTypes, isAdministrator, payments, accountLoginType, quotaFilter, withoutGroup, excludeGroup, invitedByMe, inviterId, area, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users matching the search query. This method uses the query parameters.
         * @summary Search users (using query parameters)
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeopleSearch(query?: string, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeArrayWrapper> {
            return localVarFp.getPeopleSearch(query, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users matching the search query.
         * @summary Search users
         * @param {string} query Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(query: string, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.getSearch(query, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users matching the parameters specified in the request.
         * @summary Search users by extended filter
         * @param {EmployeeStatus} [employeeStatus] User status
         * @param {string} [groupId] Group ID
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {EmployeeType} [employeeType] User type
         * @param {Array<EmployeeType>} [employeeTypes] List of user types
         * @param {boolean} [isAdministrator] Specifies if the user is an administrator or not
         * @param {Payments} [payments] User payment status
         * @param {AccountLoginType} [accountLoginType] Account login type
         * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
         * @param {boolean} [withoutGroup] Specifies whether the user should be a member of a group or not
         * @param {boolean} [excludeGroup] Specifies whether or not the user should be a member of the group with the specified ID
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimpleByFilter(employeeStatus?: EmployeeStatus, groupId?: string, activationStatus?: EmployeeActivationStatus, employeeType?: EmployeeType, employeeTypes?: Array<EmployeeType>, isAdministrator?: boolean, payments?: Payments, accountLoginType?: AccountLoginType, quotaFilter?: QuotaFilter, withoutGroup?: boolean, excludeGroup?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeArrayWrapper> {
            return localVarFp.getSimpleByFilter(employeeStatus, groupId, activationStatus, employeeType, employeeTypes, isAdministrator, payments, accountLoginType, quotaFilter, withoutGroup, excludeGroup, invitedByMe, inviterId, area, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets users with shared in room ID specified in request
         * @summary Gets users with shared in room ID specified in request
         * @param {number} id Id
         * @param {EmployeeStatus} [employeeStatus] Employee status
         * @param {EmployeeActivationStatus} [activationStatus] Activation status
         * @param {boolean} [excludeShared] Exclude shared
         * @param {boolean} [invitedByMe] Invited by me
         * @param {string} [inviterId] Inviter Id
         * @param {Area} [area] Area
         * @param {Array<EmployeeType>} [employeeTypes] Employee Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersWithRoomShared(id: number, employeeStatus?: EmployeeStatus, activationStatus?: EmployeeActivationStatus, excludeShared?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, employeeTypes?: Array<EmployeeType>, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.getUsersWithRoomShared(id, employeeStatus, activationStatus, excludeShared, invitedByMe, inviterId, area, employeeTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleSearchApi - object-oriented interface
 * @export
 * @class PeopleSearchApi
 * @extends {BaseAPI}
 */
export class PeopleSearchApi extends BaseAPI {
    /**
     * Gets accounts entries with shared
     * @summary Gets accounts entries with shared
     * @param {number} id ID
     * @param {EmployeeStatus} [employeeStatus] Employee status
     * @param {EmployeeActivationStatus} [activationStatus] Activation status
     * @param {boolean} [excludeShared] Exclude shared
     * @param {boolean} [invitedByMe] Invited by me
     * @param {string} [inviterId] Inviter Id
     * @param {Area} [area] Area
     * @param {Array<EmployeeType>} [employeeTypes] Employee Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleSearchApi
     */
    public getAccountsEntriesWithShared(id: number, employeeStatus?: EmployeeStatus, activationStatus?: EmployeeActivationStatus, excludeShared?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, employeeTypes?: Array<EmployeeType>, options?: RawAxiosRequestConfig) {
        return PeopleSearchApiFp(this.configuration).getAccountsEntriesWithShared(id, employeeStatus, activationStatus, excludeShared, invitedByMe, inviterId, area, employeeTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users matching the status filter and search query.
     * @summary Search users by status filter
     * @param {EmployeeStatus} status User status
     * @param {string} [query] Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleSearchApi
     */
    public getAdvanced(status: EmployeeStatus, query?: string, options?: RawAxiosRequestConfig) {
        return PeopleSearchApiFp(this.configuration).getAdvanced(status, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users with full information about them matching the parameters specified in the request.
     * @summary Search users and their information by extended filter
     * @param {EmployeeStatus} [employeeStatus] User status
     * @param {string} [groupId] Group ID
     * @param {EmployeeActivationStatus} [activationStatus] Activation status
     * @param {EmployeeType} [employeeType] User type
     * @param {Array<EmployeeType>} [employeeTypes] List of user types
     * @param {boolean} [isAdministrator] Specifies if the user is an administrator or not
     * @param {Payments} [payments] User payment status
     * @param {AccountLoginType} [accountLoginType] Account login type
     * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
     * @param {boolean} [withoutGroup] Specifies whether the user should be a member of a group or not
     * @param {boolean} [excludeGroup] Specifies whether or not the user should be a member of the group with the specified ID
     * @param {boolean} [invitedByMe] Invited by me
     * @param {string} [inviterId] Inviter Id
     * @param {Area} [area] Area
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleSearchApi
     */
    public getFullByFilter(employeeStatus?: EmployeeStatus, groupId?: string, activationStatus?: EmployeeActivationStatus, employeeType?: EmployeeType, employeeTypes?: Array<EmployeeType>, isAdministrator?: boolean, payments?: Payments, accountLoginType?: AccountLoginType, quotaFilter?: QuotaFilter, withoutGroup?: boolean, excludeGroup?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, options?: RawAxiosRequestConfig) {
        return PeopleSearchApiFp(this.configuration).getFullByFilter(employeeStatus, groupId, activationStatus, employeeType, employeeTypes, isAdministrator, payments, accountLoginType, quotaFilter, withoutGroup, excludeGroup, invitedByMe, inviterId, area, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users matching the search query. This method uses the query parameters.
     * @summary Search users (using query parameters)
     * @param {string} [query] Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleSearchApi
     */
    public getPeopleSearch(query?: string, options?: RawAxiosRequestConfig) {
        return PeopleSearchApiFp(this.configuration).getPeopleSearch(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users matching the search query.
     * @summary Search users
     * @param {string} query Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleSearchApi
     */
    public getSearch(query: string, options?: RawAxiosRequestConfig) {
        return PeopleSearchApiFp(this.configuration).getSearch(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users matching the parameters specified in the request.
     * @summary Search users by extended filter
     * @param {EmployeeStatus} [employeeStatus] User status
     * @param {string} [groupId] Group ID
     * @param {EmployeeActivationStatus} [activationStatus] Activation status
     * @param {EmployeeType} [employeeType] User type
     * @param {Array<EmployeeType>} [employeeTypes] List of user types
     * @param {boolean} [isAdministrator] Specifies if the user is an administrator or not
     * @param {Payments} [payments] User payment status
     * @param {AccountLoginType} [accountLoginType] Account login type
     * @param {QuotaFilter} [quotaFilter] Filter by quota (All - 0, Default - 1, Custom - 2)
     * @param {boolean} [withoutGroup] Specifies whether the user should be a member of a group or not
     * @param {boolean} [excludeGroup] Specifies whether or not the user should be a member of the group with the specified ID
     * @param {boolean} [invitedByMe] Invited by me
     * @param {string} [inviterId] Inviter Id
     * @param {Area} [area] Area
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleSearchApi
     */
    public getSimpleByFilter(employeeStatus?: EmployeeStatus, groupId?: string, activationStatus?: EmployeeActivationStatus, employeeType?: EmployeeType, employeeTypes?: Array<EmployeeType>, isAdministrator?: boolean, payments?: Payments, accountLoginType?: AccountLoginType, quotaFilter?: QuotaFilter, withoutGroup?: boolean, excludeGroup?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, options?: RawAxiosRequestConfig) {
        return PeopleSearchApiFp(this.configuration).getSimpleByFilter(employeeStatus, groupId, activationStatus, employeeType, employeeTypes, isAdministrator, payments, accountLoginType, quotaFilter, withoutGroup, excludeGroup, invitedByMe, inviterId, area, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets users with shared in room ID specified in request
     * @summary Gets users with shared in room ID specified in request
     * @param {number} id Id
     * @param {EmployeeStatus} [employeeStatus] Employee status
     * @param {EmployeeActivationStatus} [activationStatus] Activation status
     * @param {boolean} [excludeShared] Exclude shared
     * @param {boolean} [invitedByMe] Invited by me
     * @param {string} [inviterId] Inviter Id
     * @param {Area} [area] Area
     * @param {Array<EmployeeType>} [employeeTypes] Employee Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleSearchApi
     */
    public getUsersWithRoomShared(id: number, employeeStatus?: EmployeeStatus, activationStatus?: EmployeeActivationStatus, excludeShared?: boolean, invitedByMe?: boolean, inviterId?: string, area?: Area, employeeTypes?: Array<EmployeeType>, options?: RawAxiosRequestConfig) {
        return PeopleSearchApiFp(this.configuration).getUsersWithRoomShared(id, employeeStatus, activationStatus, excludeShared, invitedByMe, inviterId, area, employeeTypes, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleThemeApi - axios parameter creator
 * @export
 */
export const PeopleThemeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes the current portal theme.
         * @summary Change portal theme
         * @param {DarkThemeSettingsRequestDto} [darkThemeSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTheme: async (darkThemeSettingsRequestDto?: DarkThemeSettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(darkThemeSettingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a theme which is set to the current portal.
         * @summary Get portal theme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheme: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleThemeApi - functional programming interface
 * @export
 */
export const PeopleThemeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleThemeApiAxiosParamCreator(configuration)
    return {
        /**
         * Changes the current portal theme.
         * @summary Change portal theme
         * @param {DarkThemeSettingsRequestDto} [darkThemeSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeTheme(darkThemeSettingsRequestDto?: DarkThemeSettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DarkThemeSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeTheme(darkThemeSettingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleThemeApi.changeTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a theme which is set to the current portal.
         * @summary Get portal theme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTheme(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DarkThemeSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTheme(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleThemeApi.getTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleThemeApi - factory interface
 * @export
 */
export const PeopleThemeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleThemeApiFp(configuration)
    return {
        /**
         * Changes the current portal theme.
         * @summary Change portal theme
         * @param {DarkThemeSettingsRequestDto} [darkThemeSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTheme(darkThemeSettingsRequestDto?: DarkThemeSettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<DarkThemeSettingsWrapper> {
            return localVarFp.changeTheme(darkThemeSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a theme which is set to the current portal.
         * @summary Get portal theme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheme(options?: RawAxiosRequestConfig): AxiosPromise<DarkThemeSettingsWrapper> {
            return localVarFp.getTheme(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleThemeApi - object-oriented interface
 * @export
 * @class PeopleThemeApi
 * @extends {BaseAPI}
 */
export class PeopleThemeApi extends BaseAPI {
    /**
     * Changes the current portal theme.
     * @summary Change portal theme
     * @param {DarkThemeSettingsRequestDto} [darkThemeSettingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleThemeApi
     */
    public changeTheme(darkThemeSettingsRequestDto?: DarkThemeSettingsRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleThemeApiFp(this.configuration).changeTheme(darkThemeSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a theme which is set to the current portal.
     * @summary Get portal theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleThemeApi
     */
    public getTheme(options?: RawAxiosRequestConfig) {
        return PeopleThemeApiFp(this.configuration).getTheme(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleThirdPartyAccountsApi - axios parameter creator
 * @export
 */
export const PeopleThirdPartyAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of the available third-party accounts.
         * @summary Get third-party accounts
         * @param {boolean} [inviteView] Specifies whether to return providers that are available for invitation links, i.e. the user can login or register through these providers
         * @param {boolean} [settingsView] Specifies whether to return URLs in the format that is used on the Settings page
         * @param {string} [clientCallback] Method that is called after authorization
         * @param {string} [fromOnly] Provider name if the response only from this provider is needed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders: async (inviteView?: boolean, settingsView?: boolean, clientCallback?: string, fromOnly?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/thirdparty/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inviteView !== undefined) {
                localVarQueryParameter['inviteView'] = inviteView;
            }

            if (settingsView !== undefined) {
                localVarQueryParameter['settingsView'] = settingsView;
            }

            if (clientCallback !== undefined) {
                localVarQueryParameter['clientCallback'] = clientCallback;
            }

            if (fromOnly !== undefined) {
                localVarQueryParameter['fromOnly'] = fromOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Links a third-party account specified in the request to the user profile.
         * @summary Link a third-pary account
         * @param {LinkAccountRequestDto} [linkAccountRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAccount: async (linkAccountRequestDto?: LinkAccountRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/thirdparty/linkaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkAccountRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a third-party account with the parameters specified in the request.
         * @summary Create a third-pary account
         * @param {SignupAccountRequestDto} [signupAccountRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupAccount: async (signupAccountRequestDto?: SignupAccountRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/thirdparty/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupAccountRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlinks a third-party account specified in the request from the user profile.
         * @summary Unlink a third-pary account
         * @param {string} [provider] Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAccount: async (provider?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/thirdparty/unlinkaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleThirdPartyAccountsApi - functional programming interface
 * @export
 */
export const PeopleThirdPartyAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleThirdPartyAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of the available third-party accounts.
         * @summary Get third-party accounts
         * @param {boolean} [inviteView] Specifies whether to return providers that are available for invitation links, i.e. the user can login or register through these providers
         * @param {boolean} [settingsView] Specifies whether to return URLs in the format that is used on the Settings page
         * @param {string} [clientCallback] Method that is called after authorization
         * @param {string} [fromOnly] Provider name if the response only from this provider is needed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthProviders(inviteView?: boolean, settingsView?: boolean, clientCallback?: string, fromOnly?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfoArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthProviders(inviteView, settingsView, clientCallback, fromOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleThirdPartyAccountsApi.getAuthProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Links a third-party account specified in the request to the user profile.
         * @summary Link a third-pary account
         * @param {LinkAccountRequestDto} [linkAccountRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkAccount(linkAccountRequestDto?: LinkAccountRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkAccount(linkAccountRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleThirdPartyAccountsApi.linkAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a third-party account with the parameters specified in the request.
         * @summary Create a third-pary account
         * @param {SignupAccountRequestDto} [signupAccountRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupAccount(signupAccountRequestDto?: SignupAccountRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupAccount(signupAccountRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleThirdPartyAccountsApi.signupAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlinks a third-party account specified in the request from the user profile.
         * @summary Unlink a third-pary account
         * @param {string} [provider] Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkAccount(provider?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkAccount(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleThirdPartyAccountsApi.unlinkAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleThirdPartyAccountsApi - factory interface
 * @export
 */
export const PeopleThirdPartyAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleThirdPartyAccountsApiFp(configuration)
    return {
        /**
         * Returns a list of the available third-party accounts.
         * @summary Get third-party accounts
         * @param {boolean} [inviteView] Specifies whether to return providers that are available for invitation links, i.e. the user can login or register through these providers
         * @param {boolean} [settingsView] Specifies whether to return URLs in the format that is used on the Settings page
         * @param {string} [clientCallback] Method that is called after authorization
         * @param {string} [fromOnly] Provider name if the response only from this provider is needed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders(inviteView?: boolean, settingsView?: boolean, clientCallback?: string, fromOnly?: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountInfoArrayWrapper> {
            return localVarFp.getAuthProviders(inviteView, settingsView, clientCallback, fromOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Links a third-party account specified in the request to the user profile.
         * @summary Link a third-pary account
         * @param {LinkAccountRequestDto} [linkAccountRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAccount(linkAccountRequestDto?: LinkAccountRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.linkAccount(linkAccountRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a third-party account with the parameters specified in the request.
         * @summary Create a third-pary account
         * @param {SignupAccountRequestDto} [signupAccountRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupAccount(signupAccountRequestDto?: SignupAccountRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.signupAccount(signupAccountRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlinks a third-party account specified in the request from the user profile.
         * @summary Unlink a third-pary account
         * @param {string} [provider] Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAccount(provider?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unlinkAccount(provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleThirdPartyAccountsApi - object-oriented interface
 * @export
 * @class PeopleThirdPartyAccountsApi
 * @extends {BaseAPI}
 */
export class PeopleThirdPartyAccountsApi extends BaseAPI {
    /**
     * Returns a list of the available third-party accounts.
     * @summary Get third-party accounts
     * @param {boolean} [inviteView] Specifies whether to return providers that are available for invitation links, i.e. the user can login or register through these providers
     * @param {boolean} [settingsView] Specifies whether to return URLs in the format that is used on the Settings page
     * @param {string} [clientCallback] Method that is called after authorization
     * @param {string} [fromOnly] Provider name if the response only from this provider is needed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleThirdPartyAccountsApi
     */
    public getAuthProviders(inviteView?: boolean, settingsView?: boolean, clientCallback?: string, fromOnly?: string, options?: RawAxiosRequestConfig) {
        return PeopleThirdPartyAccountsApiFp(this.configuration).getAuthProviders(inviteView, settingsView, clientCallback, fromOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Links a third-party account specified in the request to the user profile.
     * @summary Link a third-pary account
     * @param {LinkAccountRequestDto} [linkAccountRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleThirdPartyAccountsApi
     */
    public linkAccount(linkAccountRequestDto?: LinkAccountRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleThirdPartyAccountsApiFp(this.configuration).linkAccount(linkAccountRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a third-party account with the parameters specified in the request.
     * @summary Create a third-pary account
     * @param {SignupAccountRequestDto} [signupAccountRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleThirdPartyAccountsApi
     */
    public signupAccount(signupAccountRequestDto?: SignupAccountRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleThirdPartyAccountsApiFp(this.configuration).signupAccount(signupAccountRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlinks a third-party account specified in the request from the user profile.
     * @summary Unlink a third-pary account
     * @param {string} [provider] Provider name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleThirdPartyAccountsApi
     */
    public unlinkAccount(provider?: string, options?: RawAxiosRequestConfig) {
        return PeopleThirdPartyAccountsApiFp(this.configuration).unlinkAccount(provider, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleUserDataApi - axios parameter creator
 * @export
 */
export const PeopleUserDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the progress of the started data reassignment for the user with the ID specified in the request.
         * @summary Get the reassignment progress
         * @param {string} userid User ID whose data is reassigned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReassignProgress: async (userid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getReassignProgress', 'userid', userid)
            const localVarPath = `/api/2.0/people/reassign/progress/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the progress of the started data deletion for the user with the ID specified in the request.
         * @summary Get the deletion progress
         * @param {string} userid User ID whose data is reassigned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoveProgress: async (userid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getRemoveProgress', 'userid', userid)
            const localVarPath = `/api/2.0/people/remove/progress/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends instructions for deleting a user profile.
         * @summary Send the deletion instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInstructionsToDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/self/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the data reassignment for the user with the ID specified in the request.
         * @summary Start the data reassignment
         * @param {StartReassignRequestDto} [startReassignRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startReassign: async (startReassignRequestDto?: StartReassignRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/reassign/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startReassignRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the data deletion for the user with the ID specified in the request.
         * @summary Start the data deletion
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRemove: async (terminateRequestDto?: TerminateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/remove/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terminateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the data reassignment for the user with the ID specified in the request.
         * @summary Terminate the data reassignment
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateReassign: async (terminateRequestDto?: TerminateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/reassign/terminate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terminateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the data deletion for the user with the ID specified in the request.
         * @summary Terminate the data deletion
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRemove: async (terminateRequestDto?: TerminateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/people/remove/terminate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terminateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleUserDataApi - functional programming interface
 * @export
 */
export const PeopleUserDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleUserDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the progress of the started data reassignment for the user with the ID specified in the request.
         * @summary Get the reassignment progress
         * @param {string} userid User ID whose data is reassigned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReassignProgress(userid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskProgressResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReassignProgress(userid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserDataApi.getReassignProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the progress of the started data deletion for the user with the ID specified in the request.
         * @summary Get the deletion progress
         * @param {string} userid User ID whose data is reassigned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoveProgress(userid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskProgressResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemoveProgress(userid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserDataApi.getRemoveProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends instructions for deleting a user profile.
         * @summary Send the deletion instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInstructionsToDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendInstructionsToDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserDataApi.sendInstructionsToDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the data reassignment for the user with the ID specified in the request.
         * @summary Start the data reassignment
         * @param {StartReassignRequestDto} [startReassignRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startReassign(startReassignRequestDto?: StartReassignRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskProgressResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startReassign(startReassignRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserDataApi.startReassign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the data deletion for the user with the ID specified in the request.
         * @summary Start the data deletion
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRemove(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskProgressResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRemove(terminateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserDataApi.startRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminates the data reassignment for the user with the ID specified in the request.
         * @summary Terminate the data reassignment
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateReassign(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskProgressResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateReassign(terminateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserDataApi.terminateReassign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminates the data deletion for the user with the ID specified in the request.
         * @summary Terminate the data deletion
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateRemove(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateRemove(terminateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserDataApi.terminateRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleUserDataApi - factory interface
 * @export
 */
export const PeopleUserDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleUserDataApiFp(configuration)
    return {
        /**
         * Returns the progress of the started data reassignment for the user with the ID specified in the request.
         * @summary Get the reassignment progress
         * @param {string} userid User ID whose data is reassigned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReassignProgress(userid: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskProgressResponseWrapper> {
            return localVarFp.getReassignProgress(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the progress of the started data deletion for the user with the ID specified in the request.
         * @summary Get the deletion progress
         * @param {string} userid User ID whose data is reassigned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoveProgress(userid: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskProgressResponseWrapper> {
            return localVarFp.getRemoveProgress(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends instructions for deleting a user profile.
         * @summary Send the deletion instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInstructionsToDelete(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.sendInstructionsToDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the data reassignment for the user with the ID specified in the request.
         * @summary Start the data reassignment
         * @param {StartReassignRequestDto} [startReassignRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startReassign(startReassignRequestDto?: StartReassignRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<TaskProgressResponseWrapper> {
            return localVarFp.startReassign(startReassignRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the data deletion for the user with the ID specified in the request.
         * @summary Start the data deletion
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRemove(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<TaskProgressResponseWrapper> {
            return localVarFp.startRemove(terminateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the data reassignment for the user with the ID specified in the request.
         * @summary Terminate the data reassignment
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateReassign(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<TaskProgressResponseWrapper> {
            return localVarFp.terminateReassign(terminateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the data deletion for the user with the ID specified in the request.
         * @summary Terminate the data deletion
         * @param {TerminateRequestDto} [terminateRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRemove(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.terminateRemove(terminateRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleUserDataApi - object-oriented interface
 * @export
 * @class PeopleUserDataApi
 * @extends {BaseAPI}
 */
export class PeopleUserDataApi extends BaseAPI {
    /**
     * Returns the progress of the started data reassignment for the user with the ID specified in the request.
     * @summary Get the reassignment progress
     * @param {string} userid User ID whose data is reassigned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserDataApi
     */
    public getReassignProgress(userid: string, options?: RawAxiosRequestConfig) {
        return PeopleUserDataApiFp(this.configuration).getReassignProgress(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the progress of the started data deletion for the user with the ID specified in the request.
     * @summary Get the deletion progress
     * @param {string} userid User ID whose data is reassigned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserDataApi
     */
    public getRemoveProgress(userid: string, options?: RawAxiosRequestConfig) {
        return PeopleUserDataApiFp(this.configuration).getRemoveProgress(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends instructions for deleting a user profile.
     * @summary Send the deletion instructions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserDataApi
     */
    public sendInstructionsToDelete(options?: RawAxiosRequestConfig) {
        return PeopleUserDataApiFp(this.configuration).sendInstructionsToDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the data reassignment for the user with the ID specified in the request.
     * @summary Start the data reassignment
     * @param {StartReassignRequestDto} [startReassignRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserDataApi
     */
    public startReassign(startReassignRequestDto?: StartReassignRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleUserDataApiFp(this.configuration).startReassign(startReassignRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the data deletion for the user with the ID specified in the request.
     * @summary Start the data deletion
     * @param {TerminateRequestDto} [terminateRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserDataApi
     */
    public startRemove(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleUserDataApiFp(this.configuration).startRemove(terminateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the data reassignment for the user with the ID specified in the request.
     * @summary Terminate the data reassignment
     * @param {TerminateRequestDto} [terminateRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserDataApi
     */
    public terminateReassign(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleUserDataApiFp(this.configuration).terminateReassign(terminateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the data deletion for the user with the ID specified in the request.
     * @summary Terminate the data deletion
     * @param {TerminateRequestDto} [terminateRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserDataApi
     */
    public terminateRemove(terminateRequestDto?: TerminateRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleUserDataApiFp(this.configuration).terminateRemove(terminateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleUserStatusApi - axios parameter creator
 * @export
 */
export const PeopleUserStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of profiles filtered by user status.
         * @summary Get profiles by status
         * @param {EmployeeStatus} status User status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByStatus: async (status: EmployeeStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getByStatus', 'status', status)
            const localVarPath = `/api/2.0/people/status/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the required activation status to the list of users with the IDs specified in the request.
         * @summary Set an activation status to the users
         * @param {EmployeeActivationStatus} activationstatus Activation status
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployeeActivationStatus: async (activationstatus: EmployeeActivationStatus, updateMembersRequestDto?: UpdateMembersRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activationstatus' is not null or undefined
            assertParamExists('updateEmployeeActivationStatus', 'activationstatus', activationstatus)
            const localVarPath = `/api/2.0/people/activationstatus/{activationstatus}`
                .replace(`{${"activationstatus"}}`, encodeURIComponent(String(activationstatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMembersRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a status for the users with the IDs specified in the request.
         * @summary Change a user status
         * @param {EmployeeStatus} status New user status
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserStatus: async (status: EmployeeStatus, updateMembersRequestDto?: UpdateMembersRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateUserStatus', 'status', status)
            const localVarPath = `/api/2.0/people/status/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMembersRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleUserStatusApi - functional programming interface
 * @export
 */
export const PeopleUserStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleUserStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of profiles filtered by user status.
         * @summary Get profiles by status
         * @param {EmployeeStatus} status User status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByStatus(status: EmployeeStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByStatus(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserStatusApi.getByStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the required activation status to the list of users with the IDs specified in the request.
         * @summary Set an activation status to the users
         * @param {EmployeeActivationStatus} activationstatus Activation status
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmployeeActivationStatus(activationstatus: EmployeeActivationStatus, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmployeeActivationStatus(activationstatus, updateMembersRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserStatusApi.updateEmployeeActivationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes a status for the users with the IDs specified in the request.
         * @summary Change a user status
         * @param {EmployeeStatus} status New user status
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserStatus(status: EmployeeStatus, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserStatus(status, updateMembersRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserStatusApi.updateUserStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleUserStatusApi - factory interface
 * @export
 */
export const PeopleUserStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleUserStatusApiFp(configuration)
    return {
        /**
         * Returns a list of profiles filtered by user status.
         * @summary Get profiles by status
         * @param {EmployeeStatus} status User status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByStatus(status: EmployeeStatus, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.getByStatus(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the required activation status to the list of users with the IDs specified in the request.
         * @summary Set an activation status to the users
         * @param {EmployeeActivationStatus} activationstatus Activation status
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployeeActivationStatus(activationstatus: EmployeeActivationStatus, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.updateEmployeeActivationStatus(activationstatus, updateMembersRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes a status for the users with the IDs specified in the request.
         * @summary Change a user status
         * @param {EmployeeStatus} status New user status
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserStatus(status: EmployeeStatus, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.updateUserStatus(status, updateMembersRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleUserStatusApi - object-oriented interface
 * @export
 * @class PeopleUserStatusApi
 * @extends {BaseAPI}
 */
export class PeopleUserStatusApi extends BaseAPI {
    /**
     * Returns a list of profiles filtered by user status.
     * @summary Get profiles by status
     * @param {EmployeeStatus} status User status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserStatusApi
     */
    public getByStatus(status: EmployeeStatus, options?: RawAxiosRequestConfig) {
        return PeopleUserStatusApiFp(this.configuration).getByStatus(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the required activation status to the list of users with the IDs specified in the request.
     * @summary Set an activation status to the users
     * @param {EmployeeActivationStatus} activationstatus Activation status
     * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserStatusApi
     */
    public updateEmployeeActivationStatus(activationstatus: EmployeeActivationStatus, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleUserStatusApiFp(this.configuration).updateEmployeeActivationStatus(activationstatus, updateMembersRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes a status for the users with the IDs specified in the request.
     * @summary Change a user status
     * @param {EmployeeStatus} status New user status
     * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserStatusApi
     */
    public updateUserStatus(status: EmployeeStatus, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleUserStatusApiFp(this.configuration).updateUserStatus(status, updateMembersRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleUserTypeApi - axios parameter creator
 * @export
 */
export const PeopleUserTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes a type for the users with the IDs specified in the request.
         * @summary Change a user type
         * @param {EmployeeType} type New user type
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserType: async (type: EmployeeType, updateMembersRequestDto?: UpdateMembersRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateUserType', 'type', type)
            const localVarPath = `/api/2.0/people/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMembersRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleUserTypeApi - functional programming interface
 * @export
 */
export const PeopleUserTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleUserTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * Changes a type for the users with the IDs specified in the request.
         * @summary Change a user type
         * @param {EmployeeType} type New user type
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserType(type: EmployeeType, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeFullArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserType(type, updateMembersRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleUserTypeApi.updateUserType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleUserTypeApi - factory interface
 * @export
 */
export const PeopleUserTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleUserTypeApiFp(configuration)
    return {
        /**
         * Changes a type for the users with the IDs specified in the request.
         * @summary Change a user type
         * @param {EmployeeType} type New user type
         * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserType(type: EmployeeType, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeFullArrayWrapper> {
            return localVarFp.updateUserType(type, updateMembersRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleUserTypeApi - object-oriented interface
 * @export
 * @class PeopleUserTypeApi
 * @extends {BaseAPI}
 */
export class PeopleUserTypeApi extends BaseAPI {
    /**
     * Changes a type for the users with the IDs specified in the request.
     * @summary Change a user type
     * @param {EmployeeType} type New user type
     * @param {UpdateMembersRequestDto} [updateMembersRequestDto] Update members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleUserTypeApi
     */
    public updateUserType(type: EmployeeType, updateMembersRequestDto?: UpdateMembersRequestDto, options?: RawAxiosRequestConfig) {
        return PeopleUserTypeApiFp(this.configuration).updateUserType(type, updateMembersRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PortalQuotaApi - axios parameter creator
 * @export
 */
export const PortalQuotaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current portal quota.
         * @summary Get a portal quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuota: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/quota`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the recommended quota for the current portal.
         * @summary Get the recommended quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightQuota: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/quota/right`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current portal tariff.
         * @summary Get a portal tariff
         * @param {boolean} [refresh] Specifies whether the tariff will be refreshed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTariff: async (refresh?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/tariff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the used space of the current portal.
         * @summary Get the used portal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsedSpace: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/usedspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortalQuotaApi - functional programming interface
 * @export
 */
export const PortalQuotaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortalQuotaApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current portal quota.
         * @summary Get a portal quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuota(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantQuotaWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuota(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalQuotaApi.getQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the recommended quota for the current portal.
         * @summary Get the recommended quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRightQuota(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantQuotaWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRightQuota(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalQuotaApi.getRightQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current portal tariff.
         * @summary Get a portal tariff
         * @param {boolean} [refresh] Specifies whether the tariff will be refreshed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTariff(refresh?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TariffWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTariff(refresh, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalQuotaApi.getTariff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the used space of the current portal.
         * @summary Get the used portal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsedSpace(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoubleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsedSpace(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalQuotaApi.getUsedSpace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PortalQuotaApi - factory interface
 * @export
 */
export const PortalQuotaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortalQuotaApiFp(configuration)
    return {
        /**
         * Returns the current portal quota.
         * @summary Get a portal quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuota(options?: RawAxiosRequestConfig): AxiosPromise<TenantQuotaWrapper> {
            return localVarFp.getQuota(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the recommended quota for the current portal.
         * @summary Get the recommended quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightQuota(options?: RawAxiosRequestConfig): AxiosPromise<TenantQuotaWrapper> {
            return localVarFp.getRightQuota(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current portal tariff.
         * @summary Get a portal tariff
         * @param {boolean} [refresh] Specifies whether the tariff will be refreshed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTariff(refresh?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<TariffWrapper> {
            return localVarFp.getTariff(refresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the used space of the current portal.
         * @summary Get the used portal space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsedSpace(options?: RawAxiosRequestConfig): AxiosPromise<DoubleWrapper> {
            return localVarFp.getUsedSpace(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortalQuotaApi - object-oriented interface
 * @export
 * @class PortalQuotaApi
 * @extends {BaseAPI}
 */
export class PortalQuotaApi extends BaseAPI {
    /**
     * Returns the current portal quota.
     * @summary Get a portal quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalQuotaApi
     */
    public getQuota(options?: RawAxiosRequestConfig) {
        return PortalQuotaApiFp(this.configuration).getQuota(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the recommended quota for the current portal.
     * @summary Get the recommended quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalQuotaApi
     */
    public getRightQuota(options?: RawAxiosRequestConfig) {
        return PortalQuotaApiFp(this.configuration).getRightQuota(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current portal tariff.
     * @summary Get a portal tariff
     * @param {boolean} [refresh] Specifies whether the tariff will be refreshed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalQuotaApi
     */
    public getTariff(refresh?: boolean, options?: RawAxiosRequestConfig) {
        return PortalQuotaApiFp(this.configuration).getTariff(refresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the used space of the current portal.
     * @summary Get the used portal space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalQuotaApi
     */
    public getUsedSpace(options?: RawAxiosRequestConfig) {
        return PortalQuotaApiFp(this.configuration).getUsedSpace(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PortalSettingsApi - axios parameter creator
 * @export
 */
export const PortalSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Restores the current portal.
         * @summary Restore a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuePortal: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/continue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the current portal.
         * @summary Delete a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortal: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current portal.
         * @summary Get a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the full absolute path to the current portal.
         * @summary Get a path to the portal
         * @param {string} [virtualPath] Portal virtual path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullAbsolutePath: async (virtualPath?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/path`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (virtualPath !== undefined) {
                localVarQueryParameter['virtualPath'] = virtualPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends the instructions to remove the current portal.
         * @summary Send removal instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDeleteInstructions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends the instructions to suspend the current portal.
         * @summary Send suspension instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSuspendInstructions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/suspend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates the current portal.
         * @summary Deactivate a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendPortal: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/suspend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortalSettingsApi - functional programming interface
 * @export
 */
export const PortalSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortalSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Restores the current portal.
         * @summary Restore a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continuePortal(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continuePortal(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalSettingsApi.continuePortal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the current portal.
         * @summary Delete a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePortal(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePortal(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalSettingsApi.deletePortal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current portal.
         * @summary Get a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalSettingsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the full absolute path to the current portal.
         * @summary Get a path to the portal
         * @param {string} [virtualPath] Portal virtual path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullAbsolutePath(virtualPath?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullAbsolutePath(virtualPath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalSettingsApi.getFullAbsolutePath']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends the instructions to remove the current portal.
         * @summary Send removal instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendDeleteInstructions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendDeleteInstructions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalSettingsApi.sendDeleteInstructions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends the instructions to suspend the current portal.
         * @summary Send suspension instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSuspendInstructions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendSuspendInstructions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalSettingsApi.sendSuspendInstructions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivates the current portal.
         * @summary Deactivate a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suspendPortal(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suspendPortal(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalSettingsApi.suspendPortal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PortalSettingsApi - factory interface
 * @export
 */
export const PortalSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortalSettingsApiFp(configuration)
    return {
        /**
         * Restores the current portal.
         * @summary Restore a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continuePortal(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.continuePortal(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the current portal.
         * @summary Delete a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortal(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.deletePortal(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current portal.
         * @summary Get a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: RawAxiosRequestConfig): AxiosPromise<TenantWrapper> {
            return localVarFp.get(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the full absolute path to the current portal.
         * @summary Get a path to the portal
         * @param {string} [virtualPath] Portal virtual path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullAbsolutePath(virtualPath?: string, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getFullAbsolutePath(virtualPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends the instructions to remove the current portal.
         * @summary Send removal instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDeleteInstructions(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendDeleteInstructions(options).then((request) => request(axios, basePath));
        },
        /**
         * Sends the instructions to suspend the current portal.
         * @summary Send suspension instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSuspendInstructions(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendSuspendInstructions(options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates the current portal.
         * @summary Deactivate a portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendPortal(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.suspendPortal(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortalSettingsApi - object-oriented interface
 * @export
 * @class PortalSettingsApi
 * @extends {BaseAPI}
 */
export class PortalSettingsApi extends BaseAPI {
    /**
     * Restores the current portal.
     * @summary Restore a portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalSettingsApi
     */
    public continuePortal(options?: RawAxiosRequestConfig) {
        return PortalSettingsApiFp(this.configuration).continuePortal(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the current portal.
     * @summary Delete a portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalSettingsApi
     */
    public deletePortal(options?: RawAxiosRequestConfig) {
        return PortalSettingsApiFp(this.configuration).deletePortal(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current portal.
     * @summary Get a portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalSettingsApi
     */
    public get(options?: RawAxiosRequestConfig) {
        return PortalSettingsApiFp(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the full absolute path to the current portal.
     * @summary Get a path to the portal
     * @param {string} [virtualPath] Portal virtual path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalSettingsApi
     */
    public getFullAbsolutePath(virtualPath?: string, options?: RawAxiosRequestConfig) {
        return PortalSettingsApiFp(this.configuration).getFullAbsolutePath(virtualPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends the instructions to remove the current portal.
     * @summary Send removal instructions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalSettingsApi
     */
    public sendDeleteInstructions(options?: RawAxiosRequestConfig) {
        return PortalSettingsApiFp(this.configuration).sendDeleteInstructions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends the instructions to suspend the current portal.
     * @summary Send suspension instructions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalSettingsApi
     */
    public sendSuspendInstructions(options?: RawAxiosRequestConfig) {
        return PortalSettingsApiFp(this.configuration).sendSuspendInstructions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates the current portal.
     * @summary Deactivate a portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalSettingsApi
     */
    public suspendPortal(options?: RawAxiosRequestConfig) {
        return PortalSettingsApiFp(this.configuration).suspendPortal(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PortalUsersApi - axios parameter creator
 * @export
 */
export const PortalUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an invitation link for joining the portal.
         * @summary Get an invitation link
         * @param {EmployeeType} employeeType Employee type (All, RoomAdmin, Guest, DocSpaceAdmin, User)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geInviteLink: async (employeeType: EmployeeType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeType' is not null or undefined
            assertParamExists('geInviteLink', 'employeeType', employeeType)
            const localVarPath = `/api/2.0/portal/users/invite/{employeeType}`
                .replace(`{${"employeeType"}}`, encodeURIComponent(String(employeeType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a user with the ID specified in the request from the current portal.
         * @summary Get a user by ID
         * @param {string} userID User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('getUser', 'userID', userID)
            const localVarPath = `/api/2.0/portal/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a number of portal users.
         * @summary Get a number of portal users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/userscount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a gift message as read.
         * @summary Mark a gift message as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markPresentAsReaded: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/present/mark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends congratulations to the user after registering the portal.
         * @summary Send congratulations
         * @param {string} [userid] User ID
         * @param {string} [key] Email key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCongratulations: async (userid?: string, key?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/portal/sendcongratulations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userid !== undefined) {
                localVarQueryParameter['Userid'] = userid;
            }

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortalUsersApi - functional programming interface
 * @export
 */
export const PortalUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortalUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an invitation link for joining the portal.
         * @summary Get an invitation link
         * @param {EmployeeType} employeeType Employee type (All, RoomAdmin, Guest, DocSpaceAdmin, User)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geInviteLink(employeeType: EmployeeType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geInviteLink(employeeType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalUsersApi.geInviteLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a user with the ID specified in the request from the current portal.
         * @summary Get a user by ID
         * @param {string} userID User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalUsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a number of portal users.
         * @summary Get a number of portal users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Int64Wrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalUsersApi.getUsersCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks a gift message as read.
         * @summary Mark a gift message as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markPresentAsReaded(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markPresentAsReaded(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalUsersApi.markPresentAsReaded']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends congratulations to the user after registering the portal.
         * @summary Send congratulations
         * @param {string} [userid] User ID
         * @param {string} [key] Email key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendCongratulations(userid?: string, key?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendCongratulations(userid, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortalUsersApi.sendCongratulations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PortalUsersApi - factory interface
 * @export
 */
export const PortalUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortalUsersApiFp(configuration)
    return {
        /**
         * Returns an invitation link for joining the portal.
         * @summary Get an invitation link
         * @param {EmployeeType} employeeType Employee type (All, RoomAdmin, Guest, DocSpaceAdmin, User)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geInviteLink(employeeType: EmployeeType, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.geInviteLink(employeeType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a user with the ID specified in the request from the current portal.
         * @summary Get a user by ID
         * @param {string} userID User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<UserInfoWrapper> {
            return localVarFp.getUser(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a number of portal users.
         * @summary Get a number of portal users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCount(options?: RawAxiosRequestConfig): AxiosPromise<Int64Wrapper> {
            return localVarFp.getUsersCount(options).then((request) => request(axios, basePath));
        },
        /**
         * Marks a gift message as read.
         * @summary Mark a gift message as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markPresentAsReaded(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markPresentAsReaded(options).then((request) => request(axios, basePath));
        },
        /**
         * Sends congratulations to the user after registering the portal.
         * @summary Send congratulations
         * @param {string} [userid] User ID
         * @param {string} [key] Email key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCongratulations(userid?: string, key?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendCongratulations(userid, key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortalUsersApi - object-oriented interface
 * @export
 * @class PortalUsersApi
 * @extends {BaseAPI}
 */
export class PortalUsersApi extends BaseAPI {
    /**
     * Returns an invitation link for joining the portal.
     * @summary Get an invitation link
     * @param {EmployeeType} employeeType Employee type (All, RoomAdmin, Guest, DocSpaceAdmin, User)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalUsersApi
     */
    public geInviteLink(employeeType: EmployeeType, options?: RawAxiosRequestConfig) {
        return PortalUsersApiFp(this.configuration).geInviteLink(employeeType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a user with the ID specified in the request from the current portal.
     * @summary Get a user by ID
     * @param {string} userID User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalUsersApi
     */
    public getUser(userID: string, options?: RawAxiosRequestConfig) {
        return PortalUsersApiFp(this.configuration).getUser(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a number of portal users.
     * @summary Get a number of portal users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalUsersApi
     */
    public getUsersCount(options?: RawAxiosRequestConfig) {
        return PortalUsersApiFp(this.configuration).getUsersCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a gift message as read.
     * @summary Mark a gift message as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalUsersApi
     */
    public markPresentAsReaded(options?: RawAxiosRequestConfig) {
        return PortalUsersApiFp(this.configuration).markPresentAsReaded(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends congratulations to the user after registering the portal.
     * @summary Send congratulations
     * @param {string} [userid] User ID
     * @param {string} [key] Email key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortalUsersApi
     */
    public sendCongratulations(userid?: string, key?: string, options?: RawAxiosRequestConfig) {
        return PortalUsersApiFp(this.configuration).sendCongratulations(userid, key, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityActiveConnectionsApi - axios parameter creator
 * @export
 */
export const SecurityActiveConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all the active connections to the portal.
         * @summary Get active connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllActiveConnections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/activeconnections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out from the connection with the ID specified in the request.
         * @summary Log out from the connection
         * @param {number} loginEventId Login event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutActiveConnection: async (loginEventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginEventId' is not null or undefined
            assertParamExists('logOutActiveConnection', 'loginEventId', loginEventId)
            const localVarPath = `/api/2.0/security/activeconnections/logout/{loginEventId}`
                .replace(`{${"loginEventId"}}`, encodeURIComponent(String(loginEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out from all the active connections of the current user and changes their password.
         * @summary Log out and change password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutAllActiveConnectionsChangePassword: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/activeconnections/logoutallchangepassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out from all the active connections of the user with the ID specified in the request.
         * @summary Log out for the user by ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutAllActiveConnectionsForUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('logOutAllActiveConnectionsForUser', 'userId', userId)
            const localVarPath = `/api/2.0/security/activeconnections/logoutall/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out from all the active connections except the current connection.
         * @summary Log out from all connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutAllExceptThisConnection: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/activeconnections/logoutallexceptthis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityActiveConnectionsApi - functional programming interface
 * @export
 */
export const SecurityActiveConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityActiveConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all the active connections to the portal.
         * @summary Get active connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllActiveConnections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveConnectionsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllActiveConnections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityActiveConnectionsApi.getAllActiveConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs out from the connection with the ID specified in the request.
         * @summary Log out from the connection
         * @param {number} loginEventId Login event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logOutActiveConnection(loginEventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logOutActiveConnection(loginEventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityActiveConnectionsApi.logOutActiveConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs out from all the active connections of the current user and changes their password.
         * @summary Log out and change password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logOutAllActiveConnectionsChangePassword(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logOutAllActiveConnectionsChangePassword(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityActiveConnectionsApi.logOutAllActiveConnectionsChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs out from all the active connections of the user with the ID specified in the request.
         * @summary Log out for the user by ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logOutAllActiveConnectionsForUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logOutAllActiveConnectionsForUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityActiveConnectionsApi.logOutAllActiveConnectionsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs out from all the active connections except the current connection.
         * @summary Log out from all connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logOutAllExceptThisConnection(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logOutAllExceptThisConnection(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityActiveConnectionsApi.logOutAllExceptThisConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityActiveConnectionsApi - factory interface
 * @export
 */
export const SecurityActiveConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityActiveConnectionsApiFp(configuration)
    return {
        /**
         * Returns all the active connections to the portal.
         * @summary Get active connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllActiveConnections(options?: RawAxiosRequestConfig): AxiosPromise<ActiveConnectionsWrapper> {
            return localVarFp.getAllActiveConnections(options).then((request) => request(axios, basePath));
        },
        /**
         * Logs out from the connection with the ID specified in the request.
         * @summary Log out from the connection
         * @param {number} loginEventId Login event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutActiveConnection(loginEventId: number, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.logOutActiveConnection(loginEventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Logs out from all the active connections of the current user and changes their password.
         * @summary Log out and change password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutAllActiveConnectionsChangePassword(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.logOutAllActiveConnectionsChangePassword(options).then((request) => request(axios, basePath));
        },
        /**
         * Logs out from all the active connections of the user with the ID specified in the request.
         * @summary Log out for the user by ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutAllActiveConnectionsForUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logOutAllActiveConnectionsForUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Logs out from all the active connections except the current connection.
         * @summary Log out from all connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logOutAllExceptThisConnection(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.logOutAllExceptThisConnection(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityActiveConnectionsApi - object-oriented interface
 * @export
 * @class SecurityActiveConnectionsApi
 * @extends {BaseAPI}
 */
export class SecurityActiveConnectionsApi extends BaseAPI {
    /**
     * Returns all the active connections to the portal.
     * @summary Get active connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityActiveConnectionsApi
     */
    public getAllActiveConnections(options?: RawAxiosRequestConfig) {
        return SecurityActiveConnectionsApiFp(this.configuration).getAllActiveConnections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs out from the connection with the ID specified in the request.
     * @summary Log out from the connection
     * @param {number} loginEventId Login event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityActiveConnectionsApi
     */
    public logOutActiveConnection(loginEventId: number, options?: RawAxiosRequestConfig) {
        return SecurityActiveConnectionsApiFp(this.configuration).logOutActiveConnection(loginEventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs out from all the active connections of the current user and changes their password.
     * @summary Log out and change password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityActiveConnectionsApi
     */
    public logOutAllActiveConnectionsChangePassword(options?: RawAxiosRequestConfig) {
        return SecurityActiveConnectionsApiFp(this.configuration).logOutAllActiveConnectionsChangePassword(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs out from all the active connections of the user with the ID specified in the request.
     * @summary Log out for the user by ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityActiveConnectionsApi
     */
    public logOutAllActiveConnectionsForUser(userId: string, options?: RawAxiosRequestConfig) {
        return SecurityActiveConnectionsApiFp(this.configuration).logOutAllActiveConnectionsForUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs out from all the active connections except the current connection.
     * @summary Log out from all connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityActiveConnectionsApi
     */
    public logOutAllExceptThisConnection(options?: RawAxiosRequestConfig) {
        return SecurityActiveConnectionsApiFp(this.configuration).logOutAllExceptThisConnection(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityAuditTrailDataApi - axios parameter creator
 * @export
 */
export const SecurityAuditTrailDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates the audit trail report.
         * @summary Generate the audit trail report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuditTrailReport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/events/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the audit events by the parameters specified in the request.
         * @summary Get filtered audit trail data
         * @param {string} [userId] User ID
         * @param {ProductType} [productType] Product
         * @param {ModuleType} [moduleType] Module
         * @param {ActionType} [actionType] Action type
         * @param {MessageAction} [action] Action
         * @param {EntryType} [entryType] Entry
         * @param {string} [target] Target
         * @param {ApiDateTime} [from] Start date
         * @param {ApiDateTime} [to] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditEventsByFilter: async (userId?: string, productType?: ProductType, moduleType?: ModuleType, actionType?: ActionType, action?: MessageAction, entryType?: EntryType, target?: string, from?: ApiDateTime, to?: ApiDateTime, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/events/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (productType !== undefined) {
                localVarQueryParameter['productType'] = productType;
            }

            if (moduleType !== undefined) {
                localVarQueryParameter['moduleType'] = moduleType;
            }

            if (actionType !== undefined) {
                localVarQueryParameter['actionType'] = actionType;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (entryType !== undefined) {
                localVarQueryParameter['entryType'] = entryType;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }

            if (from !== undefined) {
                for (const [key, value] of Object.entries(from)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (to !== undefined) {
                for (const [key, value] of Object.entries(to)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the audit trail settings.
         * @summary Get the audit trail settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/settings/lifetime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the latest changes (creation, modification, deletion, etc.) made by users to the entities (tasks, opportunities, files, etc.) on the portal.
         * @summary Get audit trail data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAuditEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/events/last`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the mappers for the audit trail types.
         * @summary Get audit trail mappers
         * @param {ProductType} [productType] Product
         * @param {ModuleType} [moduleType] Module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMappers: async (productType?: ProductType, moduleType?: ModuleType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/mappers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (productType !== undefined) {
                localVarQueryParameter['productType'] = productType;
            }

            if (moduleType !== undefined) {
                localVarQueryParameter['moduleType'] = moduleType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the available audit trail types.
         * @summary Get audit trail types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the audit trail settings for the current portal.
         * @summary Set the audit trail settings
         * @param {TenantAuditSettingsWrapper} [tenantAuditSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAuditSettings: async (tenantAuditSettingsWrapper?: TenantAuditSettingsWrapper, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/settings/lifetime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantAuditSettingsWrapper, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityAuditTrailDataApi - functional programming interface
 * @export
 */
export const SecurityAuditTrailDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityAuditTrailDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates the audit trail report.
         * @summary Generate the audit trail report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuditTrailReport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuditTrailReport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityAuditTrailDataApi.createAuditTrailReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the audit events by the parameters specified in the request.
         * @summary Get filtered audit trail data
         * @param {string} [userId] User ID
         * @param {ProductType} [productType] Product
         * @param {ModuleType} [moduleType] Module
         * @param {ActionType} [actionType] Action type
         * @param {MessageAction} [action] Action
         * @param {EntryType} [entryType] Entry
         * @param {string} [target] Target
         * @param {ApiDateTime} [from] Start date
         * @param {ApiDateTime} [to] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditEventsByFilter(userId?: string, productType?: ProductType, moduleType?: ModuleType, actionType?: ActionType, action?: MessageAction, entryType?: EntryType, target?: string, from?: ApiDateTime, to?: ApiDateTime, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditEventArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditEventsByFilter(userId, productType, moduleType, actionType, action, entryType, target, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityAuditTrailDataApi.getAuditEventsByFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the audit trail settings.
         * @summary Get the audit trail settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantAuditSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityAuditTrailDataApi.getAuditSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the latest changes (creation, modification, deletion, etc.) made by users to the entities (tasks, opportunities, files, etc.) on the portal.
         * @summary Get audit trail data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastAuditEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditEventArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastAuditEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityAuditTrailDataApi.getLastAuditEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the mappers for the audit trail types.
         * @summary Get audit trail mappers
         * @param {ProductType} [productType] Product
         * @param {ModuleType} [moduleType] Module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMappers(productType?: ProductType, moduleType?: ModuleType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMappers(productType, moduleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityAuditTrailDataApi.getMappers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all the available audit trail types.
         * @summary Get audit trail types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityAuditTrailDataApi.getTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the audit trail settings for the current portal.
         * @summary Set the audit trail settings
         * @param {TenantAuditSettingsWrapper} [tenantAuditSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAuditSettings(tenantAuditSettingsWrapper?: TenantAuditSettingsWrapper, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantAuditSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAuditSettings(tenantAuditSettingsWrapper, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityAuditTrailDataApi.setAuditSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityAuditTrailDataApi - factory interface
 * @export
 */
export const SecurityAuditTrailDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityAuditTrailDataApiFp(configuration)
    return {
        /**
         * Generates the audit trail report.
         * @summary Generate the audit trail report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuditTrailReport(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.createAuditTrailReport(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the audit events by the parameters specified in the request.
         * @summary Get filtered audit trail data
         * @param {string} [userId] User ID
         * @param {ProductType} [productType] Product
         * @param {ModuleType} [moduleType] Module
         * @param {ActionType} [actionType] Action type
         * @param {MessageAction} [action] Action
         * @param {EntryType} [entryType] Entry
         * @param {string} [target] Target
         * @param {ApiDateTime} [from] Start date
         * @param {ApiDateTime} [to] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditEventsByFilter(userId?: string, productType?: ProductType, moduleType?: ModuleType, actionType?: ActionType, action?: MessageAction, entryType?: EntryType, target?: string, from?: ApiDateTime, to?: ApiDateTime, options?: RawAxiosRequestConfig): AxiosPromise<AuditEventArrayWrapper> {
            return localVarFp.getAuditEventsByFilter(userId, productType, moduleType, actionType, action, entryType, target, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the audit trail settings.
         * @summary Get the audit trail settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditSettings(options?: RawAxiosRequestConfig): AxiosPromise<TenantAuditSettingsWrapper> {
            return localVarFp.getAuditSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the latest changes (creation, modification, deletion, etc.) made by users to the entities (tasks, opportunities, files, etc.) on the portal.
         * @summary Get audit trail data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAuditEvents(options?: RawAxiosRequestConfig): AxiosPromise<AuditEventArrayWrapper> {
            return localVarFp.getLastAuditEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the mappers for the audit trail types.
         * @summary Get audit trail mappers
         * @param {ProductType} [productType] Product
         * @param {ModuleType} [moduleType] Module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMappers(productType?: ProductType, moduleType?: ModuleType, options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getMappers(productType, moduleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the available audit trail types.
         * @summary Get audit trail types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTypes(options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the audit trail settings for the current portal.
         * @summary Set the audit trail settings
         * @param {TenantAuditSettingsWrapper} [tenantAuditSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAuditSettings(tenantAuditSettingsWrapper?: TenantAuditSettingsWrapper, options?: RawAxiosRequestConfig): AxiosPromise<TenantAuditSettingsWrapper> {
            return localVarFp.setAuditSettings(tenantAuditSettingsWrapper, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityAuditTrailDataApi - object-oriented interface
 * @export
 * @class SecurityAuditTrailDataApi
 * @extends {BaseAPI}
 */
export class SecurityAuditTrailDataApi extends BaseAPI {
    /**
     * Generates the audit trail report.
     * @summary Generate the audit trail report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityAuditTrailDataApi
     */
    public createAuditTrailReport(options?: RawAxiosRequestConfig) {
        return SecurityAuditTrailDataApiFp(this.configuration).createAuditTrailReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the audit events by the parameters specified in the request.
     * @summary Get filtered audit trail data
     * @param {string} [userId] User ID
     * @param {ProductType} [productType] Product
     * @param {ModuleType} [moduleType] Module
     * @param {ActionType} [actionType] Action type
     * @param {MessageAction} [action] Action
     * @param {EntryType} [entryType] Entry
     * @param {string} [target] Target
     * @param {ApiDateTime} [from] Start date
     * @param {ApiDateTime} [to] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityAuditTrailDataApi
     */
    public getAuditEventsByFilter(userId?: string, productType?: ProductType, moduleType?: ModuleType, actionType?: ActionType, action?: MessageAction, entryType?: EntryType, target?: string, from?: ApiDateTime, to?: ApiDateTime, options?: RawAxiosRequestConfig) {
        return SecurityAuditTrailDataApiFp(this.configuration).getAuditEventsByFilter(userId, productType, moduleType, actionType, action, entryType, target, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the audit trail settings.
     * @summary Get the audit trail settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityAuditTrailDataApi
     */
    public getAuditSettings(options?: RawAxiosRequestConfig) {
        return SecurityAuditTrailDataApiFp(this.configuration).getAuditSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the latest changes (creation, modification, deletion, etc.) made by users to the entities (tasks, opportunities, files, etc.) on the portal.
     * @summary Get audit trail data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityAuditTrailDataApi
     */
    public getLastAuditEvents(options?: RawAxiosRequestConfig) {
        return SecurityAuditTrailDataApiFp(this.configuration).getLastAuditEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the mappers for the audit trail types.
     * @summary Get audit trail mappers
     * @param {ProductType} [productType] Product
     * @param {ModuleType} [moduleType] Module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityAuditTrailDataApi
     */
    public getMappers(productType?: ProductType, moduleType?: ModuleType, options?: RawAxiosRequestConfig) {
        return SecurityAuditTrailDataApiFp(this.configuration).getMappers(productType, moduleType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the available audit trail types.
     * @summary Get audit trail types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityAuditTrailDataApi
     */
    public getTypes(options?: RawAxiosRequestConfig) {
        return SecurityAuditTrailDataApiFp(this.configuration).getTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the audit trail settings for the current portal.
     * @summary Set the audit trail settings
     * @param {TenantAuditSettingsWrapper} [tenantAuditSettingsWrapper] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityAuditTrailDataApi
     */
    public setAuditSettings(tenantAuditSettingsWrapper?: TenantAuditSettingsWrapper, options?: RawAxiosRequestConfig) {
        return SecurityAuditTrailDataApiFp(this.configuration).setAuditSettings(tenantAuditSettingsWrapper, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityCSPApi - axios parameter creator
 * @export
 */
export const SecurityCSPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Csp
         * @summary Csp
         * @param {CspRequestsDto} [cspRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csp: async (cspRequestsDto?: CspRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/csp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cspRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets csp
         * @summary Gets csp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/csp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityCSPApi - functional programming interface
 * @export
 */
export const SecurityCSPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityCSPApiAxiosParamCreator(configuration)
    return {
        /**
         * Csp
         * @summary Csp
         * @param {CspRequestsDto} [cspRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async csp(cspRequestsDto?: CspRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CspWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.csp(cspRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityCSPApi.csp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets csp
         * @summary Gets csp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCsp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CspWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCsp(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityCSPApi.getCsp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityCSPApi - factory interface
 * @export
 */
export const SecurityCSPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityCSPApiFp(configuration)
    return {
        /**
         * Csp
         * @summary Csp
         * @param {CspRequestsDto} [cspRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csp(cspRequestsDto?: CspRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<CspWrapper> {
            return localVarFp.csp(cspRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets csp
         * @summary Gets csp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsp(options?: RawAxiosRequestConfig): AxiosPromise<CspWrapper> {
            return localVarFp.getCsp(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityCSPApi - object-oriented interface
 * @export
 * @class SecurityCSPApi
 * @extends {BaseAPI}
 */
export class SecurityCSPApi extends BaseAPI {
    /**
     * Csp
     * @summary Csp
     * @param {CspRequestsDto} [cspRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityCSPApi
     */
    public csp(cspRequestsDto?: CspRequestsDto, options?: RawAxiosRequestConfig) {
        return SecurityCSPApiFp(this.configuration).csp(cspRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets csp
     * @summary Gets csp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityCSPApi
     */
    public getCsp(options?: RawAxiosRequestConfig) {
        return SecurityCSPApiFp(this.configuration).getCsp(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityFirebaseApi - axios parameter creator
 * @export
 */
export const SecurityFirebaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Saves the Firebase device token specified in the request for the Documents application.
         * @summary Save the Documents Firebase device token
         * @param {FirebaseRequestsDto} [firebaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docRegisterPusnNotificationDevice: async (firebaseRequestsDto?: FirebaseRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/push/docregisterdevice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firebaseRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribes to the Documents push notification.
         * @summary Subscribe to Documents push notification
         * @param {FirebaseRequestsDto} [firebaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeDocumentsPushNotification: async (firebaseRequestsDto?: FirebaseRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/push/docsubscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firebaseRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityFirebaseApi - functional programming interface
 * @export
 */
export const SecurityFirebaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityFirebaseApiAxiosParamCreator(configuration)
    return {
        /**
         * Saves the Firebase device token specified in the request for the Documents application.
         * @summary Save the Documents Firebase device token
         * @param {FirebaseRequestsDto} [firebaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async docRegisterPusnNotificationDevice(firebaseRequestsDto?: FirebaseRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireBaseUserWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.docRegisterPusnNotificationDevice(firebaseRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityFirebaseApi.docRegisterPusnNotificationDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subscribes to the Documents push notification.
         * @summary Subscribe to Documents push notification
         * @param {FirebaseRequestsDto} [firebaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeDocumentsPushNotification(firebaseRequestsDto?: FirebaseRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireBaseUserWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeDocumentsPushNotification(firebaseRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityFirebaseApi.subscribeDocumentsPushNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityFirebaseApi - factory interface
 * @export
 */
export const SecurityFirebaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityFirebaseApiFp(configuration)
    return {
        /**
         * Saves the Firebase device token specified in the request for the Documents application.
         * @summary Save the Documents Firebase device token
         * @param {FirebaseRequestsDto} [firebaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docRegisterPusnNotificationDevice(firebaseRequestsDto?: FirebaseRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<FireBaseUserWrapper> {
            return localVarFp.docRegisterPusnNotificationDevice(firebaseRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribes to the Documents push notification.
         * @summary Subscribe to Documents push notification
         * @param {FirebaseRequestsDto} [firebaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeDocumentsPushNotification(firebaseRequestsDto?: FirebaseRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<FireBaseUserWrapper> {
            return localVarFp.subscribeDocumentsPushNotification(firebaseRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityFirebaseApi - object-oriented interface
 * @export
 * @class SecurityFirebaseApi
 * @extends {BaseAPI}
 */
export class SecurityFirebaseApi extends BaseAPI {
    /**
     * Saves the Firebase device token specified in the request for the Documents application.
     * @summary Save the Documents Firebase device token
     * @param {FirebaseRequestsDto} [firebaseRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityFirebaseApi
     */
    public docRegisterPusnNotificationDevice(firebaseRequestsDto?: FirebaseRequestsDto, options?: RawAxiosRequestConfig) {
        return SecurityFirebaseApiFp(this.configuration).docRegisterPusnNotificationDevice(firebaseRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscribes to the Documents push notification.
     * @summary Subscribe to Documents push notification
     * @param {FirebaseRequestsDto} [firebaseRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityFirebaseApi
     */
    public subscribeDocumentsPushNotification(firebaseRequestsDto?: FirebaseRequestsDto, options?: RawAxiosRequestConfig) {
        return SecurityFirebaseApiFp(this.configuration).subscribeDocumentsPushNotification(firebaseRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityLoginHistoryApi - axios parameter creator
 * @export
 */
export const SecurityLoginHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates the login history report.
         * @summary Generate the login history report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginHistoryReport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/login/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the latest user login activity, including successful logins and error logs.
         * @summary Get login history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastLoginEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/login/last`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the login events by the parameters specified in the request.
         * @summary Get filtered login events
         * @param {string} [userId] User ID
         * @param {MessageAction} [action] Action
         * @param {ApiDateTime} [from] Start date
         * @param {ApiDateTime} [to] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginEventsByFilter: async (userId?: string, action?: MessageAction, from?: ApiDateTime, to?: ApiDateTime, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/security/audit/login/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (from !== undefined) {
                for (const [key, value] of Object.entries(from)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (to !== undefined) {
                for (const [key, value] of Object.entries(to)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityLoginHistoryApi - functional programming interface
 * @export
 */
export const SecurityLoginHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityLoginHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates the login history report.
         * @summary Generate the login history report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLoginHistoryReport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLoginHistoryReport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityLoginHistoryApi.createLoginHistoryReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all the latest user login activity, including successful logins and error logs.
         * @summary Get login history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastLoginEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginEventArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastLoginEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityLoginHistoryApi.getLastLoginEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the login events by the parameters specified in the request.
         * @summary Get filtered login events
         * @param {string} [userId] User ID
         * @param {MessageAction} [action] Action
         * @param {ApiDateTime} [from] Start date
         * @param {ApiDateTime} [to] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginEventsByFilter(userId?: string, action?: MessageAction, from?: ApiDateTime, to?: ApiDateTime, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginEventArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginEventsByFilter(userId, action, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityLoginHistoryApi.getLoginEventsByFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityLoginHistoryApi - factory interface
 * @export
 */
export const SecurityLoginHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityLoginHistoryApiFp(configuration)
    return {
        /**
         * Generates the login history report.
         * @summary Generate the login history report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginHistoryReport(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.createLoginHistoryReport(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the latest user login activity, including successful logins and error logs.
         * @summary Get login history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastLoginEvents(options?: RawAxiosRequestConfig): AxiosPromise<LoginEventArrayWrapper> {
            return localVarFp.getLastLoginEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the login events by the parameters specified in the request.
         * @summary Get filtered login events
         * @param {string} [userId] User ID
         * @param {MessageAction} [action] Action
         * @param {ApiDateTime} [from] Start date
         * @param {ApiDateTime} [to] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginEventsByFilter(userId?: string, action?: MessageAction, from?: ApiDateTime, to?: ApiDateTime, options?: RawAxiosRequestConfig): AxiosPromise<LoginEventArrayWrapper> {
            return localVarFp.getLoginEventsByFilter(userId, action, from, to, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityLoginHistoryApi - object-oriented interface
 * @export
 * @class SecurityLoginHistoryApi
 * @extends {BaseAPI}
 */
export class SecurityLoginHistoryApi extends BaseAPI {
    /**
     * Generates the login history report.
     * @summary Generate the login history report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityLoginHistoryApi
     */
    public createLoginHistoryReport(options?: RawAxiosRequestConfig) {
        return SecurityLoginHistoryApiFp(this.configuration).createLoginHistoryReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the latest user login activity, including successful logins and error logs.
     * @summary Get login history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityLoginHistoryApi
     */
    public getLastLoginEvents(options?: RawAxiosRequestConfig) {
        return SecurityLoginHistoryApiFp(this.configuration).getLastLoginEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the login events by the parameters specified in the request.
     * @summary Get filtered login events
     * @param {string} [userId] User ID
     * @param {MessageAction} [action] Action
     * @param {ApiDateTime} [from] Start date
     * @param {ApiDateTime} [to] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityLoginHistoryApi
     */
    public getLoginEventsByFilter(userId?: string, action?: MessageAction, from?: ApiDateTime, to?: ApiDateTime, options?: RawAxiosRequestConfig) {
        return SecurityLoginHistoryApiFp(this.configuration).getLoginEventsByFilter(userId, action, from, to, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecuritySMTPSettingsApi - axios parameter creator
 * @export
 */
export const SecuritySMTPSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the SMTP test process status.
         * @summary Get the SMTP test process status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmtpOperationStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/smtpsettings/smtp/test/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current portal SMTP settings.
         * @summary Get the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmtpSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/smtpsettings/smtp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the SMTP settings of the current portal.
         * @summary Reset the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSmtpSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/smtpsettings/smtp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the SMTP settings for the current portal.
         * @summary Save the SMTP settings
         * @param {SmtpSettingsDto} [smtpSettingsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSmtpSettings: async (smtpSettingsDto?: SmtpSettingsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/smtpsettings/smtp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smtpSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the SMTP settings for the current portal (sends test message to the user email).
         * @summary Test the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSmtpSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/smtpsettings/smtp/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecuritySMTPSettingsApi - functional programming interface
 * @export
 */
export const SecuritySMTPSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecuritySMTPSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the SMTP test process status.
         * @summary Get the SMTP test process status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSmtpOperationStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmtpOperationStatusRequestsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmtpOperationStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecuritySMTPSettingsApi.getSmtpOperationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current portal SMTP settings.
         * @summary Get the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSmtpSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmtpSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmtpSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecuritySMTPSettingsApi.getSmtpSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the SMTP settings of the current portal.
         * @summary Reset the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetSmtpSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmtpSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetSmtpSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecuritySMTPSettingsApi.resetSmtpSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the SMTP settings for the current portal.
         * @summary Save the SMTP settings
         * @param {SmtpSettingsDto} [smtpSettingsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveSmtpSettings(smtpSettingsDto?: SmtpSettingsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmtpSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveSmtpSettings(smtpSettingsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecuritySMTPSettingsApi.saveSmtpSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Tests the SMTP settings for the current portal (sends test message to the user email).
         * @summary Test the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testSmtpSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmtpOperationStatusRequestsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSmtpSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecuritySMTPSettingsApi.testSmtpSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecuritySMTPSettingsApi - factory interface
 * @export
 */
export const SecuritySMTPSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecuritySMTPSettingsApiFp(configuration)
    return {
        /**
         * Returns the SMTP test process status.
         * @summary Get the SMTP test process status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmtpOperationStatus(options?: RawAxiosRequestConfig): AxiosPromise<SmtpOperationStatusRequestsWrapper> {
            return localVarFp.getSmtpOperationStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current portal SMTP settings.
         * @summary Get the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmtpSettings(options?: RawAxiosRequestConfig): AxiosPromise<SmtpSettingsWrapper> {
            return localVarFp.getSmtpSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the SMTP settings of the current portal.
         * @summary Reset the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSmtpSettings(options?: RawAxiosRequestConfig): AxiosPromise<SmtpSettingsWrapper> {
            return localVarFp.resetSmtpSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the SMTP settings for the current portal.
         * @summary Save the SMTP settings
         * @param {SmtpSettingsDto} [smtpSettingsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSmtpSettings(smtpSettingsDto?: SmtpSettingsDto, options?: RawAxiosRequestConfig): AxiosPromise<SmtpSettingsWrapper> {
            return localVarFp.saveSmtpSettings(smtpSettingsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Tests the SMTP settings for the current portal (sends test message to the user email).
         * @summary Test the SMTP settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSmtpSettings(options?: RawAxiosRequestConfig): AxiosPromise<SmtpOperationStatusRequestsWrapper> {
            return localVarFp.testSmtpSettings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecuritySMTPSettingsApi - object-oriented interface
 * @export
 * @class SecuritySMTPSettingsApi
 * @extends {BaseAPI}
 */
export class SecuritySMTPSettingsApi extends BaseAPI {
    /**
     * Returns the SMTP test process status.
     * @summary Get the SMTP test process status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecuritySMTPSettingsApi
     */
    public getSmtpOperationStatus(options?: RawAxiosRequestConfig) {
        return SecuritySMTPSettingsApiFp(this.configuration).getSmtpOperationStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current portal SMTP settings.
     * @summary Get the SMTP settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecuritySMTPSettingsApi
     */
    public getSmtpSettings(options?: RawAxiosRequestConfig) {
        return SecuritySMTPSettingsApiFp(this.configuration).getSmtpSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the SMTP settings of the current portal.
     * @summary Reset the SMTP settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecuritySMTPSettingsApi
     */
    public resetSmtpSettings(options?: RawAxiosRequestConfig) {
        return SecuritySMTPSettingsApiFp(this.configuration).resetSmtpSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the SMTP settings for the current portal.
     * @summary Save the SMTP settings
     * @param {SmtpSettingsDto} [smtpSettingsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecuritySMTPSettingsApi
     */
    public saveSmtpSettings(smtpSettingsDto?: SmtpSettingsDto, options?: RawAxiosRequestConfig) {
        return SecuritySMTPSettingsApiFp(this.configuration).saveSmtpSettings(smtpSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the SMTP settings for the current portal (sends test message to the user email).
     * @summary Test the SMTP settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecuritySMTPSettingsApi
     */
    public testSmtpSettings(options?: RawAxiosRequestConfig) {
        return SecuritySMTPSettingsApiFp(this.configuration).testSmtpSettings(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsAuthorizationApi - axios parameter creator
 * @export
 */
export const SettingsAuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the authorization services.
         * @summary Get the authorization services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthServices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/authservice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the authorization keys.
         * @summary Save the authorization keys
         * @param {AuthServiceRequestsDto} [authServiceRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAuthKeys: async (authServiceRequestsDto?: AuthServiceRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/authservice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authServiceRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsAuthorizationApi - functional programming interface
 * @export
 */
export const SettingsAuthorizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsAuthorizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the authorization services.
         * @summary Get the authorization services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthServices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthServiceRequestsArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthServices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsAuthorizationApi.getAuthServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the authorization keys.
         * @summary Save the authorization keys
         * @param {AuthServiceRequestsDto} [authServiceRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAuthKeys(authServiceRequestsDto?: AuthServiceRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAuthKeys(authServiceRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsAuthorizationApi.saveAuthKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsAuthorizationApi - factory interface
 * @export
 */
export const SettingsAuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsAuthorizationApiFp(configuration)
    return {
        /**
         * Returns the authorization services.
         * @summary Get the authorization services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthServices(options?: RawAxiosRequestConfig): AxiosPromise<AuthServiceRequestsArrayWrapper> {
            return localVarFp.getAuthServices(options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the authorization keys.
         * @summary Save the authorization keys
         * @param {AuthServiceRequestsDto} [authServiceRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAuthKeys(authServiceRequestsDto?: AuthServiceRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.saveAuthKeys(authServiceRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsAuthorizationApi - object-oriented interface
 * @export
 * @class SettingsAuthorizationApi
 * @extends {BaseAPI}
 */
export class SettingsAuthorizationApi extends BaseAPI {
    /**
     * Returns the authorization services.
     * @summary Get the authorization services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsAuthorizationApi
     */
    public getAuthServices(options?: RawAxiosRequestConfig) {
        return SettingsAuthorizationApiFp(this.configuration).getAuthServices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the authorization keys.
     * @summary Save the authorization keys
     * @param {AuthServiceRequestsDto} [authServiceRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsAuthorizationApi
     */
    public saveAuthKeys(authServiceRequestsDto?: AuthServiceRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsAuthorizationApiFp(this.configuration).saveAuthKeys(authServiceRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsCommonSettingsApi - axios parameter creator
 * @export
 */
export const SettingsCommonSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Closes the admin helper notification.
         * @summary Close the admin helper notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAdminHelper: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/closeadminhelper`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes the Wizard settings.
         * @summary Complete the Wizard settings
         * @param {WizardRequestsDto} [wizardRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWizard: async (wizardRequestsDto?: WizardRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/wizard/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wizardRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the portal color theme with the ID specified in the request.
         * @summary Delete a color theme
         * @param {number} [id] Portal theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteColorTheme: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/colortheme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the portal color theme.
         * @summary Get a color theme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColorTheme: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/colortheme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the portal logo image URL.
         * @summary Get a portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/logo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the portal hostname.
         * @summary Get hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMachineName: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/machine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the available portal settings with the current values for each parameter.
         * @summary Get the portal settings
         * @param {boolean} [withpassword] Specifies if the password hasher settings will be returned or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (withpassword?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withpassword !== undefined) {
                localVarQueryParameter['withpassword'] = withpassword;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the socket settings.
         * @summary Get the socket settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocketSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/socket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the available portal languages in the format of a two-letter or four-letter language code (e.g. \"de\", \"en-US\", etc.).
         * @summary Get supported languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedCultures: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/cultures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the available portal time zones.
         * @summary Get time zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeZonesAsync: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/timezones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deeplink settings
         * @summary Gets deeplink settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettDeepLinkSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/deeplink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the portal payment settings.
         * @summary Get the payment settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the portal color theme specified in the request.
         * @summary Save a color theme
         * @param {CustomColorThemesSettingsRequestsDto} [customColorThemesSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveColorTheme: async (customColorThemesSettingsRequestsDto?: CustomColorThemesSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/colortheme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customColorThemesSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the deep link configuration settings for the portal.
         * @summary Configure deep link settings
         * @param {DeepLinkConfigurationRequestsDto} [deepLinkConfigurationRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveConfigureDeepLink: async (deepLinkConfigurationRequestsDto?: DeepLinkConfigurationRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/deeplink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deepLinkConfigurationRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the DNS settings specified in the request to the current portal.
         * @summary Save the DNS settings
         * @param {DnsSettingsRequestsDto} [dnsSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDnsSettings: async (dnsSettingsRequestsDto?: DnsSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/dns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dnsSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the mail domain settings specified in the request to the portal.
         * @summary Save the mail domain settings
         * @param {MailDomainSettingsRequestsDto} [mailDomainSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveMailDomainSettings: async (mailDomainSettingsRequestsDto?: MailDomainSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/maildomainsettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mailDomainSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the email activation settings.
         * @summary Update the email activation settings
         * @param {EmailActivationSettings} [emailActivationSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailActivationSettings: async (emailActivationSettings?: EmailActivationSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/emailactivation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailActivationSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsCommonSettingsApi - functional programming interface
 * @export
 */
export const SettingsCommonSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsCommonSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Closes the admin helper notification.
         * @summary Close the admin helper notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeAdminHelper(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeAdminHelper(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.closeAdminHelper']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completes the Wizard settings.
         * @summary Complete the Wizard settings
         * @param {WizardRequestsDto} [wizardRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeWizard(wizardRequestsDto?: WizardRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WizardSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWizard(wizardRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.completeWizard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the portal color theme with the ID specified in the request.
         * @summary Delete a color theme
         * @param {number} [id] Portal theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteColorTheme(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomColorThemesSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteColorTheme(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.deleteColorTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the portal color theme.
         * @summary Get a color theme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getColorTheme(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomColorThemesSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getColorTheme(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.getColorTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the portal logo image URL.
         * @summary Get a portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.getLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the portal hostname.
         * @summary Get hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMachineName(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMachineName(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.getMachineName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the available portal settings with the current values for each parameter.
         * @summary Get the portal settings
         * @param {boolean} [withpassword] Specifies if the password hasher settings will be returned or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(withpassword?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(withpassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.getSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the socket settings.
         * @summary Get the socket settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocketSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocketSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.getSocketSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the available portal languages in the format of a two-letter or four-letter language code (e.g. \"de\", \"en-US\", etc.).
         * @summary Get supported languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportedCultures(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<STRINGArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedCultures(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.getSupportedCultures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the available portal time zones.
         * @summary Get time zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeZonesAsync(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimezonesRequestsArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeZonesAsync(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.getTimeZonesAsync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets deeplink settings
         * @summary Gets deeplink settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gettDeepLinkSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantDeepLinkSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gettDeepLinkSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.gettDeepLinkSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the portal payment settings.
         * @summary Get the payment settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.paymentSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the portal color theme specified in the request.
         * @summary Save a color theme
         * @param {CustomColorThemesSettingsRequestsDto} [customColorThemesSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveColorTheme(customColorThemesSettingsRequestsDto?: CustomColorThemesSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomColorThemesSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveColorTheme(customColorThemesSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.saveColorTheme']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the deep link configuration settings for the portal.
         * @summary Configure deep link settings
         * @param {DeepLinkConfigurationRequestsDto} [deepLinkConfigurationRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveConfigureDeepLink(deepLinkConfigurationRequestsDto?: DeepLinkConfigurationRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantDeepLinkSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveConfigureDeepLink(deepLinkConfigurationRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.saveConfigureDeepLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the DNS settings specified in the request to the current portal.
         * @summary Save the DNS settings
         * @param {DnsSettingsRequestsDto} [dnsSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveDnsSettings(dnsSettingsRequestsDto?: DnsSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveDnsSettings(dnsSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.saveDnsSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the mail domain settings specified in the request to the portal.
         * @summary Save the mail domain settings
         * @param {MailDomainSettingsRequestsDto} [mailDomainSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveMailDomainSettings(mailDomainSettingsRequestsDto?: MailDomainSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveMailDomainSettings(mailDomainSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.saveMailDomainSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the email activation settings.
         * @summary Update the email activation settings
         * @param {EmailActivationSettings} [emailActivationSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailActivationSettings(emailActivationSettings?: EmailActivationSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailActivationSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailActivationSettings(emailActivationSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCommonSettingsApi.updateEmailActivationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsCommonSettingsApi - factory interface
 * @export
 */
export const SettingsCommonSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsCommonSettingsApiFp(configuration)
    return {
        /**
         * Closes the admin helper notification.
         * @summary Close the admin helper notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAdminHelper(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.closeAdminHelper(options).then((request) => request(axios, basePath));
        },
        /**
         * Completes the Wizard settings.
         * @summary Complete the Wizard settings
         * @param {WizardRequestsDto} [wizardRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWizard(wizardRequestsDto?: WizardRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<WizardSettingsWrapper> {
            return localVarFp.completeWizard(wizardRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the portal color theme with the ID specified in the request.
         * @summary Delete a color theme
         * @param {number} [id] Portal theme ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteColorTheme(id?: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomColorThemesSettingsWrapper> {
            return localVarFp.deleteColorTheme(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the portal color theme.
         * @summary Get a color theme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColorTheme(options?: RawAxiosRequestConfig): AxiosPromise<CustomColorThemesSettingsWrapper> {
            return localVarFp.getColorTheme(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the portal logo image URL.
         * @summary Get a portal logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogo(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.getLogo(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the portal hostname.
         * @summary Get hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMachineName(options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getMachineName(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the available portal settings with the current values for each parameter.
         * @summary Get the portal settings
         * @param {boolean} [withpassword] Specifies if the password hasher settings will be returned or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(withpassword?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SettingsWrapper> {
            return localVarFp.getSettings(withpassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the socket settings.
         * @summary Get the socket settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocketSettings(options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getSocketSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the available portal languages in the format of a two-letter or four-letter language code (e.g. \"de\", \"en-US\", etc.).
         * @summary Get supported languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedCultures(options?: RawAxiosRequestConfig): AxiosPromise<STRINGArrayWrapper> {
            return localVarFp.getSupportedCultures(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the available portal time zones.
         * @summary Get time zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeZonesAsync(options?: RawAxiosRequestConfig): AxiosPromise<TimezonesRequestsArrayWrapper> {
            return localVarFp.getTimeZonesAsync(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets deeplink settings
         * @summary Gets deeplink settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettDeepLinkSettings(options?: RawAxiosRequestConfig): AxiosPromise<TenantDeepLinkSettingsWrapper> {
            return localVarFp.gettDeepLinkSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the portal payment settings.
         * @summary Get the payment settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSettings(options?: RawAxiosRequestConfig): AxiosPromise<PaymentSettingsWrapper> {
            return localVarFp.paymentSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the portal color theme specified in the request.
         * @summary Save a color theme
         * @param {CustomColorThemesSettingsRequestsDto} [customColorThemesSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveColorTheme(customColorThemesSettingsRequestsDto?: CustomColorThemesSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<CustomColorThemesSettingsWrapper> {
            return localVarFp.saveColorTheme(customColorThemesSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the deep link configuration settings for the portal.
         * @summary Configure deep link settings
         * @param {DeepLinkConfigurationRequestsDto} [deepLinkConfigurationRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveConfigureDeepLink(deepLinkConfigurationRequestsDto?: DeepLinkConfigurationRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<TenantDeepLinkSettingsWrapper> {
            return localVarFp.saveConfigureDeepLink(deepLinkConfigurationRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the DNS settings specified in the request to the current portal.
         * @summary Save the DNS settings
         * @param {DnsSettingsRequestsDto} [dnsSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDnsSettings(dnsSettingsRequestsDto?: DnsSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.saveDnsSettings(dnsSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the mail domain settings specified in the request to the portal.
         * @summary Save the mail domain settings
         * @param {MailDomainSettingsRequestsDto} [mailDomainSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveMailDomainSettings(mailDomainSettingsRequestsDto?: MailDomainSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.saveMailDomainSettings(mailDomainSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the email activation settings.
         * @summary Update the email activation settings
         * @param {EmailActivationSettings} [emailActivationSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailActivationSettings(emailActivationSettings?: EmailActivationSettings, options?: RawAxiosRequestConfig): AxiosPromise<EmailActivationSettingsWrapper> {
            return localVarFp.updateEmailActivationSettings(emailActivationSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsCommonSettingsApi - object-oriented interface
 * @export
 * @class SettingsCommonSettingsApi
 * @extends {BaseAPI}
 */
export class SettingsCommonSettingsApi extends BaseAPI {
    /**
     * Closes the admin helper notification.
     * @summary Close the admin helper notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public closeAdminHelper(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).closeAdminHelper(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes the Wizard settings.
     * @summary Complete the Wizard settings
     * @param {WizardRequestsDto} [wizardRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public completeWizard(wizardRequestsDto?: WizardRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).completeWizard(wizardRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the portal color theme with the ID specified in the request.
     * @summary Delete a color theme
     * @param {number} [id] Portal theme ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public deleteColorTheme(id?: number, options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).deleteColorTheme(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the portal color theme.
     * @summary Get a color theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public getColorTheme(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).getColorTheme(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the portal logo image URL.
     * @summary Get a portal logo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public getLogo(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).getLogo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the portal hostname.
     * @summary Get hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public getMachineName(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).getMachineName(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the available portal settings with the current values for each parameter.
     * @summary Get the portal settings
     * @param {boolean} [withpassword] Specifies if the password hasher settings will be returned or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public getSettings(withpassword?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).getSettings(withpassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the socket settings.
     * @summary Get the socket settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public getSocketSettings(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).getSocketSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the available portal languages in the format of a two-letter or four-letter language code (e.g. \"de\", \"en-US\", etc.).
     * @summary Get supported languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public getSupportedCultures(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).getSupportedCultures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the available portal time zones.
     * @summary Get time zones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public getTimeZonesAsync(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).getTimeZonesAsync(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets deeplink settings
     * @summary Gets deeplink settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public gettDeepLinkSettings(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).gettDeepLinkSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the portal payment settings.
     * @summary Get the payment settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public paymentSettings(options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).paymentSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the portal color theme specified in the request.
     * @summary Save a color theme
     * @param {CustomColorThemesSettingsRequestsDto} [customColorThemesSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public saveColorTheme(customColorThemesSettingsRequestsDto?: CustomColorThemesSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).saveColorTheme(customColorThemesSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the deep link configuration settings for the portal.
     * @summary Configure deep link settings
     * @param {DeepLinkConfigurationRequestsDto} [deepLinkConfigurationRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public saveConfigureDeepLink(deepLinkConfigurationRequestsDto?: DeepLinkConfigurationRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).saveConfigureDeepLink(deepLinkConfigurationRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the DNS settings specified in the request to the current portal.
     * @summary Save the DNS settings
     * @param {DnsSettingsRequestsDto} [dnsSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public saveDnsSettings(dnsSettingsRequestsDto?: DnsSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).saveDnsSettings(dnsSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the mail domain settings specified in the request to the portal.
     * @summary Save the mail domain settings
     * @param {MailDomainSettingsRequestsDto} [mailDomainSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public saveMailDomainSettings(mailDomainSettingsRequestsDto?: MailDomainSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).saveMailDomainSettings(mailDomainSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the email activation settings.
     * @summary Update the email activation settings
     * @param {EmailActivationSettings} [emailActivationSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCommonSettingsApi
     */
    public updateEmailActivationSettings(emailActivationSettings?: EmailActivationSettings, options?: RawAxiosRequestConfig) {
        return SettingsCommonSettingsApiFp(this.configuration).updateEmailActivationSettings(emailActivationSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsCookiesApi - axios parameter creator
 * @export
 */
export const SettingsCookiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the cookies lifetime value in minutes.
         * @summary Get cookies lifetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCookieSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/cookiesettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the cookies lifetime value in minutes.
         * @summary Update cookies lifetime
         * @param {CookieSettingsRequestsDto} [cookieSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCookieSettings: async (cookieSettingsRequestsDto?: CookieSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/cookiesettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookieSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsCookiesApi - functional programming interface
 * @export
 */
export const SettingsCookiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsCookiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the cookies lifetime value in minutes.
         * @summary Get cookies lifetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCookieSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookieSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCookieSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCookiesApi.getCookieSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the cookies lifetime value in minutes.
         * @summary Update cookies lifetime
         * @param {CookieSettingsRequestsDto} [cookieSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCookieSettings(cookieSettingsRequestsDto?: CookieSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCookieSettings(cookieSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCookiesApi.updateCookieSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsCookiesApi - factory interface
 * @export
 */
export const SettingsCookiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsCookiesApiFp(configuration)
    return {
        /**
         * Returns the cookies lifetime value in minutes.
         * @summary Get cookies lifetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCookieSettings(options?: RawAxiosRequestConfig): AxiosPromise<CookieSettingsWrapper> {
            return localVarFp.getCookieSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the cookies lifetime value in minutes.
         * @summary Update cookies lifetime
         * @param {CookieSettingsRequestsDto} [cookieSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCookieSettings(cookieSettingsRequestsDto?: CookieSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.updateCookieSettings(cookieSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsCookiesApi - object-oriented interface
 * @export
 * @class SettingsCookiesApi
 * @extends {BaseAPI}
 */
export class SettingsCookiesApi extends BaseAPI {
    /**
     * Returns the cookies lifetime value in minutes.
     * @summary Get cookies lifetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCookiesApi
     */
    public getCookieSettings(options?: RawAxiosRequestConfig) {
        return SettingsCookiesApiFp(this.configuration).getCookieSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the cookies lifetime value in minutes.
     * @summary Update cookies lifetime
     * @param {CookieSettingsRequestsDto} [cookieSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCookiesApi
     */
    public updateCookieSettings(cookieSettingsRequestsDto?: CookieSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsCookiesApiFp(this.configuration).updateCookieSettings(cookieSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsCustomNavigationApi - axios parameter creator
 * @export
 */
export const SettingsCustomNavigationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a custom navigation item with the parameters specified in the request.
         * @summary Add a custom navigation item
         * @param {CustomNavigationItem} [customNavigationItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomNavigationItem: async (customNavigationItem?: CustomNavigationItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/customnavigation/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customNavigationItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom navigation item with the ID specified in the request.
         * @summary Delete a custom navigation item
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomNavigationItem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomNavigationItem', 'id', id)
            const localVarPath = `/api/2.0/settings/customnavigation/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a custom navigation item by the ID specified in the request.
         * @summary Get a custom navigation item by ID
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomNavigationItem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomNavigationItem', 'id', id)
            const localVarPath = `/api/2.0/settings/customnavigation/get/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a custom navigation item sample.
         * @summary Get a custom navigation item sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomNavigationItemSample: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/customnavigation/getsample`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the custom navigation items.
         * @summary Get the custom navigation items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomNavigationItems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/customnavigation/getall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsCustomNavigationApi - functional programming interface
 * @export
 */
export const SettingsCustomNavigationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsCustomNavigationApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a custom navigation item with the parameters specified in the request.
         * @summary Add a custom navigation item
         * @param {CustomNavigationItem} [customNavigationItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomNavigationItem(customNavigationItem?: CustomNavigationItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomNavigationItemWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomNavigationItem(customNavigationItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCustomNavigationApi.createCustomNavigationItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a custom navigation item with the ID specified in the request.
         * @summary Delete a custom navigation item
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomNavigationItem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomNavigationItem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCustomNavigationApi.deleteCustomNavigationItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a custom navigation item by the ID specified in the request.
         * @summary Get a custom navigation item by ID
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomNavigationItem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomNavigationItemWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomNavigationItem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCustomNavigationApi.getCustomNavigationItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a custom navigation item sample.
         * @summary Get a custom navigation item sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomNavigationItemSample(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomNavigationItemWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomNavigationItemSample(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCustomNavigationApi.getCustomNavigationItemSample']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the custom navigation items.
         * @summary Get the custom navigation items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomNavigationItems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomNavigationItemArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomNavigationItems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsCustomNavigationApi.getCustomNavigationItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsCustomNavigationApi - factory interface
 * @export
 */
export const SettingsCustomNavigationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsCustomNavigationApiFp(configuration)
    return {
        /**
         * Adds a custom navigation item with the parameters specified in the request.
         * @summary Add a custom navigation item
         * @param {CustomNavigationItem} [customNavigationItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomNavigationItem(customNavigationItem?: CustomNavigationItem, options?: RawAxiosRequestConfig): AxiosPromise<CustomNavigationItemWrapper> {
            return localVarFp.createCustomNavigationItem(customNavigationItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a custom navigation item with the ID specified in the request.
         * @summary Delete a custom navigation item
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomNavigationItem(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomNavigationItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a custom navigation item by the ID specified in the request.
         * @summary Get a custom navigation item by ID
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomNavigationItem(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomNavigationItemWrapper> {
            return localVarFp.getCustomNavigationItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a custom navigation item sample.
         * @summary Get a custom navigation item sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomNavigationItemSample(options?: RawAxiosRequestConfig): AxiosPromise<CustomNavigationItemWrapper> {
            return localVarFp.getCustomNavigationItemSample(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the custom navigation items.
         * @summary Get the custom navigation items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomNavigationItems(options?: RawAxiosRequestConfig): AxiosPromise<CustomNavigationItemArrayWrapper> {
            return localVarFp.getCustomNavigationItems(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsCustomNavigationApi - object-oriented interface
 * @export
 * @class SettingsCustomNavigationApi
 * @extends {BaseAPI}
 */
export class SettingsCustomNavigationApi extends BaseAPI {
    /**
     * Adds a custom navigation item with the parameters specified in the request.
     * @summary Add a custom navigation item
     * @param {CustomNavigationItem} [customNavigationItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCustomNavigationApi
     */
    public createCustomNavigationItem(customNavigationItem?: CustomNavigationItem, options?: RawAxiosRequestConfig) {
        return SettingsCustomNavigationApiFp(this.configuration).createCustomNavigationItem(customNavigationItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a custom navigation item with the ID specified in the request.
     * @summary Delete a custom navigation item
     * @param {string} id Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCustomNavigationApi
     */
    public deleteCustomNavigationItem(id: string, options?: RawAxiosRequestConfig) {
        return SettingsCustomNavigationApiFp(this.configuration).deleteCustomNavigationItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a custom navigation item by the ID specified in the request.
     * @summary Get a custom navigation item by ID
     * @param {string} id Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCustomNavigationApi
     */
    public getCustomNavigationItem(id: string, options?: RawAxiosRequestConfig) {
        return SettingsCustomNavigationApiFp(this.configuration).getCustomNavigationItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a custom navigation item sample.
     * @summary Get a custom navigation item sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCustomNavigationApi
     */
    public getCustomNavigationItemSample(options?: RawAxiosRequestConfig) {
        return SettingsCustomNavigationApiFp(this.configuration).getCustomNavigationItemSample(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the custom navigation items.
     * @summary Get the custom navigation items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsCustomNavigationApi
     */
    public getCustomNavigationItems(options?: RawAxiosRequestConfig) {
        return SettingsCustomNavigationApiFp(this.configuration).getCustomNavigationItems(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsEncryptionApi - axios parameter creator
 * @export
 */
export const SettingsEncryptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the storage encryption progress.
         * @summary Get the storage encryption progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageEncryptionProgress: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/encryption/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the storage encryption process.
         * @summary Start the storage encryption process
         * @param {StorageEncryptionRequestsDto} [storageEncryptionRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startStorageEncryption: async (storageEncryptionRequestsDto?: StorageEncryptionRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/encryption/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageEncryptionRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsEncryptionApi - functional programming interface
 * @export
 */
export const SettingsEncryptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsEncryptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the storage encryption progress.
         * @summary Get the storage encryption progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageEncryptionProgress(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoubleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageEncryptionProgress(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsEncryptionApi.getStorageEncryptionProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the storage encryption process.
         * @summary Start the storage encryption process
         * @param {StorageEncryptionRequestsDto} [storageEncryptionRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startStorageEncryption(storageEncryptionRequestsDto?: StorageEncryptionRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startStorageEncryption(storageEncryptionRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsEncryptionApi.startStorageEncryption']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsEncryptionApi - factory interface
 * @export
 */
export const SettingsEncryptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsEncryptionApiFp(configuration)
    return {
        /**
         * Returns the storage encryption progress.
         * @summary Get the storage encryption progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageEncryptionProgress(options?: RawAxiosRequestConfig): AxiosPromise<DoubleWrapper> {
            return localVarFp.getStorageEncryptionProgress(options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the storage encryption process.
         * @summary Start the storage encryption process
         * @param {StorageEncryptionRequestsDto} [storageEncryptionRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startStorageEncryption(storageEncryptionRequestsDto?: StorageEncryptionRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.startStorageEncryption(storageEncryptionRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsEncryptionApi - object-oriented interface
 * @export
 * @class SettingsEncryptionApi
 * @extends {BaseAPI}
 */
export class SettingsEncryptionApi extends BaseAPI {
    /**
     * Returns the storage encryption progress.
     * @summary Get the storage encryption progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsEncryptionApi
     */
    public getStorageEncryptionProgress(options?: RawAxiosRequestConfig) {
        return SettingsEncryptionApiFp(this.configuration).getStorageEncryptionProgress(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the storage encryption process.
     * @summary Start the storage encryption process
     * @param {StorageEncryptionRequestsDto} [storageEncryptionRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsEncryptionApi
     */
    public startStorageEncryption(storageEncryptionRequestsDto?: StorageEncryptionRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsEncryptionApiFp(this.configuration).startStorageEncryption(storageEncryptionRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsGreetingSettingsApi - axios parameter creator
 * @export
 */
export const SettingsGreetingSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the greeting settings for the current portal.
         * @summary Get greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGreetingSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/greetingsettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the greeting settings of the current portal are set to default or not.
         * @summary Check the default greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/greetingsettings/isdefault`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores the current portal greeting settings.
         * @summary Restore the greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreGreetingSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/greetingsettings/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the greeting settings specified in the request to the current portal.
         * @summary Save the greeting settings
         * @param {GreetingSettingsRequestsDto} [greetingSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGreetingSettings: async (greetingSettingsRequestsDto?: GreetingSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/greetingsettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(greetingSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsGreetingSettingsApi - functional programming interface
 * @export
 */
export const SettingsGreetingSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsGreetingSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the greeting settings for the current portal.
         * @summary Get greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGreetingSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGreetingSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsGreetingSettingsApi.getGreetingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the greeting settings of the current portal are set to default or not.
         * @summary Check the default greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsGreetingSettingsApi.isDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restores the current portal greeting settings.
         * @summary Restore the greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreGreetingSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreGreetingSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsGreetingSettingsApi.restoreGreetingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the greeting settings specified in the request to the current portal.
         * @summary Save the greeting settings
         * @param {GreetingSettingsRequestsDto} [greetingSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveGreetingSettings(greetingSettingsRequestsDto?: GreetingSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveGreetingSettings(greetingSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsGreetingSettingsApi.saveGreetingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsGreetingSettingsApi - factory interface
 * @export
 */
export const SettingsGreetingSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsGreetingSettingsApiFp(configuration)
    return {
        /**
         * Returns the greeting settings for the current portal.
         * @summary Get greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGreetingSettings(options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getGreetingSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the greeting settings of the current portal are set to default or not.
         * @summary Check the default greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isDefault(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.isDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * Restores the current portal greeting settings.
         * @summary Restore the greeting settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreGreetingSettings(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.restoreGreetingSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the greeting settings specified in the request to the current portal.
         * @summary Save the greeting settings
         * @param {GreetingSettingsRequestsDto} [greetingSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGreetingSettings(greetingSettingsRequestsDto?: GreetingSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.saveGreetingSettings(greetingSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsGreetingSettingsApi - object-oriented interface
 * @export
 * @class SettingsGreetingSettingsApi
 * @extends {BaseAPI}
 */
export class SettingsGreetingSettingsApi extends BaseAPI {
    /**
     * Returns the greeting settings for the current portal.
     * @summary Get greeting settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsGreetingSettingsApi
     */
    public getGreetingSettings(options?: RawAxiosRequestConfig) {
        return SettingsGreetingSettingsApiFp(this.configuration).getGreetingSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the greeting settings of the current portal are set to default or not.
     * @summary Check the default greeting settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsGreetingSettingsApi
     */
    public isDefault(options?: RawAxiosRequestConfig) {
        return SettingsGreetingSettingsApiFp(this.configuration).isDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores the current portal greeting settings.
     * @summary Restore the greeting settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsGreetingSettingsApi
     */
    public restoreGreetingSettings(options?: RawAxiosRequestConfig) {
        return SettingsGreetingSettingsApiFp(this.configuration).restoreGreetingSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the greeting settings specified in the request to the current portal.
     * @summary Save the greeting settings
     * @param {GreetingSettingsRequestsDto} [greetingSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsGreetingSettingsApi
     */
    public saveGreetingSettings(greetingSettingsRequestsDto?: GreetingSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsGreetingSettingsApiFp(this.configuration).saveGreetingSettings(greetingSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsIPRestrictionsApi - axios parameter creator
 * @export
 */
export const SettingsIPRestrictionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the IP portal restrictions.
         * @summary Get the IP portal restrictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpRestrictions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/iprestrictions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the IP restriction settings.
         * @summary Get the IP restriction settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIpRestrictionsSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/iprestrictions/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the IP restriction settings with a parameter specified in the request.
         * @summary Save the IP restriction settings
         * @param {IpRestrictionsDto} [ipRestrictionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveIpRestrictions: async (ipRestrictionsDto?: IpRestrictionsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/iprestrictions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ipRestrictionsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the IP restriction settings with a parameter specified in the request.
         * @summary Save the IP restriction settings
         * @param {IpRestrictionsDto} [ipRestrictionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIpRestrictionsSettings: async (ipRestrictionsDto?: IpRestrictionsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/iprestrictions/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ipRestrictionsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsIPRestrictionsApi - functional programming interface
 * @export
 */
export const SettingsIPRestrictionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsIPRestrictionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the IP portal restrictions.
         * @summary Get the IP portal restrictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIpRestrictions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPRestrictionArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIpRestrictions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsIPRestrictionsApi.getIpRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the IP restriction settings.
         * @summary Get the IP restriction settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readIpRestrictionsSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPRestrictionsSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readIpRestrictionsSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsIPRestrictionsApi.readIpRestrictionsSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the IP restriction settings with a parameter specified in the request.
         * @summary Save the IP restriction settings
         * @param {IpRestrictionsDto} [ipRestrictionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveIpRestrictions(ipRestrictionsDto?: IpRestrictionsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpRestrictionsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveIpRestrictions(ipRestrictionsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsIPRestrictionsApi.saveIpRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the IP restriction settings with a parameter specified in the request.
         * @summary Save the IP restriction settings
         * @param {IpRestrictionsDto} [ipRestrictionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIpRestrictionsSettings(ipRestrictionsDto?: IpRestrictionsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpRestrictionsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIpRestrictionsSettings(ipRestrictionsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsIPRestrictionsApi.updateIpRestrictionsSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsIPRestrictionsApi - factory interface
 * @export
 */
export const SettingsIPRestrictionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsIPRestrictionsApiFp(configuration)
    return {
        /**
         * Returns the IP portal restrictions.
         * @summary Get the IP portal restrictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpRestrictions(options?: RawAxiosRequestConfig): AxiosPromise<IPRestrictionArrayWrapper> {
            return localVarFp.getIpRestrictions(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the IP restriction settings.
         * @summary Get the IP restriction settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIpRestrictionsSettings(options?: RawAxiosRequestConfig): AxiosPromise<IPRestrictionsSettingsWrapper> {
            return localVarFp.readIpRestrictionsSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the IP restriction settings with a parameter specified in the request.
         * @summary Save the IP restriction settings
         * @param {IpRestrictionsDto} [ipRestrictionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveIpRestrictions(ipRestrictionsDto?: IpRestrictionsDto, options?: RawAxiosRequestConfig): AxiosPromise<IpRestrictionsWrapper> {
            return localVarFp.saveIpRestrictions(ipRestrictionsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the IP restriction settings with a parameter specified in the request.
         * @summary Save the IP restriction settings
         * @param {IpRestrictionsDto} [ipRestrictionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIpRestrictionsSettings(ipRestrictionsDto?: IpRestrictionsDto, options?: RawAxiosRequestConfig): AxiosPromise<IpRestrictionsWrapper> {
            return localVarFp.updateIpRestrictionsSettings(ipRestrictionsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsIPRestrictionsApi - object-oriented interface
 * @export
 * @class SettingsIPRestrictionsApi
 * @extends {BaseAPI}
 */
export class SettingsIPRestrictionsApi extends BaseAPI {
    /**
     * Returns the IP portal restrictions.
     * @summary Get the IP portal restrictions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsIPRestrictionsApi
     */
    public getIpRestrictions(options?: RawAxiosRequestConfig) {
        return SettingsIPRestrictionsApiFp(this.configuration).getIpRestrictions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the IP restriction settings.
     * @summary Get the IP restriction settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsIPRestrictionsApi
     */
    public readIpRestrictionsSettings(options?: RawAxiosRequestConfig) {
        return SettingsIPRestrictionsApiFp(this.configuration).readIpRestrictionsSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the IP restriction settings with a parameter specified in the request.
     * @summary Save the IP restriction settings
     * @param {IpRestrictionsDto} [ipRestrictionsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsIPRestrictionsApi
     */
    public saveIpRestrictions(ipRestrictionsDto?: IpRestrictionsDto, options?: RawAxiosRequestConfig) {
        return SettingsIPRestrictionsApiFp(this.configuration).saveIpRestrictions(ipRestrictionsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the IP restriction settings with a parameter specified in the request.
     * @summary Save the IP restriction settings
     * @param {IpRestrictionsDto} [ipRestrictionsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsIPRestrictionsApi
     */
    public updateIpRestrictionsSettings(ipRestrictionsDto?: IpRestrictionsDto, options?: RawAxiosRequestConfig) {
        return SettingsIPRestrictionsApiFp(this.configuration).updateIpRestrictionsSettings(ipRestrictionsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsLicenseApi - axios parameter creator
 * @export
 */
export const SettingsLicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activates a license for the portal.
         * @summary Activate a license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptLicense: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/license/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refreshes the license.
         * @summary Refresh the license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLicense: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/license/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests a portal license if necessary.
         * @summary Request a license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestLicense: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/license/required`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a portal license specified in the request.
         * @summary Upload a license
         * @param {Array<File>} [files] License attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLicense: async (files?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication asc_auth_key required

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('Files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsLicenseApi - functional programming interface
 * @export
 */
export const SettingsLicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsLicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * Activates a license for the portal.
         * @summary Activate a license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptLicense(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptLicense(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsLicenseApi.acceptLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refreshes the license.
         * @summary Refresh the license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLicense(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLicense(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsLicenseApi.refreshLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requests a portal license if necessary.
         * @summary Request a license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestLicense(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestLicense(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsLicenseApi.requestLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a portal license specified in the request.
         * @summary Upload a license
         * @param {Array<File>} [files] License attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadLicense(files?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadLicense(files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsLicenseApi.uploadLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsLicenseApi - factory interface
 * @export
 */
export const SettingsLicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsLicenseApiFp(configuration)
    return {
        /**
         * Activates a license for the portal.
         * @summary Activate a license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptLicense(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.acceptLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Refreshes the license.
         * @summary Refresh the license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLicense(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.refreshLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Requests a portal license if necessary.
         * @summary Request a license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestLicense(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.requestLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a portal license specified in the request.
         * @summary Upload a license
         * @param {Array<File>} [files] License attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLicense(files?: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.uploadLicense(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsLicenseApi - object-oriented interface
 * @export
 * @class SettingsLicenseApi
 * @extends {BaseAPI}
 */
export class SettingsLicenseApi extends BaseAPI {
    /**
     * Activates a license for the portal.
     * @summary Activate a license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsLicenseApi
     */
    public acceptLicense(options?: RawAxiosRequestConfig) {
        return SettingsLicenseApiFp(this.configuration).acceptLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refreshes the license.
     * @summary Refresh the license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsLicenseApi
     */
    public refreshLicense(options?: RawAxiosRequestConfig) {
        return SettingsLicenseApiFp(this.configuration).refreshLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests a portal license if necessary.
     * @summary Request a license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsLicenseApi
     */
    public requestLicense(options?: RawAxiosRequestConfig) {
        return SettingsLicenseApiFp(this.configuration).requestLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a portal license specified in the request.
     * @summary Upload a license
     * @param {Array<File>} [files] License attachments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsLicenseApi
     */
    public uploadLicense(files?: Array<File>, options?: RawAxiosRequestConfig) {
        return SettingsLicenseApiFp(this.configuration).uploadLicense(files, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsLoginSettingsApi - axios parameter creator
 * @export
 */
export const SettingsLoginSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the portal login settings.
         * @summary Get login settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/loginsettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the portal login settings.
         * @summary Returns the portal login settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultLoginSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/loginsettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the login settings with the parameters specified in the request.
         * @summary Update login settings
         * @param {LoginSettingsRequestDto} [loginSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginSettings: async (loginSettingsRequestDto?: LoginSettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/loginsettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginSettingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsLoginSettingsApi - functional programming interface
 * @export
 */
export const SettingsLoginSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsLoginSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the portal login settings.
         * @summary Get login settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsLoginSettingsApi.getLoginSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the portal login settings.
         * @summary Returns the portal login settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultLoginSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultLoginSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsLoginSettingsApi.setDefaultLoginSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the login settings with the parameters specified in the request.
         * @summary Update login settings
         * @param {LoginSettingsRequestDto} [loginSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoginSettings(loginSettingsRequestDto?: LoginSettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLoginSettings(loginSettingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsLoginSettingsApi.updateLoginSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsLoginSettingsApi - factory interface
 * @export
 */
export const SettingsLoginSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsLoginSettingsApiFp(configuration)
    return {
        /**
         * Returns the portal login settings.
         * @summary Get login settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginSettings(options?: RawAxiosRequestConfig): AxiosPromise<LoginSettingsWrapper> {
            return localVarFp.getLoginSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the portal login settings.
         * @summary Returns the portal login settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultLoginSettings(options?: RawAxiosRequestConfig): AxiosPromise<LoginSettingsWrapper> {
            return localVarFp.setDefaultLoginSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the login settings with the parameters specified in the request.
         * @summary Update login settings
         * @param {LoginSettingsRequestDto} [loginSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginSettings(loginSettingsRequestDto?: LoginSettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginSettingsWrapper> {
            return localVarFp.updateLoginSettings(loginSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsLoginSettingsApi - object-oriented interface
 * @export
 * @class SettingsLoginSettingsApi
 * @extends {BaseAPI}
 */
export class SettingsLoginSettingsApi extends BaseAPI {
    /**
     * Returns the portal login settings.
     * @summary Get login settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsLoginSettingsApi
     */
    public getLoginSettings(options?: RawAxiosRequestConfig) {
        return SettingsLoginSettingsApiFp(this.configuration).getLoginSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the portal login settings.
     * @summary Returns the portal login settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsLoginSettingsApi
     */
    public setDefaultLoginSettings(options?: RawAxiosRequestConfig) {
        return SettingsLoginSettingsApiFp(this.configuration).setDefaultLoginSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the login settings with the parameters specified in the request.
     * @summary Update login settings
     * @param {LoginSettingsRequestDto} [loginSettingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsLoginSettingsApi
     */
    public updateLoginSettings(loginSettingsRequestDto?: LoginSettingsRequestDto, options?: RawAxiosRequestConfig) {
        return SettingsLoginSettingsApiFp(this.configuration).updateLoginSettings(loginSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsMessagesApi - axios parameter creator
 * @export
 */
export const SettingsMessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Displays the contact form on the \"Sign In\" page, allowing users to send a message to the DocSpace administrator in case they encounter any issues while accessing DocSpace.
         * @summary Enable the administrator message settings
         * @param {TurnOnAdminMessageSettingsRequestDto} [turnOnAdminMessageSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableAdminMessageSettings: async (turnOnAdminMessageSettingsRequestDto?: TurnOnAdminMessageSettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/messagesettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(turnOnAdminMessageSettingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a message to the administrator email when unauthorized users encounter issues accessing DocSpace.
         * @summary Send a message to the administrator
         * @param {AdminMessageSettingsRequestsDto} [adminMessageSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAdmMail: async (adminMessageSettingsRequestsDto?: AdminMessageSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/sendadmmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminMessageSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an invitation email with a link to the DocSpace.
         * @summary Sends an invitation email
         * @param {AdminMessageBaseSettingsRequestsDto} [adminMessageBaseSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJoinInviteMail: async (adminMessageBaseSettingsRequestsDto?: AdminMessageBaseSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/sendjoininvite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminMessageBaseSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsMessagesApi - functional programming interface
 * @export
 */
export const SettingsMessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsMessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Displays the contact form on the \"Sign In\" page, allowing users to send a message to the DocSpace administrator in case they encounter any issues while accessing DocSpace.
         * @summary Enable the administrator message settings
         * @param {TurnOnAdminMessageSettingsRequestDto} [turnOnAdminMessageSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableAdminMessageSettings(turnOnAdminMessageSettingsRequestDto?: TurnOnAdminMessageSettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAdminMessageSettings(turnOnAdminMessageSettingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsMessagesApi.enableAdminMessageSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a message to the administrator email when unauthorized users encounter issues accessing DocSpace.
         * @summary Send a message to the administrator
         * @param {AdminMessageSettingsRequestsDto} [adminMessageSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAdmMail(adminMessageSettingsRequestsDto?: AdminMessageSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAdmMail(adminMessageSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsMessagesApi.sendAdmMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an invitation email with a link to the DocSpace.
         * @summary Sends an invitation email
         * @param {AdminMessageBaseSettingsRequestsDto} [adminMessageBaseSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendJoinInviteMail(adminMessageBaseSettingsRequestsDto?: AdminMessageBaseSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendJoinInviteMail(adminMessageBaseSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsMessagesApi.sendJoinInviteMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsMessagesApi - factory interface
 * @export
 */
export const SettingsMessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsMessagesApiFp(configuration)
    return {
        /**
         * Displays the contact form on the \"Sign In\" page, allowing users to send a message to the DocSpace administrator in case they encounter any issues while accessing DocSpace.
         * @summary Enable the administrator message settings
         * @param {TurnOnAdminMessageSettingsRequestDto} [turnOnAdminMessageSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableAdminMessageSettings(turnOnAdminMessageSettingsRequestDto?: TurnOnAdminMessageSettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.enableAdminMessageSettings(turnOnAdminMessageSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a message to the administrator email when unauthorized users encounter issues accessing DocSpace.
         * @summary Send a message to the administrator
         * @param {AdminMessageSettingsRequestsDto} [adminMessageSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAdmMail(adminMessageSettingsRequestsDto?: AdminMessageSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.sendAdmMail(adminMessageSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an invitation email with a link to the DocSpace.
         * @summary Sends an invitation email
         * @param {AdminMessageBaseSettingsRequestsDto} [adminMessageBaseSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJoinInviteMail(adminMessageBaseSettingsRequestsDto?: AdminMessageBaseSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.sendJoinInviteMail(adminMessageBaseSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsMessagesApi - object-oriented interface
 * @export
 * @class SettingsMessagesApi
 * @extends {BaseAPI}
 */
export class SettingsMessagesApi extends BaseAPI {
    /**
     * Displays the contact form on the \"Sign In\" page, allowing users to send a message to the DocSpace administrator in case they encounter any issues while accessing DocSpace.
     * @summary Enable the administrator message settings
     * @param {TurnOnAdminMessageSettingsRequestDto} [turnOnAdminMessageSettingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsMessagesApi
     */
    public enableAdminMessageSettings(turnOnAdminMessageSettingsRequestDto?: TurnOnAdminMessageSettingsRequestDto, options?: RawAxiosRequestConfig) {
        return SettingsMessagesApiFp(this.configuration).enableAdminMessageSettings(turnOnAdminMessageSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a message to the administrator email when unauthorized users encounter issues accessing DocSpace.
     * @summary Send a message to the administrator
     * @param {AdminMessageSettingsRequestsDto} [adminMessageSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsMessagesApi
     */
    public sendAdmMail(adminMessageSettingsRequestsDto?: AdminMessageSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsMessagesApiFp(this.configuration).sendAdmMail(adminMessageSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an invitation email with a link to the DocSpace.
     * @summary Sends an invitation email
     * @param {AdminMessageBaseSettingsRequestsDto} [adminMessageBaseSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsMessagesApi
     */
    public sendJoinInviteMail(adminMessageBaseSettingsRequestsDto?: AdminMessageBaseSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsMessagesApiFp(this.configuration).sendJoinInviteMail(adminMessageBaseSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsNotificationsApi - axios parameter creator
 * @export
 */
export const SettingsNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if the notification type specified in the request is enabled or not.
         * @summary Check notification availability
         * @param {NotificationType} type Notification type (Badges, RoomsActivity, DailyFeed, UsefullTips)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSettings: async (type: NotificationType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getNotificationSettings', 'type', type)
            const localVarPath = `/api/2.0/settings/notification/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of rooms with the disabled notifications
         * @summary Get room notification settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomsNotificationSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/notification/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a notification status for a room with the ID specified in the request.
         * @summary Set room notification status
         * @param {RoomsNotificationsSettingsRequestDto} [roomsNotificationsSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomsNotificationStatus: async (roomsNotificationsSettingsRequestDto?: RoomsNotificationsSettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/notification/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomsNotificationsSettingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables the notification type specified in the request.
         * @summary Enable notifications
         * @param {NotificationSettingsRequestsDto} [notificationSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSettings: async (notificationSettingsRequestsDto?: NotificationSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsNotificationsApi - functional programming interface
 * @export
 */
export const SettingsNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks if the notification type specified in the request is enabled or not.
         * @summary Check notification availability
         * @param {NotificationType} type Notification type (Badges, RoomsActivity, DailyFeed, UsefullTips)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSettings(type: NotificationType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSettings(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsNotificationsApi.getNotificationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of rooms with the disabled notifications
         * @summary Get room notification settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomsNotificationSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomsNotificationSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomsNotificationSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsNotificationsApi.getRoomsNotificationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets a notification status for a room with the ID specified in the request.
         * @summary Set room notification status
         * @param {RoomsNotificationsSettingsRequestDto} [roomsNotificationsSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoomsNotificationStatus(roomsNotificationsSettingsRequestDto?: RoomsNotificationsSettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomsNotificationSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRoomsNotificationStatus(roomsNotificationsSettingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsNotificationsApi.setRoomsNotificationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enables the notification type specified in the request.
         * @summary Enable notifications
         * @param {NotificationSettingsRequestsDto} [notificationSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSettings(notificationSettingsRequestsDto?: NotificationSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSettings(notificationSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsNotificationsApi.setSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsNotificationsApi - factory interface
 * @export
 */
export const SettingsNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsNotificationsApiFp(configuration)
    return {
        /**
         * Checks if the notification type specified in the request is enabled or not.
         * @summary Check notification availability
         * @param {NotificationType} type Notification type (Badges, RoomsActivity, DailyFeed, UsefullTips)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSettings(type: NotificationType, options?: RawAxiosRequestConfig): AxiosPromise<NotificationSettingsWrapper> {
            return localVarFp.getNotificationSettings(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of rooms with the disabled notifications
         * @summary Get room notification settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomsNotificationSettings(options?: RawAxiosRequestConfig): AxiosPromise<RoomsNotificationSettingsWrapper> {
            return localVarFp.getRoomsNotificationSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a notification status for a room with the ID specified in the request.
         * @summary Set room notification status
         * @param {RoomsNotificationsSettingsRequestDto} [roomsNotificationsSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoomsNotificationStatus(roomsNotificationsSettingsRequestDto?: RoomsNotificationsSettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomsNotificationSettingsWrapper> {
            return localVarFp.setRoomsNotificationStatus(roomsNotificationsSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables the notification type specified in the request.
         * @summary Enable notifications
         * @param {NotificationSettingsRequestsDto} [notificationSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSettings(notificationSettingsRequestsDto?: NotificationSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<NotificationSettingsWrapper> {
            return localVarFp.setSettings(notificationSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsNotificationsApi - object-oriented interface
 * @export
 * @class SettingsNotificationsApi
 * @extends {BaseAPI}
 */
export class SettingsNotificationsApi extends BaseAPI {
    /**
     * Checks if the notification type specified in the request is enabled or not.
     * @summary Check notification availability
     * @param {NotificationType} type Notification type (Badges, RoomsActivity, DailyFeed, UsefullTips)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNotificationsApi
     */
    public getNotificationSettings(type: NotificationType, options?: RawAxiosRequestConfig) {
        return SettingsNotificationsApiFp(this.configuration).getNotificationSettings(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of rooms with the disabled notifications
     * @summary Get room notification settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNotificationsApi
     */
    public getRoomsNotificationSettings(options?: RawAxiosRequestConfig) {
        return SettingsNotificationsApiFp(this.configuration).getRoomsNotificationSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a notification status for a room with the ID specified in the request.
     * @summary Set room notification status
     * @param {RoomsNotificationsSettingsRequestDto} [roomsNotificationsSettingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNotificationsApi
     */
    public setRoomsNotificationStatus(roomsNotificationsSettingsRequestDto?: RoomsNotificationsSettingsRequestDto, options?: RawAxiosRequestConfig) {
        return SettingsNotificationsApiFp(this.configuration).setRoomsNotificationStatus(roomsNotificationsSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables the notification type specified in the request.
     * @summary Enable notifications
     * @param {NotificationSettingsRequestsDto} [notificationSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsNotificationsApi
     */
    public setSettings(notificationSettingsRequestsDto?: NotificationSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsNotificationsApiFp(this.configuration).setSettings(notificationSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsOwnerApi - axios parameter creator
 * @export
 */
export const SettingsOwnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the current portal owner with a new one specified in the request.
         * @summary Update the portal owner
         * @param {OwnerIdSettingsRequestDto} [ownerIdSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        owner: async (ownerIdSettingsRequestDto?: OwnerIdSettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/owner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ownerIdSettingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends the instructions to change the DocSpace owner.
         * @summary Send the owner change instructions
         * @param {OwnerIdSettingsRequestDto} [ownerIdSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOwnerChangeInstructions: async (ownerIdSettingsRequestDto?: OwnerIdSettingsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/owner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ownerIdSettingsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsOwnerApi - functional programming interface
 * @export
 */
export const SettingsOwnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsOwnerApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the current portal owner with a new one specified in the request.
         * @summary Update the portal owner
         * @param {OwnerIdSettingsRequestDto} [ownerIdSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async owner(ownerIdSettingsRequestDto?: OwnerIdSettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.owner(ownerIdSettingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsOwnerApi.owner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends the instructions to change the DocSpace owner.
         * @summary Send the owner change instructions
         * @param {OwnerIdSettingsRequestDto} [ownerIdSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendOwnerChangeInstructions(ownerIdSettingsRequestDto?: OwnerIdSettingsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OwnerChangeInstructionsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendOwnerChangeInstructions(ownerIdSettingsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsOwnerApi.sendOwnerChangeInstructions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsOwnerApi - factory interface
 * @export
 */
export const SettingsOwnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsOwnerApiFp(configuration)
    return {
        /**
         * Updates the current portal owner with a new one specified in the request.
         * @summary Update the portal owner
         * @param {OwnerIdSettingsRequestDto} [ownerIdSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        owner(ownerIdSettingsRequestDto?: OwnerIdSettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.owner(ownerIdSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends the instructions to change the DocSpace owner.
         * @summary Send the owner change instructions
         * @param {OwnerIdSettingsRequestDto} [ownerIdSettingsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOwnerChangeInstructions(ownerIdSettingsRequestDto?: OwnerIdSettingsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<OwnerChangeInstructionsWrapper> {
            return localVarFp.sendOwnerChangeInstructions(ownerIdSettingsRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsOwnerApi - object-oriented interface
 * @export
 * @class SettingsOwnerApi
 * @extends {BaseAPI}
 */
export class SettingsOwnerApi extends BaseAPI {
    /**
     * Updates the current portal owner with a new one specified in the request.
     * @summary Update the portal owner
     * @param {OwnerIdSettingsRequestDto} [ownerIdSettingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsOwnerApi
     */
    public owner(ownerIdSettingsRequestDto?: OwnerIdSettingsRequestDto, options?: RawAxiosRequestConfig) {
        return SettingsOwnerApiFp(this.configuration).owner(ownerIdSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends the instructions to change the DocSpace owner.
     * @summary Send the owner change instructions
     * @param {OwnerIdSettingsRequestDto} [ownerIdSettingsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsOwnerApi
     */
    public sendOwnerChangeInstructions(ownerIdSettingsRequestDto?: OwnerIdSettingsRequestDto, options?: RawAxiosRequestConfig) {
        return SettingsOwnerApiFp(this.configuration).sendOwnerChangeInstructions(ownerIdSettingsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsQuotaApi - axios parameter creator
 * @export
 */
export const SettingsQuotaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets user quota
         * @summary Gets user quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuotaSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/userquotasettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the room quota settings specified in the request to the current portal.
         * @summary Save the room quota settings
         * @param {QuotaSettingsRequestsDto} [quotaSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoomQuotaSettings: async (quotaSettingsRequestsDto?: QuotaSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/roomquotasettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quotaSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the tenant quota settings specified in the request to the current portal.
         * @summary Save the tenant quota settings
         * @param {TenantQuotaSettingsRequestsDto} [tenantQuotaSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTenantQuotaSettings: async (tenantQuotaSettingsRequestsDto?: TenantQuotaSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tenantquotasettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantQuotaSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsQuotaApi - functional programming interface
 * @export
 */
export const SettingsQuotaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsQuotaApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets user quota
         * @summary Gets user quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserQuotaSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantUserQuotaSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserQuotaSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsQuotaApi.getUserQuotaSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the room quota settings specified in the request to the current portal.
         * @summary Save the room quota settings
         * @param {QuotaSettingsRequestsDto} [quotaSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRoomQuotaSettings(quotaSettingsRequestsDto?: QuotaSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantRoomQuotaSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRoomQuotaSettings(quotaSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsQuotaApi.saveRoomQuotaSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the tenant quota settings specified in the request to the current portal.
         * @summary Save the tenant quota settings
         * @param {TenantQuotaSettingsRequestsDto} [tenantQuotaSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTenantQuotaSettings(tenantQuotaSettingsRequestsDto?: TenantQuotaSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantQuotaSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTenantQuotaSettings(tenantQuotaSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsQuotaApi.setTenantQuotaSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsQuotaApi - factory interface
 * @export
 */
export const SettingsQuotaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsQuotaApiFp(configuration)
    return {
        /**
         * Gets user quota
         * @summary Gets user quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuotaSettings(options?: RawAxiosRequestConfig): AxiosPromise<TenantUserQuotaSettingsWrapper> {
            return localVarFp.getUserQuotaSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the room quota settings specified in the request to the current portal.
         * @summary Save the room quota settings
         * @param {QuotaSettingsRequestsDto} [quotaSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoomQuotaSettings(quotaSettingsRequestsDto?: QuotaSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<TenantRoomQuotaSettingsWrapper> {
            return localVarFp.saveRoomQuotaSettings(quotaSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the tenant quota settings specified in the request to the current portal.
         * @summary Save the tenant quota settings
         * @param {TenantQuotaSettingsRequestsDto} [tenantQuotaSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTenantQuotaSettings(tenantQuotaSettingsRequestsDto?: TenantQuotaSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<TenantQuotaSettingsWrapper> {
            return localVarFp.setTenantQuotaSettings(tenantQuotaSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsQuotaApi - object-oriented interface
 * @export
 * @class SettingsQuotaApi
 * @extends {BaseAPI}
 */
export class SettingsQuotaApi extends BaseAPI {
    /**
     * Gets user quota
     * @summary Gets user quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsQuotaApi
     */
    public getUserQuotaSettings(options?: RawAxiosRequestConfig) {
        return SettingsQuotaApiFp(this.configuration).getUserQuotaSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the room quota settings specified in the request to the current portal.
     * @summary Save the room quota settings
     * @param {QuotaSettingsRequestsDto} [quotaSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsQuotaApi
     */
    public saveRoomQuotaSettings(quotaSettingsRequestsDto?: QuotaSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsQuotaApiFp(this.configuration).saveRoomQuotaSettings(quotaSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the tenant quota settings specified in the request to the current portal.
     * @summary Save the tenant quota settings
     * @param {TenantQuotaSettingsRequestsDto} [tenantQuotaSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsQuotaApi
     */
    public setTenantQuotaSettings(tenantQuotaSettingsRequestsDto?: TenantQuotaSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsQuotaApiFp(this.configuration).setTenantQuotaSettings(tenantQuotaSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsRebrandingApi - axios parameter creator
 * @export
 */
export const SettingsRebrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the additional white label settings.
         * @summary Delete the additional white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdditionalWhiteLabelSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/rebranding/additional`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the company white label settings.
         * @summary Delete the company white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyWhiteLabelSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/rebranding/company`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the additional white label settings.
         * @summary Get the additional white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalWhiteLabelSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/rebranding/additional`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the company white label settings.
         * @summary Get the company white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyWhiteLabelSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/rebranding/company`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the white label is enabled or not.
         * @summary Check the white label availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnableWhitelabel: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/enablewhitelabel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies if the white label logo text are default or not.
         * @summary Check the default white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsDefaultWhiteLabelLogoText: async (isDark?: boolean, isDefault?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logotext/isdefault`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specifies if the white label logos are default or not.
         * @summary Check the default white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsDefaultWhiteLabelLogos: async (isDark?: boolean, isDefault?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logos/isdefault`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the licensor data.
         * @summary Get the licensor data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicensorData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/companywhitelabel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the white label logo text.
         * @summary Get the white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhiteLabelLogoText: async (isDark?: boolean, isDefault?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logotext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the white label logos.
         * @summary Get the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhiteLabelLogos: async (isDark?: boolean, isDefault?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores the white label logo text.
         * @summary Restore the white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreWhiteLabelLogoText: async (isDark?: boolean, isDefault?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logotext/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores the white label logos.
         * @summary Restore the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreWhiteLabelLogos: async (isDark?: boolean, isDefault?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logos/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the additional white label settings specified in the request.
         * @summary Save the additional white label settings
         * @param {AdditionalWhiteLabelSettingsWrapper} [additionalWhiteLabelSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdditionalWhiteLabelSettings: async (additionalWhiteLabelSettingsWrapper?: AdditionalWhiteLabelSettingsWrapper, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/rebranding/additional`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(additionalWhiteLabelSettingsWrapper, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the company white label settings specified in the request.
         * @summary Save the company white label settings
         * @param {CompanyWhiteLabelSettingsWrapper} [companyWhiteLabelSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCompanyWhiteLabelSettings: async (companyWhiteLabelSettingsWrapper?: CompanyWhiteLabelSettingsWrapper, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/rebranding/company`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyWhiteLabelSettingsWrapper, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the white label logo text specified in the request.
         * @summary Save the white label logo text settings
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {WhiteLabelRequestsDto} [whiteLabelRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelLogoText: async (isDark?: boolean, isDefault?: boolean, whiteLabelRequestsDto?: WhiteLabelRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logotext/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(whiteLabelRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the white label logos specified in the request.
         * @summary Save the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {WhiteLabelRequestsDto} [whiteLabelRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelSettings: async (isDark?: boolean, isDefault?: boolean, whiteLabelRequestsDto?: WhiteLabelRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logos/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(whiteLabelRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the white label logos from files.
         * @summary Save the white label logos from files
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelSettingsFromFiles: async (isDark?: boolean, isDefault?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/whitelabel/logos/savefromfiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (isDark !== undefined) {
                localVarQueryParameter['IsDark'] = isDark;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['IsDefault'] = isDefault;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsRebrandingApi - functional programming interface
 * @export
 */
export const SettingsRebrandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsRebrandingApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the additional white label settings.
         * @summary Delete the additional white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdditionalWhiteLabelSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdditionalWhiteLabelSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAdditionalWhiteLabelSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.deleteAdditionalWhiteLabelSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the company white label settings.
         * @summary Delete the company white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompanyWhiteLabelSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyWhiteLabelSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompanyWhiteLabelSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.deleteCompanyWhiteLabelSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the additional white label settings.
         * @summary Get the additional white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdditionalWhiteLabelSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdditionalWhiteLabelSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdditionalWhiteLabelSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.getAdditionalWhiteLabelSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the company white label settings.
         * @summary Get the company white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyWhiteLabelSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyWhiteLabelSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyWhiteLabelSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.getCompanyWhiteLabelSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the white label is enabled or not.
         * @summary Check the white label availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnableWhitelabel(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnableWhitelabel(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.getEnableWhitelabel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies if the white label logo text are default or not.
         * @summary Check the default white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIsDefaultWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsDefaultWhiteLabelLogosWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIsDefaultWhiteLabelLogoText(isDark, isDefault, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.getIsDefaultWhiteLabelLogoText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specifies if the white label logos are default or not.
         * @summary Check the default white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIsDefaultWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsDefaultWhiteLabelLogosArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIsDefaultWhiteLabelLogos(isDark, isDefault, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.getIsDefaultWhiteLabelLogos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the licensor data.
         * @summary Get the licensor data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicensorData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyWhiteLabelSettingsArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicensorData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.getLicensorData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the white label logo text.
         * @summary Get the white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWhiteLabelLogoText(isDark, isDefault, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.getWhiteLabelLogoText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the white label logos.
         * @summary Get the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WhiteLabelItemArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWhiteLabelLogos(isDark, isDefault, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.getWhiteLabelLogos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restores the white label logo text.
         * @summary Restore the white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreWhiteLabelLogoText(isDark, isDefault, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.restoreWhiteLabelLogoText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restores the white label logos.
         * @summary Restore the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreWhiteLabelLogos(isDark, isDefault, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.restoreWhiteLabelLogos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the additional white label settings specified in the request.
         * @summary Save the additional white label settings
         * @param {AdditionalWhiteLabelSettingsWrapper} [additionalWhiteLabelSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAdditionalWhiteLabelSettings(additionalWhiteLabelSettingsWrapper?: AdditionalWhiteLabelSettingsWrapper, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAdditionalWhiteLabelSettings(additionalWhiteLabelSettingsWrapper, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.saveAdditionalWhiteLabelSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the company white label settings specified in the request.
         * @summary Save the company white label settings
         * @param {CompanyWhiteLabelSettingsWrapper} [companyWhiteLabelSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCompanyWhiteLabelSettings(companyWhiteLabelSettingsWrapper?: CompanyWhiteLabelSettingsWrapper, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCompanyWhiteLabelSettings(companyWhiteLabelSettingsWrapper, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.saveCompanyWhiteLabelSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the white label logo text specified in the request.
         * @summary Save the white label logo text settings
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {WhiteLabelRequestsDto} [whiteLabelRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, whiteLabelRequestsDto?: WhiteLabelRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveWhiteLabelLogoText(isDark, isDefault, whiteLabelRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.saveWhiteLabelLogoText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the white label logos specified in the request.
         * @summary Save the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {WhiteLabelRequestsDto} [whiteLabelRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveWhiteLabelSettings(isDark?: boolean, isDefault?: boolean, whiteLabelRequestsDto?: WhiteLabelRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveWhiteLabelSettings(isDark, isDefault, whiteLabelRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.saveWhiteLabelSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the white label logos from files.
         * @summary Save the white label logos from files
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveWhiteLabelSettingsFromFiles(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveWhiteLabelSettingsFromFiles(isDark, isDefault, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsRebrandingApi.saveWhiteLabelSettingsFromFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsRebrandingApi - factory interface
 * @export
 */
export const SettingsRebrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsRebrandingApiFp(configuration)
    return {
        /**
         * Deletes the additional white label settings.
         * @summary Delete the additional white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdditionalWhiteLabelSettings(options?: RawAxiosRequestConfig): AxiosPromise<AdditionalWhiteLabelSettingsWrapper> {
            return localVarFp.deleteAdditionalWhiteLabelSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the company white label settings.
         * @summary Delete the company white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyWhiteLabelSettings(options?: RawAxiosRequestConfig): AxiosPromise<CompanyWhiteLabelSettingsWrapper> {
            return localVarFp.deleteCompanyWhiteLabelSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the additional white label settings.
         * @summary Get the additional white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalWhiteLabelSettings(options?: RawAxiosRequestConfig): AxiosPromise<AdditionalWhiteLabelSettingsWrapper> {
            return localVarFp.getAdditionalWhiteLabelSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the company white label settings.
         * @summary Get the company white label settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyWhiteLabelSettings(options?: RawAxiosRequestConfig): AxiosPromise<CompanyWhiteLabelSettingsWrapper> {
            return localVarFp.getCompanyWhiteLabelSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the white label is enabled or not.
         * @summary Check the white label availability
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnableWhitelabel(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.getEnableWhitelabel(options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies if the white label logo text are default or not.
         * @summary Check the default white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsDefaultWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<IsDefaultWhiteLabelLogosWrapper> {
            return localVarFp.getIsDefaultWhiteLabelLogoText(isDark, isDefault, options).then((request) => request(axios, basePath));
        },
        /**
         * Specifies if the white label logos are default or not.
         * @summary Check the default white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsDefaultWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<IsDefaultWhiteLabelLogosArrayWrapper> {
            return localVarFp.getIsDefaultWhiteLabelLogos(isDark, isDefault, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the licensor data.
         * @summary Get the licensor data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicensorData(options?: RawAxiosRequestConfig): AxiosPromise<CompanyWhiteLabelSettingsArrayWrapper> {
            return localVarFp.getLicensorData(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the white label logo text.
         * @summary Get the white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.getWhiteLabelLogoText(isDark, isDefault, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the white label logos.
         * @summary Get the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<WhiteLabelItemArrayWrapper> {
            return localVarFp.getWhiteLabelLogos(isDark, isDefault, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores the white label logo text.
         * @summary Restore the white label logo text
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.restoreWhiteLabelLogoText(isDark, isDefault, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores the white label logos.
         * @summary Restore the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.restoreWhiteLabelLogos(isDark, isDefault, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the additional white label settings specified in the request.
         * @summary Save the additional white label settings
         * @param {AdditionalWhiteLabelSettingsWrapper} [additionalWhiteLabelSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdditionalWhiteLabelSettings(additionalWhiteLabelSettingsWrapper?: AdditionalWhiteLabelSettingsWrapper, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.saveAdditionalWhiteLabelSettings(additionalWhiteLabelSettingsWrapper, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the company white label settings specified in the request.
         * @summary Save the company white label settings
         * @param {CompanyWhiteLabelSettingsWrapper} [companyWhiteLabelSettingsWrapper] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCompanyWhiteLabelSettings(companyWhiteLabelSettingsWrapper?: CompanyWhiteLabelSettingsWrapper, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.saveCompanyWhiteLabelSettings(companyWhiteLabelSettingsWrapper, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the white label logo text specified in the request.
         * @summary Save the white label logo text settings
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {WhiteLabelRequestsDto} [whiteLabelRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, whiteLabelRequestsDto?: WhiteLabelRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.saveWhiteLabelLogoText(isDark, isDefault, whiteLabelRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the white label logos specified in the request.
         * @summary Save the white label logos
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {WhiteLabelRequestsDto} [whiteLabelRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelSettings(isDark?: boolean, isDefault?: boolean, whiteLabelRequestsDto?: WhiteLabelRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.saveWhiteLabelSettings(isDark, isDefault, whiteLabelRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the white label logos from files.
         * @summary Save the white label logos from files
         * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
         * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveWhiteLabelSettingsFromFiles(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.saveWhiteLabelSettingsFromFiles(isDark, isDefault, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsRebrandingApi - object-oriented interface
 * @export
 * @class SettingsRebrandingApi
 * @extends {BaseAPI}
 */
export class SettingsRebrandingApi extends BaseAPI {
    /**
     * Deletes the additional white label settings.
     * @summary Delete the additional white label settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public deleteAdditionalWhiteLabelSettings(options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).deleteAdditionalWhiteLabelSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the company white label settings.
     * @summary Delete the company white label settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public deleteCompanyWhiteLabelSettings(options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).deleteCompanyWhiteLabelSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the additional white label settings.
     * @summary Get the additional white label settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public getAdditionalWhiteLabelSettings(options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).getAdditionalWhiteLabelSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the company white label settings.
     * @summary Get the company white label settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public getCompanyWhiteLabelSettings(options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).getCompanyWhiteLabelSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the white label is enabled or not.
     * @summary Check the white label availability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public getEnableWhitelabel(options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).getEnableWhitelabel(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies if the white label logo text are default or not.
     * @summary Check the default white label logo text
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public getIsDefaultWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).getIsDefaultWhiteLabelLogoText(isDark, isDefault, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specifies if the white label logos are default or not.
     * @summary Check the default white label logos
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public getIsDefaultWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).getIsDefaultWhiteLabelLogos(isDark, isDefault, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the licensor data.
     * @summary Get the licensor data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public getLicensorData(options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).getLicensorData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the white label logo text.
     * @summary Get the white label logo text
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public getWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).getWhiteLabelLogoText(isDark, isDefault, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the white label logos.
     * @summary Get the white label logos
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public getWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).getWhiteLabelLogos(isDark, isDefault, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores the white label logo text.
     * @summary Restore the white label logo text
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public restoreWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).restoreWhiteLabelLogoText(isDark, isDefault, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores the white label logos.
     * @summary Restore the white label logos
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public restoreWhiteLabelLogos(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).restoreWhiteLabelLogos(isDark, isDefault, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the additional white label settings specified in the request.
     * @summary Save the additional white label settings
     * @param {AdditionalWhiteLabelSettingsWrapper} [additionalWhiteLabelSettingsWrapper] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public saveAdditionalWhiteLabelSettings(additionalWhiteLabelSettingsWrapper?: AdditionalWhiteLabelSettingsWrapper, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).saveAdditionalWhiteLabelSettings(additionalWhiteLabelSettingsWrapper, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the company white label settings specified in the request.
     * @summary Save the company white label settings
     * @param {CompanyWhiteLabelSettingsWrapper} [companyWhiteLabelSettingsWrapper] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public saveCompanyWhiteLabelSettings(companyWhiteLabelSettingsWrapper?: CompanyWhiteLabelSettingsWrapper, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).saveCompanyWhiteLabelSettings(companyWhiteLabelSettingsWrapper, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the white label logo text specified in the request.
     * @summary Save the white label logo text settings
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {WhiteLabelRequestsDto} [whiteLabelRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public saveWhiteLabelLogoText(isDark?: boolean, isDefault?: boolean, whiteLabelRequestsDto?: WhiteLabelRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).saveWhiteLabelLogoText(isDark, isDefault, whiteLabelRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the white label logos specified in the request.
     * @summary Save the white label logos
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {WhiteLabelRequestsDto} [whiteLabelRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public saveWhiteLabelSettings(isDark?: boolean, isDefault?: boolean, whiteLabelRequestsDto?: WhiteLabelRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).saveWhiteLabelSettings(isDark, isDefault, whiteLabelRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the white label logos from files.
     * @summary Save the white label logos from files
     * @param {boolean} [isDark] Specifies if the logo is for a dark theme or not
     * @param {boolean} [isDefault] Specifies if the logo is for a default tenant or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsRebrandingApi
     */
    public saveWhiteLabelSettingsFromFiles(isDark?: boolean, isDefault?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsRebrandingApiFp(this.configuration).saveWhiteLabelSettingsFromFiles(isDark, isDefault, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsSSOApi - axios parameter creator
 * @export
 */
export const SettingsSSOApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the default portal SSO settings.
         * @summary Get the default SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultSsoSettingsV2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/ssov2/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current portal SSO settings.
         * @summary Get the SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSettingsV2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/ssov2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the SSO settings constants.
         * @summary Get the SSO settings constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSettingsV2Constants: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/ssov2/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the SSO settings of the current portal.
         * @summary Reset the SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSsoSettingsV2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/ssov2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the SSO settings for the current portal.
         * @summary Save the SSO settings
         * @param {SsoSettingsRequestsDto} [ssoSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSsoSettingsV2: async (ssoSettingsRequestsDto?: SsoSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/ssov2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ssoSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsSSOApi - functional programming interface
 * @export
 */
export const SettingsSSOApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsSSOApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the default portal SSO settings.
         * @summary Get the default SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultSsoSettingsV2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoSettingsV2Wrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultSsoSettingsV2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSSOApi.getDefaultSsoSettingsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current portal SSO settings.
         * @summary Get the SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSsoSettingsV2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoSettingsV2Wrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSsoSettingsV2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSSOApi.getSsoSettingsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the SSO settings constants.
         * @summary Get the SSO settings constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSsoSettingsV2Constants(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSsoSettingsV2Constants(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSSOApi.getSsoSettingsV2Constants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the SSO settings of the current portal.
         * @summary Reset the SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetSsoSettingsV2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoSettingsV2Wrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetSsoSettingsV2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSSOApi.resetSsoSettingsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the SSO settings for the current portal.
         * @summary Save the SSO settings
         * @param {SsoSettingsRequestsDto} [ssoSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveSsoSettingsV2(ssoSettingsRequestsDto?: SsoSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoSettingsV2Wrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveSsoSettingsV2(ssoSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSSOApi.saveSsoSettingsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsSSOApi - factory interface
 * @export
 */
export const SettingsSSOApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsSSOApiFp(configuration)
    return {
        /**
         * Returns the default portal SSO settings.
         * @summary Get the default SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultSsoSettingsV2(options?: RawAxiosRequestConfig): AxiosPromise<SsoSettingsV2Wrapper> {
            return localVarFp.getDefaultSsoSettingsV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current portal SSO settings.
         * @summary Get the SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSettingsV2(options?: RawAxiosRequestConfig): AxiosPromise<SsoSettingsV2Wrapper> {
            return localVarFp.getSsoSettingsV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the SSO settings constants.
         * @summary Get the SSO settings constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSettingsV2Constants(options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getSsoSettingsV2Constants(options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the SSO settings of the current portal.
         * @summary Reset the SSO settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSsoSettingsV2(options?: RawAxiosRequestConfig): AxiosPromise<SsoSettingsV2Wrapper> {
            return localVarFp.resetSsoSettingsV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the SSO settings for the current portal.
         * @summary Save the SSO settings
         * @param {SsoSettingsRequestsDto} [ssoSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSsoSettingsV2(ssoSettingsRequestsDto?: SsoSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoSettingsV2Wrapper> {
            return localVarFp.saveSsoSettingsV2(ssoSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsSSOApi - object-oriented interface
 * @export
 * @class SettingsSSOApi
 * @extends {BaseAPI}
 */
export class SettingsSSOApi extends BaseAPI {
    /**
     * Returns the default portal SSO settings.
     * @summary Get the default SSO settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSSOApi
     */
    public getDefaultSsoSettingsV2(options?: RawAxiosRequestConfig) {
        return SettingsSSOApiFp(this.configuration).getDefaultSsoSettingsV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current portal SSO settings.
     * @summary Get the SSO settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSSOApi
     */
    public getSsoSettingsV2(options?: RawAxiosRequestConfig) {
        return SettingsSSOApiFp(this.configuration).getSsoSettingsV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the SSO settings constants.
     * @summary Get the SSO settings constants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSSOApi
     */
    public getSsoSettingsV2Constants(options?: RawAxiosRequestConfig) {
        return SettingsSSOApiFp(this.configuration).getSsoSettingsV2Constants(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the SSO settings of the current portal.
     * @summary Reset the SSO settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSSOApi
     */
    public resetSsoSettingsV2(options?: RawAxiosRequestConfig) {
        return SettingsSSOApiFp(this.configuration).resetSsoSettingsV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the SSO settings for the current portal.
     * @summary Save the SSO settings
     * @param {SsoSettingsRequestsDto} [ssoSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSSOApi
     */
    public saveSsoSettingsV2(ssoSettingsRequestsDto?: SsoSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsSSOApiFp(this.configuration).saveSsoSettingsV2(ssoSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsSecurityApi - axios parameter creator
 * @export
 */
export const SettingsSecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all the enabled modules.
         * @summary Get the enabled modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnabledModules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/modules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the portal password settings.
         * @summary Get the password settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the product administrators with the ID specified in the request.
         * @summary Get the product administrators
         * @param {string} productid Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductAdministrators: async (productid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productid' is not null or undefined
            assertParamExists('getProductAdministrators', 'productid', productid)
            const localVarPath = `/api/2.0/settings/security/administrator/{productid}`
                .replace(`{${"productid"}}`, encodeURIComponent(String(productid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the availability of the module with the ID specified in the request.
         * @summary Get the module availability
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebItemSecurityInfo: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebItemSecurityInfo', 'id', id)
            const localVarPath = `/api/2.0/settings/security/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the security settings for the modules specified in the request.
         * @summary Get the security settings
         * @param {Array<string>} [ids] List of module IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebItemSettingsSecurityInfo: async (ids?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the selected user is a product administrator with the ID specified in the request.
         * @summary Check a product administrator
         * @param {string} [productid] Product ID
         * @param {string} [userid] User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isProductAdministrator: async (productid?: string, userid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/administrator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (productid !== undefined) {
                localVarQueryParameter['productid'] = productid;
            }

            if (userid !== undefined) {
                localVarQueryParameter['userid'] = userid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the access settings to the products with the IDs specified in the request.
         * @summary Set the access settings to products
         * @param {WebItemsSecurityRequestsDto} [webItemsSecurityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccessToWebItems: async (webItemsSecurityRequestsDto?: WebItemsSecurityRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webItemsSecurityRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the selected user as a product administrator with the ID specified in the request.
         * @summary Set a product administrator
         * @param {SecurityRequestsDto} [securityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProductAdministrator: async (securityRequestsDto?: SecurityRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/administrator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(securityRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the security settings to the module with the ID specified in the request.
         * @summary Set the module security settings
         * @param {WebItemSecurityRequestsDto} [webItemSecurityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWebItemSecurity: async (webItemSecurityRequestsDto?: WebItemSecurityRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webItemSecurityRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the portal password settings.
         * @summary Set the password settings
         * @param {PasswordSettingsRequestsDto} [passwordSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSettings: async (passwordSettingsRequestsDto?: PasswordSettingsRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/security/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordSettingsRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsSecurityApi - functional programming interface
 * @export
 */
export const SettingsSecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsSecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all the enabled modules.
         * @summary Get the enabled modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnabledModules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnabledModules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.getEnabledModules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the portal password settings.
         * @summary Get the password settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.getPasswordSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the product administrators with the ID specified in the request.
         * @summary Get the product administrators
         * @param {string} productid Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductAdministrators(productid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductAdministrators(productid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.getProductAdministrators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the availability of the module with the ID specified in the request.
         * @summary Get the module availability
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebItemSecurityInfo(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebItemSecurityInfo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.getWebItemSecurityInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the security settings for the modules specified in the request.
         * @summary Get the security settings
         * @param {Array<string>} [ids] List of module IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebItemSettingsSecurityInfo(ids?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebItemSettingsSecurityInfo(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.getWebItemSettingsSecurityInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the selected user is a product administrator with the ID specified in the request.
         * @summary Check a product administrator
         * @param {string} [productid] Product ID
         * @param {string} [userid] User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isProductAdministrator(productid?: string, userid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductAdministratorWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isProductAdministrator(productid, userid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.isProductAdministrator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the access settings to the products with the IDs specified in the request.
         * @summary Set the access settings to products
         * @param {WebItemsSecurityRequestsDto} [webItemsSecurityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAccessToWebItems(webItemsSecurityRequestsDto?: WebItemsSecurityRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAccessToWebItems(webItemsSecurityRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.setAccessToWebItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the selected user as a product administrator with the ID specified in the request.
         * @summary Set a product administrator
         * @param {SecurityRequestsDto} [securityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProductAdministrator(securityRequestsDto?: SecurityRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductAdministratorWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProductAdministrator(securityRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.setProductAdministrator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the security settings to the module with the ID specified in the request.
         * @summary Set the module security settings
         * @param {WebItemSecurityRequestsDto} [webItemSecurityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWebItemSecurity(webItemSecurityRequestsDto?: WebItemSecurityRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWebItemSecurity(webItemSecurityRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.setWebItemSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the portal password settings.
         * @summary Set the password settings
         * @param {PasswordSettingsRequestsDto} [passwordSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordSettings(passwordSettingsRequestsDto?: PasswordSettingsRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordSettings(passwordSettingsRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsSecurityApi.updatePasswordSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsSecurityApi - factory interface
 * @export
 */
export const SettingsSecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsSecurityApiFp(configuration)
    return {
        /**
         * Returns a list of all the enabled modules.
         * @summary Get the enabled modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnabledModules(options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getEnabledModules(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the portal password settings.
         * @summary Get the password settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSettings(options?: RawAxiosRequestConfig): AxiosPromise<PasswordSettingsWrapper> {
            return localVarFp.getPasswordSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the product administrators with the ID specified in the request.
         * @summary Get the product administrators
         * @param {string} productid Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductAdministrators(productid: string, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeArrayWrapper> {
            return localVarFp.getProductAdministrators(productid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the availability of the module with the ID specified in the request.
         * @summary Get the module availability
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebItemSecurityInfo(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.getWebItemSecurityInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the security settings for the modules specified in the request.
         * @summary Get the security settings
         * @param {Array<string>} [ids] List of module IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebItemSettingsSecurityInfo(ids?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<SecurityArrayWrapper> {
            return localVarFp.getWebItemSettingsSecurityInfo(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the selected user is a product administrator with the ID specified in the request.
         * @summary Check a product administrator
         * @param {string} [productid] Product ID
         * @param {string} [userid] User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isProductAdministrator(productid?: string, userid?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductAdministratorWrapper> {
            return localVarFp.isProductAdministrator(productid, userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the access settings to the products with the IDs specified in the request.
         * @summary Set the access settings to products
         * @param {WebItemsSecurityRequestsDto} [webItemsSecurityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccessToWebItems(webItemsSecurityRequestsDto?: WebItemsSecurityRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<SecurityArrayWrapper> {
            return localVarFp.setAccessToWebItems(webItemsSecurityRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the selected user as a product administrator with the ID specified in the request.
         * @summary Set a product administrator
         * @param {SecurityRequestsDto} [securityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProductAdministrator(securityRequestsDto?: SecurityRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductAdministratorWrapper> {
            return localVarFp.setProductAdministrator(securityRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the security settings to the module with the ID specified in the request.
         * @summary Set the module security settings
         * @param {WebItemSecurityRequestsDto} [webItemSecurityRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWebItemSecurity(webItemSecurityRequestsDto?: WebItemSecurityRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<SecurityArrayWrapper> {
            return localVarFp.setWebItemSecurity(webItemSecurityRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the portal password settings.
         * @summary Set the password settings
         * @param {PasswordSettingsRequestsDto} [passwordSettingsRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSettings(passwordSettingsRequestsDto?: PasswordSettingsRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<PasswordSettingsWrapper> {
            return localVarFp.updatePasswordSettings(passwordSettingsRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsSecurityApi - object-oriented interface
 * @export
 * @class SettingsSecurityApi
 * @extends {BaseAPI}
 */
export class SettingsSecurityApi extends BaseAPI {
    /**
     * Returns a list of all the enabled modules.
     * @summary Get the enabled modules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public getEnabledModules(options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).getEnabledModules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the portal password settings.
     * @summary Get the password settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public getPasswordSettings(options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).getPasswordSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the product administrators with the ID specified in the request.
     * @summary Get the product administrators
     * @param {string} productid Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public getProductAdministrators(productid: string, options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).getProductAdministrators(productid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the availability of the module with the ID specified in the request.
     * @summary Get the module availability
     * @param {string} id Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public getWebItemSecurityInfo(id: string, options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).getWebItemSecurityInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the security settings for the modules specified in the request.
     * @summary Get the security settings
     * @param {Array<string>} [ids] List of module IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public getWebItemSettingsSecurityInfo(ids?: Array<string>, options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).getWebItemSettingsSecurityInfo(ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the selected user is a product administrator with the ID specified in the request.
     * @summary Check a product administrator
     * @param {string} [productid] Product ID
     * @param {string} [userid] User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public isProductAdministrator(productid?: string, userid?: string, options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).isProductAdministrator(productid, userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the access settings to the products with the IDs specified in the request.
     * @summary Set the access settings to products
     * @param {WebItemsSecurityRequestsDto} [webItemsSecurityRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public setAccessToWebItems(webItemsSecurityRequestsDto?: WebItemsSecurityRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).setAccessToWebItems(webItemsSecurityRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the selected user as a product administrator with the ID specified in the request.
     * @summary Set a product administrator
     * @param {SecurityRequestsDto} [securityRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public setProductAdministrator(securityRequestsDto?: SecurityRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).setProductAdministrator(securityRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the security settings to the module with the ID specified in the request.
     * @summary Set the module security settings
     * @param {WebItemSecurityRequestsDto} [webItemSecurityRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public setWebItemSecurity(webItemSecurityRequestsDto?: WebItemSecurityRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).setWebItemSecurity(webItemSecurityRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the portal password settings.
     * @summary Set the password settings
     * @param {PasswordSettingsRequestsDto} [passwordSettingsRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsSecurityApi
     */
    public updatePasswordSettings(passwordSettingsRequestsDto?: PasswordSettingsRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsSecurityApiFp(this.configuration).updatePasswordSettings(passwordSettingsRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsStatisticsApi - axios parameter creator
 * @export
 */
export const SettingsStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the space usage statistics of the module with the ID specified in the request.
         * @summary Get the space usage statistics
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaceUsageStatistics: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSpaceUsageStatistics', 'id', id)
            const localVarPath = `/api/2.0/settings/statistics/spaceusage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsStatisticsApi - functional programming interface
 * @export
 */
export const SettingsStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the space usage statistics of the module with the ID specified in the request.
         * @summary Get the space usage statistics
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpaceUsageStatistics(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageSpaceStatItemArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpaceUsageStatistics(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStatisticsApi.getSpaceUsageStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsStatisticsApi - factory interface
 * @export
 */
export const SettingsStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsStatisticsApiFp(configuration)
    return {
        /**
         * Returns the space usage statistics of the module with the ID specified in the request.
         * @summary Get the space usage statistics
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaceUsageStatistics(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageSpaceStatItemArrayWrapper> {
            return localVarFp.getSpaceUsageStatistics(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsStatisticsApi - object-oriented interface
 * @export
 * @class SettingsStatisticsApi
 * @extends {BaseAPI}
 */
export class SettingsStatisticsApi extends BaseAPI {
    /**
     * Returns the space usage statistics of the module with the ID specified in the request.
     * @summary Get the space usage statistics
     * @param {string} id Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStatisticsApi
     */
    public getSpaceUsageStatistics(id: string, options?: RawAxiosRequestConfig) {
        return SettingsStatisticsApiFp(this.configuration).getSpaceUsageStatistics(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsStorageApi - axios parameter creator
 * @export
 */
export const SettingsStorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all the backup storages.
         * @summary Get the backup storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBackupStorages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the CDN storages.
         * @summary Get the CDN storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCdnStorages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage/cdn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the portal storages.
         * @summary Get storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStorages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all Amazon regions.
         * @summary Get Amazon regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAmazonS3Regions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage/s3/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the storage progress.
         * @summary Get the storage progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageProgress: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the CDN storage settings to the default parameters.
         * @summary Reset the CDN storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCdnToDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage/cdn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the storage settings to the default parameters.
         * @summary Reset the storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetStorageToDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the CDN storage with the parameters specified in the request.
         * @summary Update the CDN storage
         * @param {StorageRequestsDto} [storageRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCdn: async (storageRequestsDto?: StorageRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage/cdn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a storage with the parameters specified in the request.
         * @summary Update a storage
         * @param {StorageRequestsDto} [storageRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage: async (storageRequestsDto?: StorageRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsStorageApi - functional programming interface
 * @export
 */
export const SettingsStorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsStorageApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all the backup storages.
         * @summary Get the backup storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBackupStorages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBackupStorages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.getAllBackupStorages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the CDN storages.
         * @summary Get the CDN storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCdnStorages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCdnStorages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.getAllCdnStorages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the portal storages.
         * @summary Get storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStorages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllStorages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.getAllStorages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all Amazon regions.
         * @summary Get Amazon regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAmazonS3Regions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmazonS3Regions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.getAmazonS3Regions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the storage progress.
         * @summary Get the storage progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageProgress(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoubleWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageProgress(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.getStorageProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the CDN storage settings to the default parameters.
         * @summary Reset the CDN storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetCdnToDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetCdnToDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.resetCdnToDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the storage settings to the default parameters.
         * @summary Reset the storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetStorageToDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetStorageToDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.resetStorageToDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the CDN storage with the parameters specified in the request.
         * @summary Update the CDN storage
         * @param {StorageRequestsDto} [storageRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCdn(storageRequestsDto?: StorageRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdnStorageSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCdn(storageRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.updateCdn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a storage with the parameters specified in the request.
         * @summary Update a storage
         * @param {StorageRequestsDto} [storageRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorage(storageRequestsDto?: StorageRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorage(storageRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsStorageApi.updateStorage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsStorageApi - factory interface
 * @export
 */
export const SettingsStorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsStorageApiFp(configuration)
    return {
        /**
         * Returns a list of all the backup storages.
         * @summary Get the backup storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBackupStorages(options?: RawAxiosRequestConfig): AxiosPromise<StorageArrayWrapper> {
            return localVarFp.getAllBackupStorages(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the CDN storages.
         * @summary Get the CDN storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCdnStorages(options?: RawAxiosRequestConfig): AxiosPromise<StorageArrayWrapper> {
            return localVarFp.getAllCdnStorages(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the portal storages.
         * @summary Get storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStorages(options?: RawAxiosRequestConfig): AxiosPromise<StorageArrayWrapper> {
            return localVarFp.getAllStorages(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all Amazon regions.
         * @summary Get Amazon regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAmazonS3Regions(options?: RawAxiosRequestConfig): AxiosPromise<ObjectWrapper> {
            return localVarFp.getAmazonS3Regions(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the storage progress.
         * @summary Get the storage progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageProgress(options?: RawAxiosRequestConfig): AxiosPromise<DoubleWrapper> {
            return localVarFp.getStorageProgress(options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the CDN storage settings to the default parameters.
         * @summary Reset the CDN storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCdnToDefault(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetCdnToDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the storage settings to the default parameters.
         * @summary Reset the storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetStorageToDefault(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetStorageToDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the CDN storage with the parameters specified in the request.
         * @summary Update the CDN storage
         * @param {StorageRequestsDto} [storageRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCdn(storageRequestsDto?: StorageRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<CdnStorageSettingsWrapper> {
            return localVarFp.updateCdn(storageRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a storage with the parameters specified in the request.
         * @summary Update a storage
         * @param {StorageRequestsDto} [storageRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage(storageRequestsDto?: StorageRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StorageSettingsWrapper> {
            return localVarFp.updateStorage(storageRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsStorageApi - object-oriented interface
 * @export
 * @class SettingsStorageApi
 * @extends {BaseAPI}
 */
export class SettingsStorageApi extends BaseAPI {
    /**
     * Returns a list of all the backup storages.
     * @summary Get the backup storages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public getAllBackupStorages(options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).getAllBackupStorages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the CDN storages.
     * @summary Get the CDN storages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public getAllCdnStorages(options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).getAllCdnStorages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the portal storages.
     * @summary Get storages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public getAllStorages(options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).getAllStorages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all Amazon regions.
     * @summary Get Amazon regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public getAmazonS3Regions(options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).getAmazonS3Regions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the storage progress.
     * @summary Get the storage progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public getStorageProgress(options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).getStorageProgress(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the CDN storage settings to the default parameters.
     * @summary Reset the CDN storage settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public resetCdnToDefault(options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).resetCdnToDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the storage settings to the default parameters.
     * @summary Reset the storage settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public resetStorageToDefault(options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).resetStorageToDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the CDN storage with the parameters specified in the request.
     * @summary Update the CDN storage
     * @param {StorageRequestsDto} [storageRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public updateCdn(storageRequestsDto?: StorageRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).updateCdn(storageRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a storage with the parameters specified in the request.
     * @summary Update a storage
     * @param {StorageRequestsDto} [storageRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsStorageApi
     */
    public updateStorage(storageRequestsDto?: StorageRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsStorageApiFp(this.configuration).updateStorage(storageRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsTFASettingsApi - axios parameter creator
 * @export
 */
export const SettingsTFASettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current two-factor authentication settings.
         * @summary Get the TFA settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTfaSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaapp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates the setup TFA code for the current user.
         * @summary Generate setup code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaAppGenerateSetupCode: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaapp/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the two-factor authentication application codes.
         * @summary Get the TFA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaAppGetCodes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaappcodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlinks the current two-factor authentication application from the user account specified in the request.
         * @summary Unlink the TFA application
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaAppNewApp: async (tfaRequestsDto?: TfaRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaappnewapp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tfaRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the new backup codes for the two-factor authentication application.
         * @summary Update the TFA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaAppRequestNewCodes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaappnewcodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the confirmation email URL for authorization via SMS or TFA application.
         * @summary Get confirmation email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaConfirmUrl: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaapp/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the two-factor authentication settings with the parameters specified in the request.
         * @summary Update the TFA settings
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaSettings: async (tfaRequestsDto?: TfaRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaapp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tfaRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the confirmation email URL for updating TFA settings.
         * @summary Get confirmation email for updating TFA settings
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaSettingsLink: async (tfaRequestsDto?: TfaRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaappwithlink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tfaRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates the two-factor authentication code specified in the request.
         * @summary Validate the TFA code
         * @param {TfaValidateRequestsDto} [tfaValidateRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaValidateAuthCode: async (tfaValidateRequestsDto?: TfaValidateRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tfaapp/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tfaValidateRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsTFASettingsApi - functional programming interface
 * @export
 */
export const SettingsTFASettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsTFASettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current two-factor authentication settings.
         * @summary Get the TFA settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTfaSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TfaSettingsArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTfaSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.getTfaSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates the setup TFA code for the current user.
         * @summary Generate setup code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfaAppGenerateSetupCode(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetupCodeWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfaAppGenerateSetupCode(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.tfaAppGenerateSetupCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the two-factor authentication application codes.
         * @summary Get the TFA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfaAppGetCodes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfaAppGetCodes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.tfaAppGetCodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlinks the current two-factor authentication application from the user account specified in the request.
         * @summary Unlink the TFA application
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfaAppNewApp(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfaAppNewApp(tfaRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.tfaAppNewApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requests the new backup codes for the two-factor authentication application.
         * @summary Update the TFA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfaAppRequestNewCodes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfaAppRequestNewCodes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.tfaAppRequestNewCodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the confirmation email URL for authorization via SMS or TFA application.
         * @summary Get confirmation email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfaConfirmUrl(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfaConfirmUrl(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.tfaConfirmUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the two-factor authentication settings with the parameters specified in the request.
         * @summary Update the TFA settings
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfaSettings(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfaSettings(tfaRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.tfaSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the confirmation email URL for updating TFA settings.
         * @summary Get confirmation email for updating TFA settings
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfaSettingsLink(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfaSettingsLink(tfaRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.tfaSettingsLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates the two-factor authentication code specified in the request.
         * @summary Validate the TFA code
         * @param {TfaValidateRequestsDto} [tfaValidateRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfaValidateAuthCode(tfaValidateRequestsDto?: TfaValidateRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfaValidateAuthCode(tfaValidateRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTFASettingsApi.tfaValidateAuthCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsTFASettingsApi - factory interface
 * @export
 */
export const SettingsTFASettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsTFASettingsApiFp(configuration)
    return {
        /**
         * Returns the current two-factor authentication settings.
         * @summary Get the TFA settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTfaSettings(options?: RawAxiosRequestConfig): AxiosPromise<TfaSettingsArrayWrapper> {
            return localVarFp.getTfaSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates the setup TFA code for the current user.
         * @summary Generate setup code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaAppGenerateSetupCode(options?: RawAxiosRequestConfig): AxiosPromise<SetupCodeWrapper> {
            return localVarFp.tfaAppGenerateSetupCode(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the two-factor authentication application codes.
         * @summary Get the TFA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaAppGetCodes(options?: RawAxiosRequestConfig): AxiosPromise<ObjectArrayWrapper> {
            return localVarFp.tfaAppGetCodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Unlinks the current two-factor authentication application from the user account specified in the request.
         * @summary Unlink the TFA application
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaAppNewApp(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.tfaAppNewApp(tfaRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the new backup codes for the two-factor authentication application.
         * @summary Update the TFA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaAppRequestNewCodes(options?: RawAxiosRequestConfig): AxiosPromise<ObjectArrayWrapper> {
            return localVarFp.tfaAppRequestNewCodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the confirmation email URL for authorization via SMS or TFA application.
         * @summary Get confirmation email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaConfirmUrl(options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.tfaConfirmUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the two-factor authentication settings with the parameters specified in the request.
         * @summary Update the TFA settings
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaSettings(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.tfaSettings(tfaRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the confirmation email URL for updating TFA settings.
         * @summary Get confirmation email for updating TFA settings
         * @param {TfaRequestsDto} [tfaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaSettingsLink(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<StringWrapper> {
            return localVarFp.tfaSettingsLink(tfaRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates the two-factor authentication code specified in the request.
         * @summary Validate the TFA code
         * @param {TfaValidateRequestsDto} [tfaValidateRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfaValidateAuthCode(tfaValidateRequestsDto?: TfaValidateRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.tfaValidateAuthCode(tfaValidateRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsTFASettingsApi - object-oriented interface
 * @export
 * @class SettingsTFASettingsApi
 * @extends {BaseAPI}
 */
export class SettingsTFASettingsApi extends BaseAPI {
    /**
     * Returns the current two-factor authentication settings.
     * @summary Get the TFA settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public getTfaSettings(options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).getTfaSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates the setup TFA code for the current user.
     * @summary Generate setup code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public tfaAppGenerateSetupCode(options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).tfaAppGenerateSetupCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the two-factor authentication application codes.
     * @summary Get the TFA codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public tfaAppGetCodes(options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).tfaAppGetCodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlinks the current two-factor authentication application from the user account specified in the request.
     * @summary Unlink the TFA application
     * @param {TfaRequestsDto} [tfaRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public tfaAppNewApp(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).tfaAppNewApp(tfaRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests the new backup codes for the two-factor authentication application.
     * @summary Update the TFA codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public tfaAppRequestNewCodes(options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).tfaAppRequestNewCodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the confirmation email URL for authorization via SMS or TFA application.
     * @summary Get confirmation email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public tfaConfirmUrl(options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).tfaConfirmUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the two-factor authentication settings with the parameters specified in the request.
     * @summary Update the TFA settings
     * @param {TfaRequestsDto} [tfaRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public tfaSettings(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).tfaSettings(tfaRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the confirmation email URL for updating TFA settings.
     * @summary Get confirmation email for updating TFA settings
     * @param {TfaRequestsDto} [tfaRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public tfaSettingsLink(tfaRequestsDto?: TfaRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).tfaSettingsLink(tfaRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates the two-factor authentication code specified in the request.
     * @summary Validate the TFA code
     * @param {TfaValidateRequestsDto} [tfaValidateRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTFASettingsApi
     */
    public tfaValidateAuthCode(tfaValidateRequestsDto?: TfaValidateRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsTFASettingsApiFp(this.configuration).tfaValidateAuthCode(tfaValidateRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsTeamTemplatesApi - axios parameter creator
 * @export
 */
export const SettingsTeamTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a team template by the ID specified in the request.
         * @summary Get a team template by ID
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peopleSchema: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('peopleSchema', 'id', id)
            const localVarPath = `/api/2.0/settings/customschemas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all portal team templates that allow users to name their organization (or group), add members, and define their activities within the portal.
         * @summary Get team templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peopleSchemas: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/customschemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a custom team template with the parameters specified in the request.
         * @summary Create a custom team template
         * @param {SchemaRequestsDto} [schemaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomNamingSettings: async (schemaRequestsDto?: SchemaRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/customschemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the names from the team template with the ID specified in the request.
         * @summary Save the naming settings
         * @param {SchemaBaseRequestsDto} [schemaBaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveNamingSettings: async (schemaBaseRequestsDto?: SchemaBaseRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/customschemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaBaseRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsTeamTemplatesApi - functional programming interface
 * @export
 */
export const SettingsTeamTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsTeamTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a team template by the ID specified in the request.
         * @summary Get a team template by ID
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async peopleSchema(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaRequestsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.peopleSchema(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTeamTemplatesApi.peopleSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all portal team templates that allow users to name their organization (or group), add members, and define their activities within the portal.
         * @summary Get team templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async peopleSchemas(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaRequestsArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.peopleSchemas(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTeamTemplatesApi.peopleSchemas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a custom team template with the parameters specified in the request.
         * @summary Create a custom team template
         * @param {SchemaRequestsDto} [schemaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCustomNamingSettings(schemaRequestsDto?: SchemaRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaRequestsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCustomNamingSettings(schemaRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTeamTemplatesApi.saveCustomNamingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves the names from the team template with the ID specified in the request.
         * @summary Save the naming settings
         * @param {SchemaBaseRequestsDto} [schemaBaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveNamingSettings(schemaBaseRequestsDto?: SchemaBaseRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaRequestsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveNamingSettings(schemaBaseRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTeamTemplatesApi.saveNamingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsTeamTemplatesApi - factory interface
 * @export
 */
export const SettingsTeamTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsTeamTemplatesApiFp(configuration)
    return {
        /**
         * Returns a team template by the ID specified in the request.
         * @summary Get a team template by ID
         * @param {string} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peopleSchema(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SchemaRequestsWrapper> {
            return localVarFp.peopleSchema(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all portal team templates that allow users to name their organization (or group), add members, and define their activities within the portal.
         * @summary Get team templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peopleSchemas(options?: RawAxiosRequestConfig): AxiosPromise<SchemaRequestsArrayWrapper> {
            return localVarFp.peopleSchemas(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a custom team template with the parameters specified in the request.
         * @summary Create a custom team template
         * @param {SchemaRequestsDto} [schemaRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomNamingSettings(schemaRequestsDto?: SchemaRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<SchemaRequestsWrapper> {
            return localVarFp.saveCustomNamingSettings(schemaRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the names from the team template with the ID specified in the request.
         * @summary Save the naming settings
         * @param {SchemaBaseRequestsDto} [schemaBaseRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveNamingSettings(schemaBaseRequestsDto?: SchemaBaseRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<SchemaRequestsWrapper> {
            return localVarFp.saveNamingSettings(schemaBaseRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsTeamTemplatesApi - object-oriented interface
 * @export
 * @class SettingsTeamTemplatesApi
 * @extends {BaseAPI}
 */
export class SettingsTeamTemplatesApi extends BaseAPI {
    /**
     * Returns a team template by the ID specified in the request.
     * @summary Get a team template by ID
     * @param {string} id Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTeamTemplatesApi
     */
    public peopleSchema(id: string, options?: RawAxiosRequestConfig) {
        return SettingsTeamTemplatesApiFp(this.configuration).peopleSchema(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all portal team templates that allow users to name their organization (or group), add members, and define their activities within the portal.
     * @summary Get team templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTeamTemplatesApi
     */
    public peopleSchemas(options?: RawAxiosRequestConfig) {
        return SettingsTeamTemplatesApiFp(this.configuration).peopleSchemas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a custom team template with the parameters specified in the request.
     * @summary Create a custom team template
     * @param {SchemaRequestsDto} [schemaRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTeamTemplatesApi
     */
    public saveCustomNamingSettings(schemaRequestsDto?: SchemaRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsTeamTemplatesApiFp(this.configuration).saveCustomNamingSettings(schemaRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the names from the team template with the ID specified in the request.
     * @summary Save the naming settings
     * @param {SchemaBaseRequestsDto} [schemaBaseRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTeamTemplatesApi
     */
    public saveNamingSettings(schemaBaseRequestsDto?: SchemaBaseRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsTeamTemplatesApiFp(this.configuration).saveNamingSettings(schemaBaseRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsTipsApi - axios parameter creator
 * @export
 */
export const SettingsTipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if the current user is subscribed to the tips or not.
         * @summary Check the tip subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTipsSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tips/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the tip settings with a parameter specified in the request.
         * @summary Update the tip settings
         * @param {TipsRequestDto} [tipsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTipsSettings: async (tipsRequestDto?: TipsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tipsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the tip subscription.
         * @summary Update the tip subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTipsSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/tips/change/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsTipsApi - functional programming interface
 * @export
 */
export const SettingsTipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsTipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks if the current user is subscribed to the tips or not.
         * @summary Check the tip subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTipsSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTipsSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTipsApi.getTipsSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the tip settings with a parameter specified in the request.
         * @summary Update the tip settings
         * @param {TipsRequestDto} [tipsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTipsSettings(tipsRequestDto?: TipsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipsSettingsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTipsSettings(tipsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTipsApi.updateTipsSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the tip subscription.
         * @summary Update the tip subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTipsSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTipsSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsTipsApi.updateTipsSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsTipsApi - factory interface
 * @export
 */
export const SettingsTipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsTipsApiFp(configuration)
    return {
        /**
         * Checks if the current user is subscribed to the tips or not.
         * @summary Check the tip subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTipsSubscription(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.getTipsSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the tip settings with a parameter specified in the request.
         * @summary Update the tip settings
         * @param {TipsRequestDto} [tipsRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTipsSettings(tipsRequestDto?: TipsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<TipsSettingsWrapper> {
            return localVarFp.updateTipsSettings(tipsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the tip subscription.
         * @summary Update the tip subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTipsSubscription(options?: RawAxiosRequestConfig): AxiosPromise<BooleanWrapper> {
            return localVarFp.updateTipsSubscription(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsTipsApi - object-oriented interface
 * @export
 * @class SettingsTipsApi
 * @extends {BaseAPI}
 */
export class SettingsTipsApi extends BaseAPI {
    /**
     * Checks if the current user is subscribed to the tips or not.
     * @summary Check the tip subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTipsApi
     */
    public getTipsSubscription(options?: RawAxiosRequestConfig) {
        return SettingsTipsApiFp(this.configuration).getTipsSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the tip settings with a parameter specified in the request.
     * @summary Update the tip settings
     * @param {TipsRequestDto} [tipsRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTipsApi
     */
    public updateTipsSettings(tipsRequestDto?: TipsRequestDto, options?: RawAxiosRequestConfig) {
        return SettingsTipsApiFp(this.configuration).updateTipsSettings(tipsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the tip subscription.
     * @summary Update the tip subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsTipsApi
     */
    public updateTipsSubscription(options?: RawAxiosRequestConfig) {
        return SettingsTipsApiFp(this.configuration).updateTipsSubscription(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsWebhooksApi - axios parameter creator
 * @export
 */
export const SettingsWebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new tenant webhook with the parameters specified in the request.
         * @summary Create a webhook
         * @param {WebhooksConfigRequestsDto} [webhooksConfigRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (webhooksConfigRequestsDto?: WebhooksConfigRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhooksConfigRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables a webhook with the ID specified in the request.
         * @summary Disable a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableWebHook: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableWebHook', 'id', id)
            const localVarPath = `/api/2.0/settings/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the logs of the webhook activities.
         * @summary Get webhook logs
         * @param {string} [deliveryFrom] Delivey start time
         * @param {string} [deliveryTo] Delivey end time
         * @param {string} [hookUri] Hook URI
         * @param {number} [webhookId] Webhook ID
         * @param {number} [configId] Config ID
         * @param {number} [eventId] Event ID
         * @param {WebhookGroupStatus} [groupStatus] Webhook group status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJournal: async (deliveryFrom?: string, deliveryTo?: string, hookUri?: string, webhookId?: number, configId?: number, eventId?: number, groupStatus?: WebhookGroupStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/webhooks/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (deliveryFrom !== undefined) {
                localVarQueryParameter['deliveryFrom'] = (deliveryFrom as any instanceof Date) ?
                    (deliveryFrom as any).toISOString() :
                    deliveryFrom;
            }

            if (deliveryTo !== undefined) {
                localVarQueryParameter['deliveryTo'] = (deliveryTo as any instanceof Date) ?
                    (deliveryTo as any).toISOString() :
                    deliveryTo;
            }

            if (hookUri !== undefined) {
                localVarQueryParameter['hookUri'] = hookUri;
            }

            if (webhookId !== undefined) {
                localVarQueryParameter['webhookId'] = webhookId;
            }

            if (configId !== undefined) {
                localVarQueryParameter['configId'] = configId;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (groupStatus !== undefined) {
                localVarQueryParameter['groupStatus'] = groupStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the tenant webhooks.
         * @summary Get webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the tenant webhook with the ID specified in the request.
         * @summary Remove a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeWebhook', 'id', id)
            const localVarPath = `/api/2.0/settings/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retries a webhook with the ID specified in the request.
         * @summary Retry a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryWebhook: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retryWebhook', 'id', id)
            const localVarPath = `/api/2.0/settings/webhook/{id}/retry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retries all the webhooks with the IDs specified in the request.
         * @summary Retry webhooks
         * @param {WebhookRetryRequestsDto} [webhookRetryRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryWebhooks: async (webhookRetryRequestsDto?: WebhookRetryRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/webhook/retry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRetryRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns settings of all webhooks.
         * @summary Get webhook settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the tenant webhook with the parameters specified in the request.
         * @summary Update a webhook
         * @param {WebhooksConfigRequestsDto} [webhooksConfigRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhooksConfigRequestsDto?: WebhooksConfigRequestsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhooksConfigRequestsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsWebhooksApi - functional programming interface
 * @export
 */
export const SettingsWebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsWebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new tenant webhook with the parameters specified in the request.
         * @summary Create a webhook
         * @param {WebhooksConfigRequestsDto} [webhooksConfigRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(webhooksConfigRequestsDto?: WebhooksConfigRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksConfigWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(webhooksConfigRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disables a webhook with the ID specified in the request.
         * @summary Disable a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableWebHook(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableWebHook(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.disableWebHook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the logs of the webhook activities.
         * @summary Get webhook logs
         * @param {string} [deliveryFrom] Delivey start time
         * @param {string} [deliveryTo] Delivey end time
         * @param {string} [hookUri] Hook URI
         * @param {number} [webhookId] Webhook ID
         * @param {number} [configId] Config ID
         * @param {number} [eventId] Event ID
         * @param {WebhookGroupStatus} [groupStatus] Webhook group status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJournal(deliveryFrom?: string, deliveryTo?: string, hookUri?: string, webhookId?: number, configId?: number, eventId?: number, groupStatus?: WebhookGroupStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksLogArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJournal(deliveryFrom, deliveryTo, hookUri, webhookId, configId, eventId, groupStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.getJournal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the tenant webhooks.
         * @summary Get webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantWebhooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksConfigWithStatusArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantWebhooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.getTenantWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the tenant webhook with the ID specified in the request.
         * @summary Remove a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeWebhook(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksConfigWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeWebhook(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.removeWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retries a webhook with the ID specified in the request.
         * @summary Retry a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryWebhook(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksLogWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retryWebhook(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.retryWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retries all the webhooks with the IDs specified in the request.
         * @summary Retry webhooks
         * @param {WebhookRetryRequestsDto} [webhookRetryRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryWebhooks(webhookRetryRequestsDto?: WebhookRetryRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksLogArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retryWebhooks(webhookRetryRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.retryWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns settings of all webhooks.
         * @summary Get webhook settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.settings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the tenant webhook with the parameters specified in the request.
         * @summary Update a webhook
         * @param {WebhooksConfigRequestsDto} [webhooksConfigRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhooksConfigRequestsDto?: WebhooksConfigRequestsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksConfigWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhooksConfigRequestsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsWebhooksApi - factory interface
 * @export
 */
export const SettingsWebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsWebhooksApiFp(configuration)
    return {
        /**
         * Creates a new tenant webhook with the parameters specified in the request.
         * @summary Create a webhook
         * @param {WebhooksConfigRequestsDto} [webhooksConfigRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(webhooksConfigRequestsDto?: WebhooksConfigRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksConfigWrapper> {
            return localVarFp.createWebhook(webhooksConfigRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables a webhook with the ID specified in the request.
         * @summary Disable a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableWebHook(id: number, options?: RawAxiosRequestConfig): AxiosPromise<WebhookWrapper> {
            return localVarFp.disableWebHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the logs of the webhook activities.
         * @summary Get webhook logs
         * @param {string} [deliveryFrom] Delivey start time
         * @param {string} [deliveryTo] Delivey end time
         * @param {string} [hookUri] Hook URI
         * @param {number} [webhookId] Webhook ID
         * @param {number} [configId] Config ID
         * @param {number} [eventId] Event ID
         * @param {WebhookGroupStatus} [groupStatus] Webhook group status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJournal(deliveryFrom?: string, deliveryTo?: string, hookUri?: string, webhookId?: number, configId?: number, eventId?: number, groupStatus?: WebhookGroupStatus, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksLogArrayWrapper> {
            return localVarFp.getJournal(deliveryFrom, deliveryTo, hookUri, webhookId, configId, eventId, groupStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the tenant webhooks.
         * @summary Get webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<WebhooksConfigWithStatusArrayWrapper> {
            return localVarFp.getTenantWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the tenant webhook with the ID specified in the request.
         * @summary Remove a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(id: number, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksConfigWrapper> {
            return localVarFp.removeWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retries a webhook with the ID specified in the request.
         * @summary Retry a webhook
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryWebhook(id: number, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksLogWrapper> {
            return localVarFp.retryWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retries all the webhooks with the IDs specified in the request.
         * @summary Retry webhooks
         * @param {WebhookRetryRequestsDto} [webhookRetryRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryWebhooks(webhookRetryRequestsDto?: WebhookRetryRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksLogArrayWrapper> {
            return localVarFp.retryWebhooks(webhookRetryRequestsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns settings of all webhooks.
         * @summary Get webhook settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settings(options?: RawAxiosRequestConfig): AxiosPromise<WebhookArrayWrapper> {
            return localVarFp.settings(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the tenant webhook with the parameters specified in the request.
         * @summary Update a webhook
         * @param {WebhooksConfigRequestsDto} [webhooksConfigRequestsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhooksConfigRequestsDto?: WebhooksConfigRequestsDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksConfigWrapper> {
            return localVarFp.updateWebhook(webhooksConfigRequestsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsWebhooksApi - object-oriented interface
 * @export
 * @class SettingsWebhooksApi
 * @extends {BaseAPI}
 */
export class SettingsWebhooksApi extends BaseAPI {
    /**
     * Creates a new tenant webhook with the parameters specified in the request.
     * @summary Create a webhook
     * @param {WebhooksConfigRequestsDto} [webhooksConfigRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public createWebhook(webhooksConfigRequestsDto?: WebhooksConfigRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).createWebhook(webhooksConfigRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables a webhook with the ID specified in the request.
     * @summary Disable a webhook
     * @param {number} id Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public disableWebHook(id: number, options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).disableWebHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the logs of the webhook activities.
     * @summary Get webhook logs
     * @param {string} [deliveryFrom] Delivey start time
     * @param {string} [deliveryTo] Delivey end time
     * @param {string} [hookUri] Hook URI
     * @param {number} [webhookId] Webhook ID
     * @param {number} [configId] Config ID
     * @param {number} [eventId] Event ID
     * @param {WebhookGroupStatus} [groupStatus] Webhook group status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public getJournal(deliveryFrom?: string, deliveryTo?: string, hookUri?: string, webhookId?: number, configId?: number, eventId?: number, groupStatus?: WebhookGroupStatus, options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).getJournal(deliveryFrom, deliveryTo, hookUri, webhookId, configId, eventId, groupStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the tenant webhooks.
     * @summary Get webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public getTenantWebhooks(options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).getTenantWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the tenant webhook with the ID specified in the request.
     * @summary Remove a webhook
     * @param {number} id Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public removeWebhook(id: number, options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).removeWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retries a webhook with the ID specified in the request.
     * @summary Retry a webhook
     * @param {number} id Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public retryWebhook(id: number, options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).retryWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retries all the webhooks with the IDs specified in the request.
     * @summary Retry webhooks
     * @param {WebhookRetryRequestsDto} [webhookRetryRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public retryWebhooks(webhookRetryRequestsDto?: WebhookRetryRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).retryWebhooks(webhookRetryRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns settings of all webhooks.
     * @summary Get webhook settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public settings(options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).settings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the tenant webhook with the parameters specified in the request.
     * @summary Update a webhook
     * @param {WebhooksConfigRequestsDto} [webhooksConfigRequestsDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebhooksApi
     */
    public updateWebhook(webhooksConfigRequestsDto?: WebhooksConfigRequestsDto, options?: RawAxiosRequestConfig) {
        return SettingsWebhooksApiFp(this.configuration).updateWebhook(webhooksConfigRequestsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsWebpluginsApi - axios parameter creator
 * @export
 */
export const SettingsWebpluginsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds web plugins from file
         * @summary Adds web plugins from file
         * @param {boolean} [system] System
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebPluginFromFile: async (system?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/webplugins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes web plugins by name specified in request
         * @summary Deletes web plugins by name specified in request
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebPlugin: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteWebPlugin', 'name', name)
            const localVarPath = `/api/2.0/settings/webplugins/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets web plugins by name specified in request
         * @summary Gets web plugins by name specified in request
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebPlugin: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getWebPlugin', 'name', name)
            const localVarPath = `/api/2.0/settings/webplugins/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets web plugins
         * @summary Gets web plugins
         * @param {boolean} [enabled] Enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebPlugins: async (enabled?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/2.0/settings/webplugins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates web plugins
         * @summary Updates web plugins
         * @param {string} name Name
         * @param {WebPluginRequests} [webPluginRequests] Web plugin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebPlugin: async (name: string, webPluginRequests?: WebPluginRequests, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateWebPlugin', 'name', name)
            const localVarPath = `/api/2.0/settings/webplugins/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication asc_auth_key required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webPluginRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsWebpluginsApi - functional programming interface
 * @export
 */
export const SettingsWebpluginsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsWebpluginsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds web plugins from file
         * @summary Adds web plugins from file
         * @param {boolean} [system] System
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWebPluginFromFile(system?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebPluginWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWebPluginFromFile(system, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebpluginsApi.addWebPluginFromFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes web plugins by name specified in request
         * @summary Deletes web plugins by name specified in request
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebPlugin(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebPlugin(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebpluginsApi.deleteWebPlugin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets web plugins by name specified in request
         * @summary Gets web plugins by name specified in request
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebPlugin(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebPluginWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebPlugin(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebpluginsApi.getWebPlugin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets web plugins
         * @summary Gets web plugins
         * @param {boolean} [enabled] Enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebPlugins(enabled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebPluginArrayWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebPlugins(enabled, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebpluginsApi.getWebPlugins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates web plugins
         * @summary Updates web plugins
         * @param {string} name Name
         * @param {WebPluginRequests} [webPluginRequests] Web plugin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebPlugin(name: string, webPluginRequests?: WebPluginRequests, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebPlugin(name, webPluginRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsWebpluginsApi.updateWebPlugin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsWebpluginsApi - factory interface
 * @export
 */
export const SettingsWebpluginsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsWebpluginsApiFp(configuration)
    return {
        /**
         * Adds web plugins from file
         * @summary Adds web plugins from file
         * @param {boolean} [system] System
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebPluginFromFile(system?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<WebPluginWrapper> {
            return localVarFp.addWebPluginFromFile(system, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes web plugins by name specified in request
         * @summary Deletes web plugins by name specified in request
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebPlugin(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebPlugin(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets web plugins by name specified in request
         * @summary Gets web plugins by name specified in request
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebPlugin(name: string, options?: RawAxiosRequestConfig): AxiosPromise<WebPluginWrapper> {
            return localVarFp.getWebPlugin(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets web plugins
         * @summary Gets web plugins
         * @param {boolean} [enabled] Enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebPlugins(enabled?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<WebPluginArrayWrapper> {
            return localVarFp.getWebPlugins(enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates web plugins
         * @summary Updates web plugins
         * @param {string} name Name
         * @param {WebPluginRequests} [webPluginRequests] Web plugin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebPlugin(name: string, webPluginRequests?: WebPluginRequests, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateWebPlugin(name, webPluginRequests, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsWebpluginsApi - object-oriented interface
 * @export
 * @class SettingsWebpluginsApi
 * @extends {BaseAPI}
 */
export class SettingsWebpluginsApi extends BaseAPI {
    /**
     * Adds web plugins from file
     * @summary Adds web plugins from file
     * @param {boolean} [system] System
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebpluginsApi
     */
    public addWebPluginFromFile(system?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsWebpluginsApiFp(this.configuration).addWebPluginFromFile(system, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes web plugins by name specified in request
     * @summary Deletes web plugins by name specified in request
     * @param {string} name Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebpluginsApi
     */
    public deleteWebPlugin(name: string, options?: RawAxiosRequestConfig) {
        return SettingsWebpluginsApiFp(this.configuration).deleteWebPlugin(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets web plugins by name specified in request
     * @summary Gets web plugins by name specified in request
     * @param {string} name Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebpluginsApi
     */
    public getWebPlugin(name: string, options?: RawAxiosRequestConfig) {
        return SettingsWebpluginsApiFp(this.configuration).getWebPlugin(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets web plugins
     * @summary Gets web plugins
     * @param {boolean} [enabled] Enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebpluginsApi
     */
    public getWebPlugins(enabled?: boolean, options?: RawAxiosRequestConfig) {
        return SettingsWebpluginsApiFp(this.configuration).getWebPlugins(enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates web plugins
     * @summary Updates web plugins
     * @param {string} name Name
     * @param {WebPluginRequests} [webPluginRequests] Web plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsWebpluginsApi
     */
    public updateWebPlugin(name: string, webPluginRequests?: WebPluginRequests, options?: RawAxiosRequestConfig) {
        return SettingsWebpluginsApiFp(this.configuration).updateWebPlugin(name, webPluginRequests, options).then((request) => request(this.axios, this.basePath));
    }
}



